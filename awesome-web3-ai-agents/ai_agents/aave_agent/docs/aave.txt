<page>
  <title>Aave Protocol Overview</title>
  <url>https://aave.com/docs</url>
  <content>[](https://aave.com/docs)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>Aave</title>
  <url>https://aave.com/</url>
  <content>Access the full power of DeFi.
------------------------------

Aave is the world’s largest liquidity protocol. Supply, borrow, swap, stake and more.

$ billion of liquidity currently supplied in Aave.

Meet Aave.
----------

Earn interest and borrow assets.

Aave by the numbers.
--------------------

Aave is one of the largest DeFi protocols with billions of dollars in weekly volume across Ethereum and 12+ networks.

 Net deposits supplied across 13 networks.

 Average stablecoin supply APY Ethereum network, past year.

 Average stablecoin borrow APR Ethereum network, past year.

DeFi, unlocked.
---------------

### Swap

Swap any ERC-20, even those borrowed or supplied.

### Stake

Earn rewards for securing the protocol.

### Health Factor

Easily track the risk level of your borrow positions.

### Multi-Network

Deployable on any EVM compatible network.

### Non-Custodial

Users maintain control over their own funds throughout the supplying and borrowing process.

### Transparent

The Aave Protocol is open source and transactions are visible to anyone.

### Community Governed

AAVE token holders decide which assets are listed and steer protocol development.

### Composability

Integrating Aave's liquidity pools and interest rate mechanisms enables the creation of diverse products and applications.

GHO
---

GHO is the only decentralised, overcollateralised stablecoin native to the Aave Protocol.

[Learn More](https://aave.com/gho)

%

Collateralisation30 Day Avg

Aave everywhere.
----------------

Join Aave’s growing constellation of builders.

Trusted by the best.
--------------------

Aave Protocol has been trusted by leading institutions and companies.

Governed by you & others.
-------------------------

AAVE token holders guide the Aave Protocol via procedures, voting, and smart contract execution.

[Go to the Forum](https://governance.aave.com/)

Serious security.
-----------------

Peace of mind by design.

### Extensive Audits

Peace of mind supported by multiple audits by the world’s leading security firms.

[Learn More](https://aave.com/security)

### Bug Bounty

Security is a top priority. Report vulnerabilities or bugs responsibly and get rewarded.

[Learn More](https://immunefi.com/bug-bounty/aave/)

### Shortfall Secured

The Aave Protocol is secured with a backstop against protocol insolvency.

[Learn More](https://aave.com/help/safety-module)

* * *

FAQs
----

Aave is a decentralised non-custodial liquidity protocol where users can participate as suppliers or borrowers. Suppliers provide liquidity to the market while earning interest, and borrowers can access liquidity by providing collateral that exceeds the borrowed amount.

Supplied tokens are stored in publicly accessible smart contracts that enable overcollateralised borrowing according to governance-approved parameters. The Aave Protocol smart contracts have been audited and formally verified by third parties.

No protocol can be considered entirely risk free, but extensive steps have been taken to minimize these risks as much as possible -- the Aave Protocol code is publicly available and auditable by anyone, and has been audited by multiple smart contract auditors. Any code changes must be executed through the onchain governance processes. Additionally, there is an ongoing bug bounty campaign and service providers specializing in technical reviews and risk mitigation.

AAVE is used as the centre of gravity of Aave Protocol governance. AAVE is used to vote and decide on the outcome of Aave Improvement Proposals (AIPs). Apart from this, AAVE can be staked within the protocol Safety Module to provide a backstop in the case of a shortfall event, and earn incentives for doing so.

[See More](https://aave.com/faq)</content>
</page>

<page>
  <title>Brand</title>
  <url>https://aave.com/brand</url>
  <content>* * *

Typography
----------

The three typefaces that define the brand.

* * *

* * *

* * *

* * *

### Suggested usage

Use colors with adequate contrast.

Give the mark enough spacing.

Use the logos as provided. Treat them with care.

Use the full logo when more brand context is needed.

### Things to avoid

Placing the ghost on top of the Aave wordmark.

Stretching or deforming the mark in a non-uniform way.

Rotating the mark or flipping it upside-down awkwardly.

Presenting the ghost with negative emotions.

Using multiple colors within the mark.

Cropping the mark. Especially in a creepy way.

Using patterns, gradients or shadows.

Using other fonts next to the ghost logo as the wordmark.

* * *

FAQs
----

The Aave logo should be used in its original form without any modifications. It should be clearly visible and not distorted. The logo should also maintain a minimum clear space around it to ensure it stands out.

You can use the Aave logo on your website or promotional materials, provided your usage doesn't misrepresent the Aave brand. Visual assets should not be altered, combined with other logos, or used in a way that misrepresents the Aave brand.

Yes, we encourage you to stay true to the Aave brand while creating your own assets. Start with one of the derivative logos.</content>
</page>

<page>
  <title>FAQ</title>
  <url>https://aave.com/faq</url>
  <content>* * *

General
-------

Aave is a decentralised non-custodial liquidity protocol where users can participate as suppliers or borrowers. Suppliers provide liquidity to the market while earning interest, and borrowers can access liquidity by providing collateral that exceeds the borrowed amount.

Aave is a decentralised, non-custodial liquidity protocol that is completely permissionless, meaning anyone can access it. Users can interact with Aave through a user-friendly interface or directly with its smart contracts on supported blockchain networks. This openness also enables the creation of third-party services or applications that integrate with the protocol.

To interact with the Aave Protocol, simply connect your crypto wallet and supply your preferred asset and amount. Once supplied, you'll earn passive income based on market borrowing demand. Additionally, your supplied assets can be used as collateral, enabling you to borrow other assets.

Yes, you need a wallet to interact with Aave. Each instance of the Aave Protocol is deployed to a blockchain network. To interact with Aave, you need a wallet on the corresponding network such as a hardware wallet, browser extension, mobile wallet, multi-signature wallets, among others.

When interacting with an Aave Protocol interface, wallets are connected using methods such as mobile wallets (Family), browser wallets (MetaMask, Rabby, etc.), WalletConnect, and more. These connection methods are utilized to prompt for messages and transactions to be signed in the connected wallet.

Interacting with the Aave Protocol requires transactions on Ethereum or other blockchain networks where Aave is deployed. These transactions may incur gas fees, which are non-refundable network transaction fees determined by the network status and transaction complexity.

Transaction costs are typically highest on Ethereum, and significantly cheaper on all other networks, which can be compared

[here](https://www.growthepie.xyz/fundamentals/transaction-costs). The connected wallet will ask you to confirm the gas fee when signing a transaction.

There are multiple interfaces available to access the Aave Protocol. Below are just a few examples:

*   [Aave Labs Interface](https://app.aave.com/)
*   All functionalities + leverage and auto liquidation (repayment with collateral) through [DeFi Saver](https://app.defisaver.com/aave).
*   Flash Loans, supply and withdrawal from [Furucombo](https://furucombo.app/) interface.
*   Supply and withdraw from [Argent wallet](https://www.argent.xyz/).
*   Manage positions via smart account with [Brahma Console](https://console.brahma.fi/).
*   Asset management with [Fireblocks](https://www.fireblocks.com/).
*   All actions are available directly through protocol smart contracts, which can be accessed through block explorers or code by following the guidelines available in the [docs](https://aave.com/docs).

Be careful. Aave never advertises on any social media platform or search engine and does not have any downloadable mobile application available. If you find one, it is a scam. Aave Protocol will never ask for your wallet seed phrase.

You can use Aave in a simulation environment designed for testing and development. In this environment, the assets are not real and have no economic value.

1.  Go to the [Aave Labs Interface](https://app.aave.com/), select the settings button on the top right corner, enable testnet view.
2.  Switch to the testnet you wish to utilize over your wallet provider.
3.  Make sure to have the native asset for the specific network.
4.  Get some tokens from the test client faucet.

No central entity, including Aave Labs or any individual contributor, has the authority or ability to freeze or alter individual user positions within the Aave ecosystem. The Aave Protocol is fully decentralized and governed by the Aave Decentralized Autonomous Organization (DAO), which is controlled by AAVE token holders. As such, users maintain complete self-custody of their funds, and there is no mechanism for freezing or modifying individual positions by any entity.

**Risk Management Controls:** While individual positions are untouchable, the protocol includes specific risk management functions designed to safeguard the overall system. These functions are strictly limited to broader protocol actions and do not extend to individual user positions:

1\. **PoolAdmin Role**: In Aave V2, the PoolAdmin can only pause all interactions within the entire pool of assets.

2\. **EmergencyAdmin Role**: In Aave V3, the EmergencyAdmin role — currently held by the Aave Guardian — can pause specific reserves for purposes of risk management. However, even this action is limited to the reserve level and does not allow for freezing or altering individual positions. These roles are designed to protect the integrity of the protocol as a whole and do not have the capability to interfere with or directly manage individual user funds. For detailed information on these roles and their specific limitations, please refer to the

[Aave Permissions Book](https://github.com/bgd-labs/aave-permissions-book)

and the

[governance forum](https://governance.aave.com/).

Approving tokens is a necessary step when performing actions that involve transferring tokens to a smart contract, such as supplying and repaying tokens to the Aave Protocol. If a token approval is required, frontends such as the

[Aave Labs interface](https://app.aave.com/)

will prompt users to perform the approval with one of the following methods:

**Transaction**: a transaction is an onchain action that requires gas fees and time to confirm. You will be prompted to approve/pay for the gas fee to facilitate the transaction.

**Signature**: when a signature approval is required to transfer tokens, you will be prompted to sign a message with the same wallet making the transaction. Message signing is free and instant, however, it is only available for certain tokens (

[EIP-2612](https://medium.com/noncept/understanding-eip-2612-and-erc20-permit-43ce8b829bd5)

compatible), and wallet types (private key wallets).

Risk
----

No protocol can be considered entirely risk free, but extensive steps have been taken to minimize these risks as much as possible – the Aave Protocol code is publicly available and auditable by anyone, and has been audited by multiple

[smart contract auditors](https://aave.com/security). Any code changes must be executed through the onchain governance processes. Additionally, there is an ongoing

[bug bounty campaign](https://immunefi.com/bounty/aave)

and service providers specializing in technical reviews and risk mitigation. It is recommended to use or migrate to the latest version of the protocol (Aave V3) due to the introduction of granular risk parameters such as supply caps, borrow caps, and isolated collateral assets.

Different risk categories are explained in detail below. You can find additional risk and security related information in the

[risk framework](https://aave.com/docs/concepts/risks)

and

[security and audits](https://aave.com/security)

sections.

#### Smart Contract Risk

Smart contract risk involves the potential for bugs or vulnerabilities within the Aave Protocol code or the underlying reserve tokens.

#### Oracle Risk

Oracle risk arises from the reliance on third-party data providers for price feeds and other external data such as redemption ratio for liquid staking tokens. If an oracle fails or is compromised, it could lead to incorrect valuations of assets.

#### Collateral Risk

Collateral risk pertains to the value and stability of assets used as collateral. The inability to liquidate collateral due to rapid decrease in value or insufficient external liquidity can result in bad debt.

#### Network / Bridge Risk

Network or bridge risk involves the potential issues related to the underlying blockchain networks and bridges upon which the Aave Protocol operates. These risks include congestion, censorship, or security vulnerabilities.

**Smart Contract Risk**

To mitigate smart contract risks, the Aave Protocol code is publicly available and has been audited by multiple [smart contract auditors](https://aave.com/security). Aave employs onchain governance, which validates that any changes to the protocol are thoroughly vetted and approved by the community. Additionally, service providers contribute their expertise to identify and mitigate potential risks. The protocol also runs an ongoing bug bounty program that encourages external developers to find and report vulnerabilities.

**Oracle Risk**

Aave mitigates oracle risks by using decentralised oracles such as Chainlink to provide reliable and tamper-resistant price and redemption ratio feeds.

**Collateral Risk**

To address collateral risks, the Aave DAO engages risk service providers who continuously monitor the collateral assets and market conditions to provide insights and adjustments. The protocol sets risk parameters such as loan-to-value (LTV) and liquidation thresholds to promote the maintenance of overcollateralized borrow positions. Onchain governance allows the community to adjust these risk parameters as needed to respond to changing market conditions, further safeguarding the protocol.

**Network / Bridge Risk**

Aave Governance has adopted a robust [network onboarding framework](https://governance.aave.com/t/bgd-aave-v3-deployments-technical-evaluation-framework-of-a-network/10237) to thoroughly vet new networks and bridges before integration. Onchain governance oversees decisions related to network and bridge integrations, ensuring community participation and scrutiny. This comprehensive approach helps to mitigate network and bridge risks, enhancing the security and reliability of the Aave Protocol.

Supplying & Earning
-------------------

Browse to the "Supply" section and click on "Supply" for the asset you want to supply. Select the amount you'd like to supply and submit your transaction. Once the transaction is confirmed, your supply is successfully registered and you begin earning interest.

Transferring tokens on an Ethereum based network requires a token approval from your self-custodial wallet. This must be performed with a transaction or signed message prior to the supply.

Suppliers receive continuous earnings that evolve with market conditions based on:

*   **The interest rate payment on borrow positions:** Suppliers share the interests paid by borrowers corresponding to the average borrow rate times the utilization rate. The higher the utilization of a reserve, the higher the yield for suppliers.
*   **Flash Loan fees:** Suppliers receive a share of the Flash Loan fees corresponding to 0.09% of the Flash Loan volume.

You can find the current supply rate for each token in the Markets tab of the

[Aave Labs Interface](https://app.aave.com/markets). Historic rates can be viewed by clicking on individual tokens to view their corresponding reserve details page.

There is no minimum amount to supply.

However, assets on Aave V3 markets may have a supply cap parameter which limits the total amount that can be supplied of a particular asset.

Supplied tokens are stored in publicly accessible smart contracts that enable overcollateralised borrowing according to governance-approved parameters. The Aave Protocol smart contracts have been audited and formally verified by third parties.

Withdrawing from the Aave Protocol occurs on the Pool smart contract. Withdrawal transactions can be performed through the

[Aave Labs Interface](https://app.aave.com/)

by navigating to the "Dashboard" section and clicking “Withdraw.” Select the amount to withdraw and submit the transaction.

You need to make sure there is enough liquidity (not borrowed) in order to withdraw, if this is not the case, you need to wait for more liquidity from suppliers or borrowers repaying.

Additionally, the

[Aave Labs Interface](https://app.aave.com/)

has a “Withdraw & Switch” feature to enable withdrawing into other tokens.

Yes. After supplying your assets, you are able to unselect the asset so that it will not be used as collateral. The opt-out is available in the "Supply" section within your dashboard. Simply switch the "use as collateral" button on the asset you would prefer to opt-out from being used as a collateral.

You can withdraw your assets without opting out of using them as collateral, as long as those funds are not actively being used to borrow and provided the withdrawal amount would not cause a liquidation on your borrow positions.

Borrowing
---------

Before borrowing you need to supply approved asset to be used as collateral (check out the Supplying & Earning FAQ section for more info). After this, you can execute a borrow from the Aave smart contracts or a user interface. On the

[Aave Labs Interface](https://app.aave.com/), head to the Borrow section and click on “Borrow” for the asset you want to borrow. Adjust the amount you need based on the available collateral balance, and confirm the transaction in your wallet.

The maximum amount you can borrow depends on the value you have supplied, the available liquidity, and the asset borrow cap. For example, you can’t borrow an asset if there is not enough liquidity or if your health factor doesn’t allow you to. You can find all collateral available and their specific borrow parameters in the

[risk parameters dashboard](https://aave.com/docs/resources/parameters).

Selling your assets means closing your position on that particular asset. Hence, if you are long on the asset, you would not be entitled to the potential upside value gain. By borrowing you are able to obtain liquidity (working capital) without selling your assets. Users are mainly borrowing for unexpected expenses, leveraging their holdings or for new investment opportunities.

Borrow positions can be repaid through Aave smart contracts or a user interface. On the

[Aave Labs Interface](https://app.aave.com/), go to the Borrowings section of your dashboard and click on the "Repay" button for the asset you borrowed and want to repay. Select the amount to repay and confirm the transaction.

You repay your borrow position in the same asset you borrowed. For example, if you borrow 1 GHO you will pay back 1 GHO + interest accrued. The

[Aave Labs Interface](https://app.aave.com/)

also integrates a repay with collateral feature, which uses flashloans and DEX integrations to allow borrow positions to be repaid with aTokens. Availability of repay with collateral feature on Aave markets can be found

[here](https://aave.com/docs/developers/smart-contracts/switch-adapters#switch-adapters).

The interest rate you pay for borrowing assets depends on the supply and demand ratio of the asset and interest rate curve parameters determined by Aave Governance.

You can find the current borrow rate for each borrowable token in the Markets tab of the

[Aave Labs Interface](https://app.aave.com/markets). Historic rates can be viewed by clicking on individual tokens to view their corresponding reserve details page.

There is no fixed time period to pay back the borrow position. As long as your position is properly collateralised, you can borrow for an undefined period. However, as time passes, the accrued interest will grow making your health factor decrease, which might result in your supplied assets becoming more likely to be liquidated.

Liquidations
------------

Health factor is the numeric representation of the safety of a borrow position, calculated as:

Total Collateral Value \* Weighted Average Liquidation Threshold / Total Borrow Value

Liquidation Threshold is a parameter determined by Aave Governance for each collateral asset, which is the maximum percentage of value that can be borrowed against a collateral asset. A health factor below 1 represents a borrow position that is eligible for liquidation.

For example, if you supply $10,000 in ETH with an 80% threshold and borrow $6,000 in USDC, your health factor = 10000 \* 0.8 / 6000 = 1.333.

Depending on the value fluctuation of your supplies, the health factor will increase or decrease. If your health factor increases, it will improve your borrow position by making the liquidation threshold more unlikely to be reached. In the case that the value of your collateralised assets against the borrowed assets decreases, your health factor is also reduced, resulting in increased liquidation risk.

A liquidation is a process that occurs when a borrower's health factor goes below 1 because their collateral value does not properly cover their borrow value. This can happen when the collateral value decreases and /or when the borrow position value increases beyond the liquidation threshold of the collateral assets.

In a liquidation, up to 50% of a borrower's debt is repaid and that value + the liquidation fee is taken from the collateral available, so after a liquidation that amount liquidated from your borrow position is repaid.

Liquidations are a permissionless feature of the Aave Protocol. If a borrow position has insufficient collateral to cover the liquidation threshold, then any address on the network is able to initiate a liquidation transaction.

The liquidation penalty (or bonus for liquidators) depends on the asset used as collateral. You can find every asset's liquidation fee in the

[risk parameters dashboard](https://aave.com/docs/resources/parameters).

**Example 1**

Bob supplies 10 ETH and borrows 5 ETH worth of GHO. If Bob’s Health Factor drops below 1 his borrow position will be eligible for liquidation. A liquidator can repay up to 50% of a single borrowed amount = 2.5 ETH worth of GHO. In return, the liquidator can claim a single collateral which is ETH (5% bonus).

The liquidator claims 2.5 + 0.125 ETH for repaying 2.5 ETH worth of GHO.

**Example 2**

Bob supplies 5 ETH and 4 ETH worth of YFI, and borrows 5 ETH worth of GHO. If Bob’s Health Factor drops below 1 his borrow position will be eligible for liquidation. A liquidator can repay up to 50% of a single borrowed amount = 2.5 ETH worth of GHO. In return, the liquidator can claim a single collateral, as the liquidation bonus is higher for YFI (15%) than ETH (5%) the liquidator chooses to claim YFI.

The liquidator claims 2.5 + 0.375 ETH worth of YFI for repaying 2.5 ETH worth of GHO.

Health Factor represents the ratio of collateral to borrow value. There is not an exact answer as to what constitutes a "safe" health factor as it depends on the volatility and correlation of collateral and borrow asset prices.

Each collateral and borrow asset has a corresponding oracle that reports the price of the token with respect to a base currency (typically USD). In general, if the collateral and borrow assets are highly correlated with respect to the base currency (such as supplying and borrowing only stablecoins or ETH-correlated assets), a lower health factor can be considered safe compared to a position where assets are not correlated.

[Simulation tools](https://defisim.xyz/)

can be used to estimate the effects of price movements and accrued interest on health factor.

The liquidation price of an account is a point at which the balances and oracle prices of the collateral and borrow positions results in a health factor < 1.0. Health factor depends on the balances and oracle prices of all collateral and borrow tokens, so liquidation price is not a single point, it is a curve of combinations.

[Simulation tools](https://defisim.xyz/)

can be used to estimate the effects of price movements and accrued interest on health factor, and estimate the most likely combinations that can result in liquidation.

To avoid liquidation you can raise your health factor by supplying more collateral assets or repaying part of your borrow position. By default, repayments increase your health factor more than supplies. Also, it's important to monitor your health factor and keep it high to avoid a liquidation. Keeping your health factor over 2, for example, gives you more of a margin to avoid a liquidation.

Tools that can help you with this:

*   You can simulate Health Factor movements using [DeFi Simulator](https://defisim.xyz/).
*   You can auto liquidate your borrow position using [DeFi Saver](https://app.defisaver.com/aave).

You should be mindful of stablecoin price fluctuations due to market conditions and how it might affect your Health Factor. For example, the market price of USDC 1.00 might not equal exactly USD 1.00, but USD 0.95, for example. The price fluctuations of stablecoins, like any assets, affects your Health Factor.

Governance
----------

The Aave Protocol is governed by the AAVE token holder community through procedures, voting, and smart contract execution, collectively known as Aave Governance.

All instances of the Aave Protocol are governed by the AAVE, stkAAVE, and aAAVE token holders on Ethereum mainnet.

The

[Governance Process](https://aave.com/docs/primitives/governance)

guide details the proposal lifecycle from idea to execution, which includes phases for discussion → temp check voting → onchain voting and execution.

In order to vote you need to have AAVE, stkAAVE (Staked AAVE), or aAAVE (AAVE supplied to Ethereum V3 market) tokens on Ethereum mainnet. Voting power is the sum of token balances and incoming delegations.

Voting occurs through Aave Governance smart contracts. There are multiple interfaces that can be used to access voting such as the

[Aave Labs](https://app.aave.com/governance),

[BGD Labs](https://vote.onaave.com/), and

[Tally](https://www.tally.xyz/gov/aave)

governance interfaces.

The threshold is dynamic and can change based on the quorum + differential of votes for/against an AIP.

If there are very few votes against an AIP, the threshold will remain the same. However, if the votes against the AIP are more substantial, then the threshold can be moved up so there must be more votes in favor for the AIP to pass. This is to validate that an AIP has overwhelming approval before it is implemented.

For example:

*   If the quorum is 20%, the differential is 15% and 2% of the total votes are against the AIP, the threshold would remain at 20% (because 15+2 = 17 < 20).
*   If the quorum is 20%, the differential is 15% and 6% of the total votes are against the AIP, then the threshold would be raised to 21% (because 15+6=21), so more "yae" votes would be required for the AIP to pass.

The Aave Treasury is a smart contract instance on each network where the protocol is deployed, controlled by Aave Governance.

Each borrowable reserve in an Aave market has a parameter called reserve factor, which is the percentage of borrow interest accumulated to the treasury and is determined on a per-asset basis by Aave Governance.

Participation in Aave Governance is optional. Users can access the Aave Protocol without participating in governance.

Safety Module
-------------

The Aave Safety Module is a mechanism designed to protect the protocol in case of a shortfall event. Users can stake AAVE (stkAAVE), GHO (stkGHO), or AAVE/wstETH liquidity pool tokens (stkABPT) in the Safety Module to act as a backstop, earning rewards in return. This helps to maintain the stability and security of the Aave ecosystem.

Staking consists of supplying supported tokens within the protocol

[Safety Module](https://aave.com/help/safety-module). The purpose of staking is to act as a mitigation tool in case of a shortfall event. As an incentive for this, Safety Module stakers will receive Safety Incentives.

In the case of a shortfall event, Aave Governance can initiate a transaction to utilize Safety Module funds up to the maximum slashing percentage to cover the deficit.

The maximum slashing percentage for each staking token is determined by Aave Governance, currently 33% for stkAAVE / stkABPT and 99% for stkGHO.

Stakers within the Safety Module receive incentives with assets and emission rates determined by Aave Governance.

Staking can be performed through the

[Aave Labs Interface](https://app.aave.com/)

Staking section. Over the staking section select 'stake', input the amount to stake and click on 'stake'. Then proceed to send 2 transactions to stake your AAVE:

1.  **Approve:** This is a required transaction prior to the staking that allows the staking contract to move your AAVE tokens. This transaction won't be required if you perform additional staking actions unless you revoke the approval.
2.  **Stake AAVE:** This transaction performs the action to stake AAVE tokens. When confirmed, your tokens will be staked in the Safety Module.

If you want to stop staking, head over to the

[Aave Labs Interface](https://app.aave.com/)

in the Staking section. Over the staking section select 'Unstake', input the amount and click on 'unstake'.

*   If you did not activate the cooldown period, you will need to activate it. This consists of 1 transaction to activate the cooldown. When the cooldown period finishes, you will be able to unstake by following the next step.
*   **Unstake AAVE:** This transaction performs the action to unstake AAVE tokens. When confirmed, your AAVE tokens will be back in your wallet!

After the cooldown period passes there is a 2-day window to unstake. If you do not unstake during that period you will need to activate the cooldown again.

The cooldown period is the time required prior to unstaking your tokens. You must start the cooldown period before you can unstake your tokens. You can start the cooldown period by going to the staking section, select 'unstake' and click on 'activate cooldown'. It will require one transaction to be sent.

The cooldown period is currently 20 days, but could be modified in the future by an Aave Governance proposal.

**IMPORTANT:** After the cooldown period is complete, you have a 2-day window where you can unstake. If you do not unstake during that period, you will have to start the cooldown process over again.

Example:

*   If the cooldown period was activated 20 days and 4 hours ago, you can unstake.
*   If the cooldown period was activated 22 days and 2 hours ago, you can not unstake, and you will need to start the 20-day cooldown period again.

You can stake more AAVE tokens in the Safety Module or receive stkAAVE, but that would increase your cooldown period based on the amount received. Even if the amount received is big enough, it will reset your cooldown period requiring you to activate it again before you can unstake.

You can claim your rewards at any time on the staking section by clicking on "Claim". The AAVE tokens from the reward will be in your connected wallet as soon as the transaction is confirmed.

GHO Stablecoin
--------------

GHO is a decentralised, overcollateralised stablecoin that is fully backed, transparent, and native to the Aave Protocol.

The

[GHO Documentation](https://aave.com/docs/developers/gho)

is a comprehensive resource that explains the core mechanics of how the GHO stablecoin operates.

Borrowers and suppliers can mint GHO using assets they have supplied into V3 as collateral on Ethereum markets, while continuing to earn interests on their underlying assets.

The GHO pool functions differently from existing assets, but borrowing it will work similarly as other available assets on the different markets in the protocol.

1.  Supply Collateral
2.  Borrow GHO
3.  Repay GHO and Accrued Interest (real-time)
4.  Repaid interest will be redirected to the DAO, rather than an asset supplier, contributing to the DAO treasury.

Assets that are available in the Aave Protocol can be used to back GHO. Initially, the Ethereum V3 pool will be the first facilitator to launch because of V3’s extensive risk-mitigation features, including e-mode, isolation mode, and supply caps.

The Aave DAO manages the supply of GHO, the interest rates and determine risk parameters.

With 100% of repaid interest being redirected to the DAO, rather than the asset suppliers, these repaid interest contribute to the DAO treasury.

Unlike many stablecoins, the oracle price for GHO is fixed. Decentralised stablecoins such as GHO are transparent and cannot be changed. Interest rates are defined by Aave DAO and repaid interest is redirected to the DAO instead of the asset suppliers. Discounts are available to borrowers staking AAVE in the Safety Module.

Users who have staked AAVE tokens in the Safety Module (stkAave) are eligible for a discount on GHO.

For each stkAave there is a discount on the borrowing rate for 100 GHO. The discount model is interchangeable and can be redesigned and replaced if needed by The Aave DAO.

Currently only stkAAVE holders are eligible for the borrow rate discount.

GHO has a Flashmint Facilitator, that functions similarly to flashloan functionality of all other Aave Protocol reserves, and can be used to borrow GHO tokens for use cases requiring liquidity that is borrowed and returned within a single block.

Aave Governance has the ability to approve GHO facilitators that allow liquidity to be bridged to other networks. A facilitator utilizing Chainlink CCIP has been approved which enables tokens to be bridged to the Arbitrum network.

Bridging can be performed on the

[Aave Labs Interface](https://app.aave.com/)

by using the “Bridge GHO” feature in the top navigation bar.

Developers
----------

Aave is a collection of smart contracts deployed to Ethereum and other blockchain networks. Aave functionality can be integrated into an application by interacting with the protocol smart contracts.

Aave data can be queried directly through view functions. The

[Aave Docs](https://aave.com/docs/developers/aave-v3)

contain details on available functions, and all protocol addresses can be viewed and integrated through the

[Aave Address Book](https://github.com/bgd-labs/aave-address-book/).

Historical data for protocol data such as parameters, rates, balances can be queried through contract events or indexed data sources. A breakdown of all core protocol events can be found

[here](https://github.com/aave/protocol-subgraphs/blob/main/templates/v3.subgraph.template.yaml). The

[Aave Protocol subgraphs](https://github.com/aave/protocol-subgraphs)

are an example of an indexed data source that maps Aave contract events to a GraphQL endpoint.

Other Features
--------------

Flash loans are a feature designed for developers, due to the technical knowledge required to execute one. Flash Loans allow you to borrow any available amount of assets without putting up any collateral, as long as the liquidity is returned to the protocol within one block transaction. To do a Flash Loan, you will need to build a contract that requests a Flash Loan. The contract will then need to execute the instructed steps and pay back the Flash Loan + fee (0.07% in Aave V2, 0.05% in Aave V3) all within the same transaction.

If you would like to develop a Flash Loan smart contract, check out the developer

[documentation](https://aave.com/docs/developers/flash-loans).

Aave community developers are also available in the official

[Discord](https://aave.com/discord)

channel to help with the process.

Yes, there are tools allowing users to utilize Flash Loans to access liquidity in the background for advanced features such as repay with collateral, collateral switch, and more.

Availability of flashloan features on Aave markets can be found

[here](https://aave.com/docs/developers/smart-contracts/switch-adapters#switch-adapters).

Isolation mode allows Aave Governance to list new assets as isolated assets, which have a specific debt ceiling. Only certain assets can be borrowed in isolation mode—specifically, approved stablecoins. In order for an asset to become approved for borrowing, assets are voted on through Aave Governance process.

The debt ceiling for an isolated asset is represented as the maximum amount in USD that can be borrowed against the user’s collateral with two decimals of precision.

Entering isolation mode is specific to certain isolated assets that are voted on and approved by Aave Governance. You cannot utilize non-isolated assets as collateral to enter isolation mode.

The E-mode (efficiency mode) feature maximizes capital efficiency when collateral and borrowed assets have correlated prices. For example, DAI, USDC, USDT are all stablecoins pegged to USD. These stablecoins are all within the same E-mode category. Accordingly, a user supplying DAI in E-mode will have higher collateralisation power when borrowing assets like USDC or USDT.

Only assets of the same category (for example stablecoins) can be borrowed in E-mode. E-mode does not restrict the usage of other assets as collateral. Assets outside of the E-mode category can still be supplied as collateral with normal LTV and liquidation parameters.

Supply and borrow positions can be migrated between Aave V2 and V3 by using the migration tool, or by manually withdrawing from an Aave V2 markets and supplying to an Aave V3 market.

The migration tool can be accessed through the

[Aave Labs Interface](https://app.aave.com/)

by navigating to an Aave V2 market, pressing the “Migrate to V3” button next to the market selector, and following the prompts to migrate selected supply and borrow positions.

In order to switch your assets you just need to go to the Switch section and follow these steps:

1.  Select the asset you want to switch and the amount in the left side (From).
2.  Select the asset you want to switch to in the right side (From).
3.  Make sure to check the exchange rate and check the slippage. You can edit it based on your preferences. Depending on the slippage, the expected rate might differ and the transaction might even fail if you set it too low. After this click on Continue.
4.  In the next step you will need to send the approval and submit the transaction. The approval transaction will only be required the 1st time you do this step, unless you revoke the approval.
5.  Make sure to have enough ETH for the transaction cost. After sending both transactions your switch will be complete.

In order to repay with your assets you just need to go to the Dashboard and follow these steps:

1.  Click on repay on the debt you want to repay.
2.  Choose repay "With your current collateral".
3.  Select the asset you want to repay and amount in the left side (Borrowed Asset).
4.  Select the asset you want to use to repay to in the right side (Select Collateral).
5.  Make sure to check the exchange rate and check the slippage. You can edit it based on your preferences. Depending on the slippage, the expected might differ and the transaction might even fail if you set it too low. After this click on Continue.
6.  In the next step you need to send the approval and submit the transaction. The approval transaction will only be required the 1st time you do this step, unless you revoke the approval.
7.  Make sure to have enough ETH for the transaction cost. After sending both transactions your repayment will be done.

Brand
-----

The Aave logo should be used in its original form without any modifications. It should be clearly visible and not distorted. The logo should also maintain a minimum clear space around it to ensure it stands out.

You can use the Aave logo on your website or promotional materials, provided your usage doesn't misrepresent the Aave brand. Visual assets should not be altered, combined with other logos, or used in a way that misrepresents the Aave brand.

Yes, we encourage you to stay true to the Aave brand while creating your own assets. Start with one of the derivative logos.

* * *

Have more questions?
--------------------

Check out the Help & Support center for more information and detailed guides on Aave.

[Help & Support](https://aave.com/help)</content>
</page>

<page>
  <title>GHO</title>
  <url>https://aave.com/gho</url>
  <content>A new kind of stable.
---------------------

Mint GHO by supplying collateral in Aave. You earn interest on the collateral while the value of GHO is pegged to the US Dollar.

* * *

GHO at a glance.
----------------

%

Collateralization1 Yr Avg

* * *

### Decentralised & Transparent

GHO is fully governed by the Aave DAO who votes on its development and future roadmap.

[Learn More](https://governance.aave.com/)

### Multi-collateral Backing

GHO is backed by multiple diverse assets supplied in the Aave Protocol.

[Learn More](https://app.aave.com/reserve-overview/?underlyingAsset=0x40d16fc0246ad3160ccc09b8d0d3a2cd28ae6c2f&marketName=proto_mainnet_v3)

### Build with GHO

With as few as 10 lines of code, you can easily integrate GHO payments into your app.

[Learn More](https://aave.com/docs/developers/gho)

FAQs
----

GHO is a decentralised, overcollateralised stablecoin that is fully backed, transparent, and native to the Aave Protocol.

The

[GHO Documentation](https://aave.com/docs/developers/gho)

is a comprehensive resource that explains the core mechanics of how the GHO stablecoin operates.

Borrowers and suppliers can mint GHO using assets they have supplied into V3 as collateral on Ethereum markets, while continuing to earn interests on their underlying assets.

The GHO pool functions differently from existing assets, but borrowing it will work similarly as other available assets on the different markets in the protocol.

1.  Supply Collateral
2.  Borrow GHO
3.  Repay GHO and Accrued Interest (real-time)
4.  Repaid interest will be redirected to the DAO, rather than an asset supplier, contributing to the DAO treasury.

Assets that are available in the Aave Protocol can be used to back GHO. Initially, the Ethereum V3 pool will be the first facilitator to launch because of V3’s extensive risk-mitigation features, including e-mode, isolation mode, and supply caps.

The Aave DAO manages the supply of GHO, the interest rates and determine risk parameters.

With 100% of repaid interest being redirected to the DAO, rather than the asset suppliers, these repaid interest contribute to the DAO treasury.

Unlike many stablecoins, the oracle price for GHO is fixed. Decentralised stablecoins such as GHO are transparent and cannot be changed. Interest rates are defined by Aave DAO and repaid interest is redirected to the DAO instead of the asset suppliers. Discounts are available to borrowers staking AAVE in the Safety Module.

Users who have staked AAVE tokens in the Safety Module (stkAave) are eligible for a discount on GHO.

For each stkAave there is a discount on the borrowing rate for 100 GHO. The discount model is interchangeable and can be redesigned and replaced if needed by The Aave DAO.

Currently only stkAAVE holders are eligible for the borrow rate discount.

GHO has a Flashmint Facilitator, that functions similarly to flashloan functionality of all other Aave Protocol reserves, and can be used to borrow GHO tokens for use cases requiring liquidity that is borrowed and returned within a single block.

Aave Governance has the ability to approve GHO facilitators that allow liquidity to be bridged to other networks. A facilitator utilizing Chainlink CCIP has been approved which enables tokens to be bridged to the Arbitrum network.

Bridging can be performed on the

[Aave Labs Interface](https://app.aave.com/)

by using the “Bridge GHO” feature in the top navigation bar.</content>
</page>

<page>
  <title>Help & Support</title>
  <url>https://aave.com/help</url>
  <content>[](https://aave.com/)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>Security</title>
  <url>https://aave.com/security</url>
  <content>Safety Module
-------------

The Aave Protocol is secured with a safe backstop for protocol insolvency worth $246,613,412.

[Learn more](https://app.aave.com/staking/)

### DDOS Protection

Advanced cloud-based DDoS protection services are used to identify and neutralize threats before they reach interface infrastructure. Scalable solutions are used so that applications can remain accessible, even during periods of high request volume.

### Domain Protection

To safeguard the domain, DNSSEC is used to protect against DNS spoofing and validate that domain name requests are securely authenticated. Regular monitoring and updates to DNS configurations help prevent unauthorized domain transfers.

### Intrusion Detection

The front-end employs state-of-the-art intrusion detection systems (IDS) that monitor for suspicious activities and potential threats, assisting with rapid detection and response to protect user data.

### Modification Detection

Content Security Policy (CSP) and Subresource Integrity (SRI) checks are used to detect and prevent unauthorized modifications to front-end code, maintaining the integrity and security of the application.

### IPFS Naming Records

Each commit of the Aave Interface codebase is automatically deployed to IPFS. The app.aave.com IPNS pointer and domain text records, using the DNSLink standard, are continuously updated to reflect latest deployment hash.</content>
</page>

<page>
  <title>Concepts</title>
  <url>https://aave.com/docs/concepts</url>
  <content>[](https://aave.com/docs)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>Supply</title>
  <url>https://aave.com/docs/concepts/supply</url>
  <content>[](#supply)

SuppliersLiquidity Pools

Supplying tokens to the Aave Protocol allows users to earn interest on their digital assets and utilise supplied tokens as collateral. When tokens are supplied, they are transferred to the Aave liquidity pool, a system of smart contracts that facilitates overcollateralised borrowing of tokens. In Aave, supplied tokens automatically accrue interest based on the current market supply rate. As the balance of supplied tokens increases, interest is accrued dynamically, reflecting the current rate allocated to suppliers.

Interest rates for supplied tokens are determined by the borrow utilisation rate, which measures the proportion of assets currently borrowed against the total supplied in the pool, and by governance parameters that can be adjusted through community decisions. These parameters, including collateralisation requirements and interest rates for suppliers and borrowers, are influenced by onchain inputs such as token balances, oracle prices, and the borrow utilisation ratio. As liquidity is supplied, borrowed, repaid, or withdrawn from the pool, the interest rates are updated accordingly.</content>
</page>

<page>
  <title>Liquidity Protocol</title>
  <url>https://aave.com/docs/concepts/liquidity-protocol</url>
  <content>[](#liquidity-protocol)

A **liquidity protocol** is a decentralised system of smart contracts that facilitates the transfer of digital assets. As a leading liquidity protocol that operates on a supply and borrow model, Aave enables users to supply their assets to liquidity pools and, in return, allows other participants to borrow from those pools using their own collateral. The protocol operates across multiple blockchain networks, making it highly accessible to users across different ecosystems.

One of the key features of a decentralised liquidity protocol is its non-custodial nature, meaning users maintain control over their assets at all times. Interaction with the protocol happens through self-custodial wallets, allowing users to supply or borrow funds directly, without relying on intermediaries. All of this is managed through publicly accessible and permissionless smart contracts, which execute and verify transactions based on predefined conditions, such as collateral ratios and market parameters, providing a transparent and trustless experience.

Aave is governed by AAVE token holders. This decentralised governance model further enhances the protocol’s adaptability and accessibility. Governance token holders can propose, vote, and implement changes to the protocol, including adjusting interest rates and collateral requirements as well as other key parameters that impact both borrowers and suppliers. This decentralised management structure means that the protocol can evolve in response to the needs of its community without requiring centralised control.

As a decentralised finance (DeFi) platform, Aave includes a range of features, from its native GHO stablecoin to periphery contracts that simplify complex actions like asset swaps and repayments. The flexibility of a liquidity protocol like Aave highlights the potential of DeFi to offer more open, transparent, and equitable financial services to anyone with access to a blockchain network.</content>
</page>

<page>
  <title>Borrow</title>
  <url>https://aave.com/docs/concepts/borrow</url>
  <content>[](#borrow)

BorrowersLiquidity Pools

Borrowing tokens from the Aave Protocol allows users to access liquidity by using their supplied tokens as collateral, unlocking capital without selling their assets. However, borrowers face liquidation risk if the value of their collateral falls below the required threshold. Interest rates are determined dynamically, influenced by protocol factors and governance decisions, and can change over time based on community input. Interest accrues based on the utilisation rate, which reflects the percentage of supplied liquidity that is borrowed. Higher utilisation rates lead to higher interest rates, adjusting with demand. Each reserve has specific parameters designed to incentivize both borrowers and suppliers.

To maintain a healthy ratio and avoid liquidation risk, borrowers should actively monitor their collateralization level, keeping their health factor in check, to assure their borrow positions remain overcollateralised even as market conditions change or interest accrues.</content>
</page>

<page>
  <title>Repay</title>
  <url>https://aave.com/docs/concepts/repay</url>
  <content>[](#repay)

SuppliersLiquidity Pools

Repaying borrowed tokens in the Aave Protocol is an important step for managing borrow positions. Borrowers can repay using the same tokens they borrowed, or repay with aTokens (collateral tokens) of the same underlying token. In addition, there are [periphery contracts](https://github.com/aave/aave-v3-periphery) available that simplify the process by allowing repayment with other tokens, such as other collateral assets, without the need to manually convert them beforehand. This flexibility makes it easier for borrowers to manage and close their positions when needed.

Repayment increases the collateralisation ratio, ensuring adequate collateralization and preventing liquidation. By boosting the collateral relative to what is borrowed, repayment prevents assets from being liquidated and allows borrowers to safely withdraw part of their collateral.</content>
</page>

<page>
  <title>Withdraw</title>
  <url>https://aave.com/docs/concepts/withdraw</url>
  <content>[](#withdraw)

BorrowersLiquidity Pools

Aave Protocol allows suppliers to withdraw their supplied tokens, including accrued interest, as long as there is sufficient unborrowed liquidity in the reserve. The withdrawal amount is limited by the available underlying assets, and that the user’s ability to maintain a sufficient collateral ratio for their borrow position. Periphery contracts with features such as withdraw and switch, allow users to redeem their supplied liquidity in a different token, providing more options for efficient asset management.

When withdrawing with an active borrow position, it’s crucial to maintain a healthy collateralisation ratio to avoid liquidation. Reducing collateral can lower the health factor, increasing the risk of liquidation. To remain safe, after the withdrawal, the account must stay above the liquidation threshold parameters. Therefore, withdrawals require careful management and consideration of the overall borrow positions to avoid liquidation.</content>
</page>

<page>
  <title>Liquidations</title>
  <url>https://aave.com/docs/concepts/liquidations</url>
  <content>[](#liquidations)

The **health factor** is a critical metric within the Aave Protocol that measures the safety of a borrow position. It is calculated as:

Health Factor = (Total Collateral Value \* Weighted Average Liquidation Threshold) / Total Borrow Value

The health factor measures a borrow position’s stability. A health factor below 1 risks liquidation. The liquidation threshold, set by Aave Governance for each asset, determines the maximum percentage of value that can be borrowed against the asset. For example, if a user supplies $10,000 in ETH with an 80% liquidation threshold and borrows $6,000 in GHO, the health factor would be 1.333.

A health factor above 1 represents a position that is above the liquidation threshold. Regular monitoring is essential, as the health factor fluctuates based on both the value of collateral and borrowed assets. To improve the health factor, users can either supply more collateral or repay part of the borrow position. The health factor is directly tied to collateral value. If the value rises, the health factor improves; if it falls, the health factor declines, increasing the risk of liquidation.

However, there is no universally "safe" health factor. The health factor depends on the volatility and correlation of the assets. Lower health factors may be acceptable, for example, with correlated assets, such as stablecoins or assets closely tied to ETH.

Liquidation happens when a borrower's health factor drops below 1, meaning their collateral is insufficient to cover the borrowed amount. This can occur when the value of collateral decreases or the borrowing amount is increased. When a liquidation occurs, up to 50% of the borrower's debt is repaid by a liquidator. A liquidation fee is also levied against the borrower's collateral. Liquidations are permissionless, meaning any participant within the network can initiate the liquidation of an eligible borrow position.

Liquidations are highly competitive, requiring a deep understanding of the protocol and technical proficiency. Liquidators closely monitor borrow positions, react swiftly to market changes, and prioritise liquidation transactions to be the first to execute the liquidation.

Tools for Managing Health Factor
--------------------------------

[](#tools-for-managing-health-factor)

*   Simulate health factor changes: [DeFi Simulator](https://defisim.xyz/)
    
*   Auto-repay borrow position: [DeFi Saver](https://defisaver.com/)
    

For more information on participating as a liquidator, see the [developer guide](https://aave.com/docs/developers/liquidations).</content>
</page>

<page>
  <title>Risks</title>
  <url>https://aave.com/docs/concepts/risks</url>
  <content>[](#risks)

The Aave Protocol offers decentralised access to liquidity but is not without risks. Robust risk management measures, including smart contract audits and governance frameworks, are in place to help mitigate risks. Below is an overview of key risks and mitigation efforts.

Smart Contract Risk
-------------------

[](#smart-contract-risk)

Smart contracts can contain software bugs or other vulnerabilities within the protocol code and the underlying reserve tokens. To mitigate these risks, Aave’s code is publicly available for audit and has undergone multiple external third-party professional audits. Any proposed changes to the protocol code are thoroughly reviewed and approved prior to implementation by the Aave community. Additionally, the protocol runs a continuous bug bounty program to incentivize external developers to identify and report any issues they may find so they can be fixed.

Oracle Risk
-----------

[](#oracle-risk)

Aave relies on third-party oracles for price feeds and external data, such as redemption ratios for liquid staking tokens. This reliance introduces potential risks such as incorrect valuations if an oracle fails or is compromised. To reduce this risk, Aave uses decentralised oracles like Chainlink, which provide tamper-resistant data feeds, greater reliability, and security measures.

Collateral Risk
---------------

[](#collateral-risk)

The Aave DAO also engages risk service providers who track collateral performance and market stability. The value and liquidity of assets used as collateral can fluctuate, leading to the risk of under collateralisation or bad debt. Aave mitigates these risks by setting key risk parameters such as loan-to-value (LTV) ratios and liquidation thresholds. These parameters are continuously monitored by risk service providers and can be adjusted by Aave governance to respond to market conditions.

Network / Bridge Risk
---------------------

[](#network-bridge-risk)

Aave operates across multiple blockchain networks and bridges, each with potential risks such as congestion, censorship, or security vulnerabilities. To address these types of risks, Aave Governance has a robust network onboarding framework that thoroughly vets new networks and bridges before they are integrated into the protocol. Community oversight during the governance process is an important step to validate adoption of secure and reliable systems, minimising risk.

For additional information on Aave Protocol risk management, see [Security & Audits](https://aave.com/security).</content>
</page>

<page>
  <title>Liquidity Pool</title>
  <url>https://aave.com/docs/primitives/liquidity-pool</url>
  <content>[](#liquidity-pool)

SupplyBorrow%%%%%%%%%%%%%%%%

A **liquidity pool** is an Aave market instance that enables users to participate as suppliers or borrowers. Governance-approved parameters, such as reserve configurations and collateralization thresholds, define each pool. Suppliers provide liquidity into the pool that borrowers can access through overcollateralised positions. In return, suppliers earn interest, while borrowers can obtain liquidity against their collateral, all facilitated through decentralised smart contracts.

Aave liquidity pools operate on a blockchain network governed by decisions that define the chain and reserve parameters. Parameter decisions must balance liquidity demands for various actions with risk management. The use of smart contracts validate parameters, executing the actions of borrowing, repaying, and liquidation processes seamlessly without intermediaries. This decentralised approach enhances the transparency, efficiency, and security of financial interactions within the pool.</content>
</page>

<page>
  <title>Reserve</title>
  <url>https://aave.com/docs/primitives/reserve</url>
  <content>[](#reserve)

WETHBorrowing powerLiquidation thresholdInterest rate strategyCapsE-mode

A **reserve** is an instance of a token within an Aave [liquidity pool](https://aave.com/docs/primitives/liquidity-pool). Each reserve is governed by a set of parameters that manage risk and optimise liquidity. These parameters can vary across different markets, even for the same underlying token, allowing Aave to adapt to various network and pool conditions.

Key Reserve Parameters
----------------------

[](#key-reserve-parameters)

1.  **Loan-to-Value (LTV)**: The maximum amount that can be borrowed relative to the collateral’s value. For example, a 75% LTV allows borrowing 75% of the collateral’s value. An asset with an LTV of 0% cannot be enabled as collateral.
    
2.  **Liquidation Threshold**: Defines the point at which a position becomes at risk of liquidation. If the threshold is exceeded, the position could be liquidated to repay the borrower's debt.
    
3.  **Borrowing Enabled**: Determines whether liquidity of a reserve can be borrowed.
    
4.  **Caps**: Supply and Borrow caps limit the total amount of a token that can be supplied and borrowed from a reserve. These caps are crucial for maintaining liquidity and preventing overexposure during volatile market conditions​.
    
5.  **Interest Rate Model**: Interest rates in Aave adjust dynamically based on the utilisation of the liquidity pool. As more liquidity is borrowed, interest rates rise to reflect the reduced availability of assets, creating conditions that enough liquidity remains for withdrawals and liquidations. The rates are controlled by parameters that set the base rate and slopes for utilisation​.
    

Dynamic Parameters and Governance
---------------------------------

[](#dynamic-parameters-and-governance)

The parameters for each reserve are not fixed; they vary between markets and can change over time as Aave Governance monitors market conditions and adjusts settings accordingly. For example, the same underlying token, such as ETH, might have different LTVs or interest rates in Ethereum versus Polygon markets. These adjustments are made to optimise liquidity and risk management for each market. Governance proposals allow the community to vote on changes, such as raising borrow caps or adjusting LTVs, enabling reserves to remain aligned with current market dynamics.</content>
</page>

<page>
  <title>Flash Loans</title>
  <url>https://aave.com/docs/concepts/flash-loans</url>
  <content>[](#flash-loans)

Liquidity PoolFlash LoanReceiver

Flash Loans are special transactions that allow users to borrow an asset for a single block, provided they repay the borrowed amount and a fee within that same block time. Sometimes these actions are also referred to as “One Block Borrows.” Flash Loans do not require any collateral upfront. There is no direct real-world analogy to Flash Loans, so it requires some basic understanding of how state is managed within blocks in blockchains.

There are tools allowing users to utilise Flash Loans to access liquidity in the background for advanced features such as repay with collateral, collateral switch, and more.

Example interfaces that integrate Flash Loans are [DeFi Saver](https://defisaver.com/), [Instadapp](https://instadapp.io/), and [Furucombo](https://furucombo.app/).

Flash Loans let users borrow from a pool’s reserves (if borrowing is enabled) for one transaction, provided they repay the amount taken plus a fee (0.07% in Aave V2, 0.05% in Aave V3) or open a borrow position within the same transaction.

Due to the technical knowledge required to execute a Flash Loan, the feature is designed for developers. To do a Flash Loan, users will need to build a contract that requests a Flash Loan. For more information on integrating flash loans, see the [developers' guide](https://aave.com/docs/developers/flash-loans).</content>
</page>

<page>
  <title>Incentives</title>
  <url>https://aave.com/docs/primitives/incentives</url>
  <content>[](#incentives)

User AccountsLiquidity PoolGovernance

Incentives within the Aave Protocol encourage active participation from suppliers and borrowers, enhancing liquidity and the overall efficiency of the protocol. It should be noted that there is no one source of various incentive initiatives, but they can originate from multiple sources, including the Aave DAO treasury and external entities interested in promoting liquidity for specific [reserves](https://aave.com/docs/primitives/reserve).

The Aave DAO, governed by AAVE token holders through proposals and voting, can allocate funds from the DAO treasury to incentivise certain activities within the protocol. Incentive programs funded by the DAO are proposed, discussed, and approved through the [Aave Governance](https://aave.com/docs/primitives/governance) process, ensuring community involvement and transparency.

Liquidity Pool Incentives
-------------------------

[](#liquidity-pool-incentives)

Incentives can also be applied to the supply or borrow side of Aave liquidity pools, promoting activity of the incentivised [reserve](https://aave.com/docs/primitives/reserve). By offering rewards to suppliers and borrowers of certain assets on Aave, the visibility and adoption of tokens can be boosted. Such external incentives require governance approval.

Approved incentives are distributed continuously over time proportional to the amount of liquidity a user supplies or borrows. Users can claim these rewards via the protocol’s incentive controller, which manages the allocation and distribution of incentives. This system adds value for those actively participating in the protocol while aligning user interests with the health and stability of the Aave ecosystem.

Safety Module
-------------

[](#safety-module)

AAVE holders can stake their tokens in the [Safety Module](https://aave.com/docs/primitives/safety-module), a reserve designed to secure the protocol against unexpected shortfalls. In return for staking their AAVE tokens and taking on the associated risk, participants earn rewards, typically in the form of additional AAVE tokens or other incentives approved by governance. These rewards not only compensate stakers but also enhance the protocol's security by ensuring sufficient reserves are available to cover potential deficits.

Merit Program
-------------

[](#merit-program)

Merit is an Aave-alignment user reward system, designed as a merkle-tree-based periodic airdrop to incentivise Aave-aligned behaviours and enhance the competitiveness of the Aave protocol. More information and interface to access merit distribution can be found [here](https://apps.aavechan.com/merit).</content>
</page>

<page>
  <title>Oracle</title>
  <url>https://aave.com/docs/primitives/oracle</url>
  <content>[](#oracle)

MarketsPriceSequencer uptimePrice Redemption Ratio

Each [reserve](https://aave.com/docs/primitives/reserve) within the Aave Protocol is associated with an oracle contract. These oracle contracts are responsible for reporting the market price of assets in the protocol, which is essential for determining collateralisation requirements.

The oracle for each reserve is selected through Aave Governance, establishing a decentralised model where the community decides which data sources are used. Once chosen, the oracle contract submits price feed updates based on its operational logic (time-based, deviation-based, etc.).

Types of Oracles in Use
-----------------------

[](#types-of-oracles-in-use)

Currently, there are two primary types of oracle contracts utilised on production Aave markets:

1.  **Chainlink Price Feeds**: Chainlink oracles provide highly reliable, decentralised price data for various assets. These price feeds pull data from multiple sources and aggregate them, minimising the risk of manipulation or outages.
    
2.  **Correlated Assets Price Oracle (CAPO)**: CAPO is designed for assets that have a strong correlation with another asset's price. For example, wrapped tokens can use this oracle to mirror the price of their underlying assets. CAPO leverages specialised logic to adjust and submit prices that follow the movements of these correlated assets. See more details about its implementation on [GitHub](https://github.com/bgd-labs/aave-capo).</content>
</page>

<page>
  <title>Governance</title>
  <url>https://aave.com/docs/primitives/governance</url>
  <content>[](#governance)

The Aave DAO is a decentralised collective of AAVE token holders and contributors who work together to shape the future of the protocol through a structured governance process. This community-driven model enables participants to propose, discuss, and vote on critical changes, guiding the evolution of the protocol and aligning with the collective goals of its members.

Processes
---------

[](#processes)

Aave's governance process is structured so that the protocol remains decentralised, secure, and adaptable. The lifecycle of a proposal is carefully designed to allow community members to present ideas, vote on them, and execute approved changes through a transparent and structured process.

### Proposal Lifecycle

[](#processes-proposal-lifecycle)

1.  **Governance Forum** The proposal process begins with an idea introduced to the [Aave Governance Forum](https://governance.aave.com/). This is where initial discussions take place and feedback is gathered. The community helps refine the proposal before moving to the next stage.
    
2.  **Temp Check (Snapshot Voting)** After discussion, the proposal proceeds to a TEMP CHECK via the [Aave Snapshot Space](https://snapshot.org/#/aave.eth). This informal vote gauges community sentiment. TEMP CHECK votes are non-binding but help determine if there is sufficient interest in moving forward. Proposals in this stage do not require detailed technical specifics.
    
3.  **ARFC (Aave Request for Final Comments)** If the TEMP CHECK passes, the proposal moves to the ARFC stage, where it undergoes more formal scrutiny. Service providers and community members contribute detailed feedback on how the proposal would impact the protocol, preparing it for the AIP stage. ARFC voting also occurs on the [Aave Snapshot Space](https://snapshot.org/#/aave.eth).
    
4.  **AIP (Aave Improvement Proposal)** The AIP stage is where the proposal becomes a formal, onchain submission. It includes two parts: metadata (stored on IPFS) and the contract payload. These are submitted through Aave's governance contracts, primarily on the Ethereum Mainnet.
    
5.  **Voting** Once submitted, the AIP enters a PENDING status before becoming ACTIVE for voting. Voting is conducted onchain through Aave governance contracts. A proposal succeeds if it meets quorum and vote differential requirements. If these thresholds aren’t met, the proposal fails.
    
6.  **Execution** A successful proposal moves to the execution phase, where it is enacted via Aave's governance infrastructure. Depending on the type of proposal, a timelock delay (either one day or 7 days) is imposed before the changes are implemented. Cross-chain proposals are executed using Aave's Delivery Infrastructure (a.DI).
    

### Voting Overview

[](#processes-voting-overview)

IntroductionTemp CheckAave Request for Final Comments (ARFC)Aave Improvement Proposal (AIP)VotingExecutionGovernance ForumSnapshotOnchain

#### Off-chain Voting (Snapshot)

[](#processes-voting-overview-off-chain-voting-snapshot)

Off-chain votes are used to measure community sentiment during the early stages of proposal development (Temp Checks and ARFCs). These non-binding votes take place on Snapshot and last for three days, allowing token holders to participate without transaction fees.

#### Onchain Voting (Governance Interfaces)

[](#processes-voting-overview-onchain-voting-governance-interfaces)

Once a proposal reaches the AIP stage, onchain voting is required. Token holders, delegates, or delegators vote on proposals using their AAVE, stkAAVE, or aAAVE tokens. The process is secured through various governance interfaces, including [Aave Labs](https://app.aave.com/), [BGD Labs](https://vote.onaave.com/), and [Boardroom](https://boardroom.io/aave).

Since voting can occur on multiple networks, this can create limitations for smart contract wallets that only exist on one network. To accommodate this, governance interfaces can be used to setup **voting representatives**, which allows a separate voting address to be designated for each network.

### Proposal Frameworks

[](#processes-proposal-frameworks)

Aave has predefined frameworks for common types of proposals, simplifying the governance process:

*   **Caps Update Framework**: Direct-to-AIP process for adjusting caps or freezing reserves.
    
*   **Asset Onboarding Framework**: Standardised lifecycle for onboarding new assets to the protocol.
    
*   **New Chain Deployment Framework**: Guidelines for deploying Aave on new blockchains.
    
*   **Emission Manager Framework**: Simplified process for adding emission admins to reserves.
    

These frameworks streamline governance and allow the community to focus on more complex issues while maintaining the protocol's security and adaptability.

Delegates are entrusted with voting power by other community members or through self-delegation. They actively participate in governance by voting on proposals on behalf of those who have delegated their voting rights. Some delegates are compensated through the Orbit program for their contributions.

Delegators are community members who hold AAVE, stkAAVE, or aAAVE tokens but choose to delegate their voting power to another individual or entity. This allows them to have their interests represented in governance without directly participating in every vote.

Contributors dedicate time and resources to the Aave DAO by engaging in working groups, completing bounties, building on the protocol, or working through grants. These efforts help maintain and improve the Aave ecosystem.

Service providers offer essential services to the protocol, such as risk management, financial oversight, security, and development. Examples of service providers include:

*   Chaos Labs (Risk)
    
*   Llamarisk (Risk)
    
*   Karpatkey (Finance)
    
*   Certora (Security)
    
*   Tokenlogic (Finance)
    
*   BGD Labs (Development)
    
*   ACI (Growth and Business Development)
    
*   Aave Labs (Development)
    

The Aave Community Guardians are a group of community-elected signers authorized to execute limited emergency protections.

The Aave Guardians have responsibilities divided between two multi-signature wallets, with roles and signers listed below.

The Protocol Emergency Guardian is the holder of the [EMERGENCY\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#roles-emergency-admin) role for Aave protocol markets and failsafe emergency actor for cross-chain messaging in Emergency Mode.

The Protocol Emergency Guardian is a 5 of 9 multi-signature wallet consisting of the following community-elected signers:

*   Chaos Labs (risk service provider)
    
*   Llamarisk (risk service provider)
    
*   Karpatkey (finance service provider)
    
*   Certora (security service provider)
    
*   Tokenlogic (finance service provider)
    
*   BGD Labs (development service provider)
    
*   ACI (growth and business development service provider)
    
*   Ezr3al (Aave DAO delegate)
    
*   Stable Labs (Aave DAO delegate)
    

The Governance Emergency Guardian is tasked to protect the Aave Protocol against potential governance takeovers by having the ability to “veto” an onchain payload if it is deemed malicious.

The Governance Emergency Guardian is a 5 of 9 multi-signature wallet consisting of the following community-elected signers:

*   Seb (Zapper)
    
*   Mounir (Paraswap)
    
*   Gavi Galloway (Standard Crypto)
    
*   Nenad (Defi Saver)
    
*   Fernando (Balancer)
    
*   Roger (Chainlink community)
    
*   Mariano Conti (DeFi OG)
    
*   Marin (Lido)
    
*   Certora (security service provider)
    

Stewards have delegated responsibility over specific protocol parameters, allowing the DAO to quickly respond to market changes. Stewards manage areas such as the GHO stablecoin and liquidity parameters. This system streamlines governance by reducing the need for frequent votes on minor adjustments, promoting efficiency. The source code for GHO Steward contracts can be found on [GitHub](https://github.com/aave/gho-core/tree/main/src/contracts/misc).

| Parameter | Description |  |
| --- | --- | --- |
| Facilitator Bucket Capacity | Up to 100% increase |  |

| Parameter | Description |  |
| --- | --- | --- |
| GHO Borrow Cap | Up to 100% increase or decrease |  |
| GHO Borrow Rate | Up to 5% change to optimalUsageRatio, baseVariableBorrowRate, variableRateSlope1, and variableRateSlope2 with maximum of 25% |  |
| GHO Supply Cap | Up to 100% increase |  |

| Parameter | Description |  |
| --- | --- | --- |
| Bridge Limit | Up to 100% increase or decrease |  |
| Rate Limit | Up to 100% increase or decrease |  |

| Parameter | Description |  |
| --- | --- | --- |
| GSM Exposure Cap | Up to 100% increase |  |
| GSM Buy/Sell Fees | Up to 0.5% increase or decrease |  |

| Description | Value |  |
| --- | --- | --- |
| Frequency of change | 5 days |  |
| Maximum supply cap increase | 50% |  |
| Maximum borrow cap increase | 50% |  |</content>
</page>

<page>
  <title>Safety Module</title>
  <url>https://aave.com/docs/primitives/safety-module</url>
  <content>[](#safety-module)

The [Umbrella](https://governance.aave.com/t/bgd-aave-safety-module-umbrella/18366) governance proposal outlines potential changes to the Safety Module, including automated slashing, replacing stkAAVE and stkABPT with aToken staking, and new incentives design, subject to community approval.

User AccountsSafety ModuleLiquidity PoolGovernance

Staking in the Aave Safety Module allows AAVE, GHO, and ABPT holders on the Ethereum network to contribute to the protocol's security while earning Safety Incentives. By staking, participants add an additional layer of protection, with the acknowledgement that their assets may be slashed in the event of a shortfall to cover any protocol deficits. Underlying tokens that can be supplied to safety module are listed below:

*   [AAVE](https://etherscan.io/address/0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9)
    
*   [ABPT](https://etherscan.io/address/0x3de27efa2f1aa663ae5d458857e731c129069f29) ([Underlying Balancer Token Pool](https://app.balancer.fi/#/ethereum/pool/0x3de27efa2f1aa663ae5d458857e731c129069f29000200000000000000000588))
    
*   [GHO](https://etherscan.io/address/0x40d16fc0246ad3160ccc09b8d0d3a2cd28ae6c2f)
    

Safety Incentives
-----------------

[](#safety-incentives)

Safety Incentives are rewards distributed to participants who stake their assets in the Aave Safety Module. These incentives serve as compensation for the risk taken by stakers, whose assets may be slashed to cover protocol deficits in the event of a shortfall. Safety Incentives are primarily distributed in the form of AAVE tokens, and the amount allocated to stakers is determined by Aave Governance through votes on emission parameters.

The emission parameters, which dictate the rate of Safety Incentives, are voted on by the Aave DAO. These parameters are allocated from the Ecosystem Reserve (AAVE Tokens) and/or the Protocol Treasury. Governance votes allow AAVE token holders to influence how much of the reserve or treasury is allocated to these incentives and how they are distributed over time. This decentralised decision-making process aligns incentives with the overall health and security of the Aave ecosystem.

Safety Incentives accumulate over time and can be claimed at any point while tokens are staked or after un-staking from the safety module.

Slashing Risks
--------------

[](#slashing-risks)

When staking in the Aave Safety Module, it’s important to be aware of the potential slashing risks. Slashing refers to the reduction of staked assets in the event of a shortfall event within the Aave Protocol. This mechanism is in place to protect the protocol by using a portion of staked assets to cover any deficits that may arise. While staking offers rewards through Safety Incentives, there is a risk that a portion of the staked assets could be slashed to contribute to the stability of the Aave ecosystem.

The extent of slashing varies depending on the type of token staked:

*   **stkAAVE and stkABPT**: Maximum slashing risk is up to 30% of the staked assets.
    
*   **stkGHO**: Maximum slashing risk is up to 99% of the staked assets.
    

These risks are an essential consideration for anyone looking to participate in the Aave Safety Module, as they reflect the potential loss of assets in exchange for helping to secure the protocol. The process of identifying and executing a slashing event is subject to an onchain Aave Governance proposal.</content>
</page>

<page>
  <title>AAVE Token</title>
  <url>https://aave.com/docs/primitives/aave</url>
  <content>[](#aave)

The AAVE token is the native governance token of the Aave Protocol. It empowers holders to participate in decision-making through protocol governance. AAVE is an ERC-20 token deployed on the Ethereum blockchain and is widely accessible across various centralised and decentralised exchanges.

Governance
----------

[](#governance)

AAVE token holders have the ability to influence the future of the Aave Protocol through governance. Both AAVE and safety module staked AAVE (stkAAVE) holders can vote on proposals or delegate their voting power to others. By participating in governance votes, holders contribute to decisions on protocol deployments, parameter adjustments, features, and more.

Liquidity Pools
---------------

[](#liquidity-pools)

AAVE tokens can be supplied to liquidity pools within the Aave Protocol, or external pools such as decentralised exchanges, allowing users to earn yield.

Holders can stake their tokens in the Aave safety module, enhancing the system's security by providing a backstop in case of insolvency and earning rewards in return. Staking AAVE can also grant reduced GHO borrowing rates, adding further incentives for participation. Additionally, AAVE tokens can be supplied to the Aave markets as collateral, allowing users to borrow other assets and increase their capital efficiency.

Cross-Chain
-----------

[](#cross-chain)

Furthermore, AAVE has cross-chain implementation on several networks using canonical network messaging bridges. This enables users to access AAVE across different blockchain networks, with the acknowledgment that the ability to bridge tokens to and from Ethereum depends on the availability of the network bridge.</content>
</page>

<page>
  <title>Aave V3</title>
  <url>https://aave.com/docs/developers/aave-v3</url>
  <content>[](#aave-v3)

SuppliersBorrowersWalletsDappsVariable ratesInterest bearing tokensFlash loansReserve liquidity pools

Features
--------

[](#features)

The Aave Protocol is a decentralised non-custodial liquidity protocol where users can participate as suppliers, borrowers, or liquidators. Suppliers provide liquidity to a market and can earn interest on the crypto assets provided, while borrowers are able to borrow in an overcollateralized fashion. Borrowers can also engage in one-block borrow transactions (”flash loans”), which do not require overcollateralization.

V3 of the Aave Protocol augments the core concepts of the Aave Protocol (aTokens, instant liquidity, credit delegation, etc.) with new features in the following areas.

### Capital Efficiency

[](#features-capital-efficiency)

V3 allows users to optimise their assets supplied to the Aave Protocol in terms of yield generation and borrowing power.

### Efficiency Mode (E-Mode)

[](#features-efficiency-mode-e-mode)

The High Efficiency Mode, or eMode, allows borrowers to extract the highest borrowing power out of their collateral when supplied and borrowed assets are correlated in price, particularly when both are derivatives of the same underlying asset (e.g., stablecoins pegged to USD).

This can enable a wave of new use cases such as high leverage forex trading, highly efficient yield farming (for example, deposit ETH staking derivatives to borrow ETH), and diversified risk management.

### Isolation Mode

[](#features-isolation-mode)

New assets can be listed as isolated in Aave Protocol V3. Borrowers supplying an isolated asset as collateral cannot supply other assets as collateral (though they can still supply to capture yield). Borrowers using an isolated collateral can only borrow stablecoins that have been configured by Aave governance to be borrowable in isolation mode, up to a specified debt ceiling.

NormalUser suppliesNon-isolated tokenCan Borrow:Any AssetCan Supply:Any AssetIsolation ModeUser suppliesisolated tokenCan borrow:TetherUSDTDaiDAIUSD CoinUSDCCan Supply:Any Asset

### Siloed Borrowing

[](#features-siloed-borrowing)

Siloed Borrowing allows certain assets to be treated as isolated within the protocol. Borrowers using these assets as collateral can only borrow stablecoins configured for siloed assets, with strict borrowing limits defined by the Aave governance. This structure reduces the systemic risk for assets that are highly volatile or less liquid by limiting their borrowing capacities and containing the exposure to siloed assets.

### Portals

[](#features-portals)

This feature allows the flow of liquidity between Aave V3 markets across different networks. Protocol V3 allows governance-approved bridges to burn aTokens on the source network while instantly minting them on the destination network. The underlying assets can then be supplied to Aave on the destination network in a deferred manner, by passing them to the pool after they have been moved through a bridge.

Aave V3 provides a new system role - BRIDGE - granting permission to leverage the Portal feature. Only addresses with the BRIDGE\_ROLE can move the supplied liquidity in Aave V3.

Aave Governance holds the ability to grant BRIDGE\_ROLE to any cross-chain protocol.

This can help bridging protocols like Connext, Hop Protocol, Anyswap, xPollinate, and novel solutions specifically built to leverage Portal, tap into Aave Protocol liquidity to facilitate seamless cross-chain interactions.

In order to support Portal, the following three additional features are required by the protocol:

*   Mint Unbacked Tokens: Allows addresses with BRIDGE role permission to mint unbacked aTokens to the onBehalfOf address.
    
*   Back Unbacked Tokens: Allows contracts with BRIDGE role permission to back the currently unbacked aTokens with the amount of underlying asset and pay a fee.
    
*   Whitelist Bridges: Allows the Bridge Role Admin to add/remove addresses for BRIDGE\_ROLE.
    

Integrations
------------

[](#integrations)

### Live Data

[](#integrations-live-data)

For reliable live data integrations, the recommended approach is to query directly from protocol [view contracts](https://aave.com/docs/developers/smart-contracts/view-contracts) such as the UiPoolDataProvider. This enables you to access all reserve information and user positions efficiently.

To simplify the process of querying Aave Protocol data through a blockchain RPC, you can use the Aave Utilities SDK, which is an extension of ethers v5. It streamlines data fetching and formatting, making it easier to interact with the protocol.

You can learn how to fetch data by following the instructions in the [Fetch Data](https://github.com/aave/aave-utilities#data-methods-setup) section of the SDK documentation. After fetching the data, you might need to format it for your application; the [Format Data](https://github.com/aave/aave-utilities#formatreserves) guide provides detailed instructions on how to format reserves and other relevant data structures. For a practical implementation example, you can refer to this [code sample](https://github.com/WeAreNewt/config.fyi/blob/master/pages/api/aave.ts), which demonstrates how to use the Aave Utilities SDK in a demo NextJS application.

### Historical Data

[](#integrations-historical-data)

If you're interested in historical data for parameters, rates, and balances, you can query contract events directly or use indexed data sources. A comprehensive breakdown of all core protocol events can be found in the documentation.

The Aave Protocol subgraphs are an example of an indexed data source that maps contract events to a GraphQL endpoint, allowing for efficient querying of historical data. For example, you can explore [queries of an address's transaction history](https://github.com/aave/protocol-subgraphs?tab=readme-ov-file#user-transaction-history) using these subgraphs.

### Smart Contracts

[](#integrations-smart-contracts)

For detailed information on interacting with the protocol's smart contracts, please refer to the [Pool Methods](https://aave.com/docs/developers/smart-contracts/pool) documentation. Additionally, the [Testing & Debugging](https://aave.com/docs/developers/testing-and-debugging) guides offer valuable insights into developing and troubleshooting smart contract integrations.</content>
</page>

<page>
  <title>Smart Contracts</title>
  <url>https://aave.com/docs/developers/smart-contracts</url>
  <content>[](#smart-contracts)

Liquidity PoolsSafety ModuleTokensGovernance

The source code of the Aave V3 Protocol contracts is available on [GitHub](https://github.com/aave-dao/aave-v3-origin). Contract addresses can be imported as Solidity or JavaScript package with the [Aave Address Book](https://github.com/bgd-labs/aave-address-book).

The core contracts fall into the following categories in the GitHub repository:

*   Pool
    
*   Configuration
    
*   Logic
    
*   Tokenization
    
*   Helpers
    
*   Misc
    

Pool
----

[](#pool)

### Pool

[](#pool-pool)

The [Pool](https://aave.com/docs/developers/smart-contracts/pool) is the main entry point into the Aave Protocol. Most user interactions with the Aave Protocol occur via the Pool contract. Pool is owned by the PoolAddressesProvider of the specific market. All admin functions are callable by the PoolConfigurator contract, which is defined in PoolAddressesProvider.

### L2Pool

[](#pool-l2pool)

The [L2Pool](https://aave.com/docs/developers/smart-contracts/l2-pool) is a modification of the Pool contract for L2 rollups, with gas-optimized user methods that takes byte encoded input arguments. It is a calldata optimized extension of the Pool contract allowing users to pass compact calldata representations to reduce transaction costs on rollups.

### PoolConfigurator

[](#pool-poolconfigurator)

The [PoolConfigurator](https://aave.com/docs/developers/smart-contracts/pool-configurator) provides configuration methods for the Pool contract. The write methods of this contract can only be called by addresses with corresponding permissioned system roles that are managed by ACLManager.

Configuration
-------------

[](#configuration)

### ACLManager

[](#configuration-aclmanager)

The [ACLManager](https://aave.com/docs/developers/smart-contracts/acl-manager) contract is the main registry of system roles and permissions.

### PoolAddressesProvider

[](#configuration-pooladdressesprovider)

The [PoolAddressesProvider](https://aave.com/docs/developers/smart-contracts/pool-addresses-provider) is a registry of various components of the protocol, including the ACLManager and Pool contracts, and has the ability to update pointers or update the implementation of proxy contracts.

Logic
-----

[](#logic)

[Libraries](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/libraries/logic/) that implement the base logic for various actions and functions.

Tokenization
------------

[](#tokenization)

### AToken

[](#tokenization-atoken)

[ATokens](https://aave.com/docs/developers/smart-contracts/tokenization) are yield-generating tokens that are minted and burnt upon supply and withdraw of assets to Aave Pool.

### VariableDebtToken

[](#tokenization-variabledebttoken)

[VariableDebtTokens](https://aave.com/docs/developers/smart-contracts/tokenization) are non-transferable interest accruing tokens representing variable borrow rate positions.

Helpers
-------

[](#helpers)

### L2Encoder

[](#helpers-l2encoder)

The [L2Encoder](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/L2Encoder.sol) is a helper contract to encode calldata that is passed to the L2Pool. It is used to optimize calldata size in L2Pool for transaction cost reduction. It is only intended to help generate calldata for users/frontends.

### AaveProtocolDataProvider

[](#helpers-aaveprotocoldataprovider)

The [AaveProtocolDataProvider](https://aave.com/docs/developers/smart-contracts/view-contracts) is a peripheral contract to collect and pre-process information from the Pool.

Misc
----

[](#misc)

### AaveOracle

[](#misc-aaveoracle)

The [AaveOracle](https://aave.com/docs/developers/smart-contracts/oracles) is the registry of reserve oracle to get asset prices and manage price sources.

### DefaultReserveInterestRateStrategy

[](#misc-defaultreserveinterestratestrategy)

The [DefaultReserveInterestRateStrategy](https://aave.com/docs/developers/smart-contracts/interest-rate-strategy) implements the calculation of the interest rates depending on the reserve state. This contract holds the information needed to calculate and update the yield relating to specific liquidity pools.

### PriceOracleSentinel

[](#misc-priceoraclesentinel)

The [PriceOracleSentinel](https://aave.com/docs/developers/smart-contracts/oracles) validates if operations are allowed depending on the PriceOracle health. Once the PriceOracle gets up after an outage or downtime, users can make their positions healthy during a grace period.</content>
</page>

<page>
  <title>GHO Token</title>
  <url>https://aave.com/docs/primitives/gho</url>
  <content>[](#gho)

GHO (pronounced "go") is a decentralised, over-collateralised stablecoin that is fully backed, transparent, and native to the Aave Protocol. Designed to maintain a value pegged to the U.S. dollar, GHO is minted by users on demand, subject to mint cap limitations set by Aave's governance. Its stability is maintained through market efficiencies and over-collateralisation mechanisms inherent in the Aave Protocol.

Facilitators
------------

[](#facilitators)

Facilitators are contract addresses approved by Aave Governance with the ability to mint and burn GHO tokens. Each facilitator operates under a specific bucket cap, controlling the maximum amount of GHO they can generate. Facilitators play a crucial role in maintaining GHO's stability and integrating it across various platforms and use cases.

### Aave Ethereum V3 Market

[](#facilitators-aave-ethereum-v3-market)

The Aave V3 Ethereum Market serves as a primary facilitator for GHO. Users can mint GHO by supplying approved collateral assets into the Aave Protocol and borrowing GHO against them. This process follows standard over-collateralisation practices, ensuring the protocol's security and the stablecoin's reliability. GHO has a discount mechanism that enables holder of stkAAVE (see [safety module](https://aave.com/docs/primitives/safety-module)) to borrow GHO at a discounted rate from the Aave V3 Ethereum Market.

### Flash Mint

[](#facilitators-flash-mint)

The FlashMinter facilitator allows users to access uncollateralised GHO through flash loans, provided the borrowed amount is returned within the same transaction. This feature enables arbitrage opportunities and enhances liquidity without permanently increasing the overall supply of GHO.

### GHO Stability Module (GSM)

[](#facilitators-gho-stability-module-gsm)

The GHO Stability Module acts as a facilitator to help maintain GHO's peg to the U.S. dollar. It allows users to swap GHO for other stable assets, providing a mechanism to absorb market imbalances and keep GHO's price stable.

### Cross-Chain

[](#facilitators-cross-chain)

Cross-chain liquidity pools enable GHO to be used across different blockchain networks. Utilising CCIP, GHO can be bridged to other chains, allowing users to access liquidity pools on platforms outside of Ethereum. This cross-chain functionality expands GHO's utility and integrates it with a broader range of DeFi applications.

GHO Liquidity Committee
-----------------------

[](#gho-liquidity-committee)

The GHO Liquidity Committee (GLC) was created in October 2023 to focus solely on the liquidity of the GHO stablecoin. The committee was formed through a [governance proposal](https://governance-v2.aave.com/governance/proposal/343/) and consisted of a small team. After a successful initial 3-month period, it was [integrated](https://governance-v2.aave.com/governance/proposal/407/) into the Aave Liquidity Committee (ALC).

The ALC's main responsibilities regarding GHO include:

*   Providing analytics and modelling of the liquidity strategy
    
*   Liaising with teams that support the protocols hosting GHO liquidity
    
*   Leading and coordinating the committee's weekly activities
    
*   Providing critical feedback and helping refine the strategy
    
*   Verifying and signing transactions
    

The ALC's performance measures and liquidity targets for GHO can be found on the [GHO Analytics platform](https://aave.tokenlogic.xyz/liquidity-committee) provided by TokenLogic.

More information regarding the role of the GHO Liquidity Committee can be found in [Aave's Governance forum](https://governance.aave.com/t/temp-check-treasury-management-create-and-fund-gho-liquidity-committee/14800).

GHO Stewards
------------

[](#gho-stewards)

GHO Stewards is an additional entity created in April 2024 to more flexibly manage GHO market parameters, enabling GHO to be scaled per prevailing market conditions. The source code for GHO Steward contracts can be found on [GitHub](https://github.com/aave/gho-core/tree/main/src/contracts/misc).

The GHO Stewards determine if and how much to adjust the following, subject to pre-defined and Governance accepted thresholds:

*   GHO Borrow Cap
    
*   GHO Borrow Rate
    
*   GSM Exposure Cap
    
*   GSM Bucket Capacity
    
*   GSM Price Strategy
    
*   GSM Fee Strategy
    
*   GSM Price Range (Freeze, Unfreeze)
    

With many liquidity pools being created and rewards distributed across them, it is important that the DAO can swiftly increase the GHO Borrow Cap to mitigate GHO trading above $1. The GHO Stewards can swiftly increase the GHO Borrow Cap to mitigate GHO trading above the peg. The GHO Stewards can increase the GHO Borrow Cap to a threshold of 50M units to a total borrow cap of 100M.

The Borrow Rate must be adjusted gradually to enable the ecosystem to expand safely. If the trailing 30-day average price of GHO stays outside a $0.995 - $1.005 price range, the GHO Stewards are able to adjust the Borrow Rate no more than 500bps per 2-day period, up to a maximum 25% APR.

GHO Stewards consist of members from Growth (ACI), Risk (ChaosLabs), and Finance (TokenLogic + karpatkey) Service Providers and utilise a 3 of 4 multi-sig.

Liquidity Pools
---------------

[](#liquidity-pools)

Liquidity pools are vital for providing market liquidity for GHO, enabling users to trade, borrow, and supply GHO across various platforms.

The Aave community, through the Liquidity Committee, may offer incentives to liquidity providers who supply GHO to specific pools. These incentives can include reward tokens or reduced fees, encouraging users to add liquidity and improve market depth. Incentivized liquidity pools help keep GHO readily available and maintain its peg to the U.S. dollar.</content>
</page>

<page>
  <title>Pool</title>
  <url>https://aave.com/docs/developers/smart-contracts/pool</url>
  <content>[](#pool)

This contract is the main user-facing contract. Most user interactions with the Aave Protocol occur via the Pool contract. It exposes the liquidity management methods that can be invoked using either _**Solidity**_ or _**Web3**_ libraries.

Pool.sol allows users to:

*   Supply
    
*   Withdraw
    
*   Borrow
    
*   Repay
    
*   Enable/disable supplied assets as collateral
    
*   Liquidate positions
    
*   Execute Flash Loans
    

Pool is covered by a proxy contract and is owned by the [PoolAddressesProvider](https://aave.com/docs/developers/smart-contracts/pool-addresses-provider) of the specific market. All admin functions are callable by the [PoolConfigurator](https://aave.com/docs/developers/smart-contracts/pool-configurator) contract defined in the [PoolAddressesProvider](https://aave.com/docs/developers/smart-contracts/pool-addresses-provider).

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/pool/Pool.sol).

Write Methods
-------------

[](#write-methods)

### initialize

[](#write-methods-initialize)

    function initialize(IPoolAddressesProvider provider) external virtual

Initializes the Pool.

Function is invoked by the proxy contract when the Pool contract is added to the [PoolAddressesProvider](https://aave.com/docs/developers/smart-contracts/pool-addresses-provider) of the market.

Caches the address of the [PoolAddressesProvider](https://aave.com/docs/developers/smart-contracts/pool-addresses-provider) in order to reduce gas consumption on subsequent operations.

#### Input Parameters:

[](#write-methods-initialize-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| provider | address | The address of the PoolAddressesProvider |  |

### supply

[](#write-methods-supply)

    function supply(    address asset,    uint256 amount,    address onBehalfOf,    uint16 referralCode) public virtual override

Supplies a certain amount of an asset into the protocol, minting the same amount of corresponding aTokens and transferring them to the onBehalfOf address. For example, if a user supplies 100 USDC and onBehalfOf address is the same as msg.sender, they will get 100 aUSDC in return.

The referralCode is emitted in Supply event and can be for third-party referral integrations. To activate the referral feature and obtain a unique referral code, integrators need to submit a proposal to Aave Governance.

When supplying, the Pool contract must have allowance() to spend funds on behalf of msg.sender for at least the amount for the asset being supplied. This can be done via the standard ERC20 approve() method on the underlying token contract.

Referral supply is currently inactive, you can pass 0 as referralCode. This program may be activated in the future through an Aave governance proposal.

#### Input Parameters:

[](#write-methods-supply-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset being supplied to the pool |  |
| amount | uint256 | The amount of asset to be supplied |  |
| onBehalfOf | address | The address that will receive the corresponding aTokens. This is the only address that will be able to withdraw the asset from the pool. This will be the same as msg.sender if the user wants to receive aTokens into their own wallet, or use a different address if the beneficiary of aTokens is a different wallet |  |
| referralCode | uint16 | Referral supply is currently inactive, you can pass 0. This code is used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-men |  |

### supplyWithPermit

[](#write-methods-supplywithpermit)

    function supplyWithPermit(    address asset,    uint256 amount,    address onBehalfOf,    uint16 referralCode,    uint256 deadline,    uint8 permitV,    bytes32 permitR,    bytes32 permitS) public virtual override

Supply with transfer approval of the asset to be supplied via permit function. This method removes the need for separate approval tx before supplying asset to the pool. See: [https://eips.ethereum.org/EIPS/eip-2612](https://eips.ethereum.org/EIPS/eip-2612).

Permit signature must be signed by msg.sender with spender as Pool address.

Referral program is currently inactive, you can pass 0 as referralCode. This program may be activated in the future through an Aave governance proposal.

#### Input Parameters:

[](#write-methods-supplywithpermit-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of underlying asset being supplied. The same asset as used in permit v, s, and r |  |
| amount | uint256 | The amount of asset to be supplied and signed for approval. The same amount as used in permit v, s, and r |  |
| onBehalfOf | address | The address that will receive the aTokens. This will be the same as msg.sender if the user wants to receive aTokens into their own wallet, or use a different address if the beneficiary of aTokens is a different wallet |  |
| referralCode | uint16 | Referral supply is currently inactive, you can pass 0. This code is used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-men |  |
| deadline | uint256 | The unix timestamp up until which the permit signature is valid |  |
| permitV | uint8 | The v parameter of the ERC712 permit signature |  |
| permitR | bytes32 | The r parameter of the ERC712 permit signature |  |
| permitS | bytes32 | The s parameter of the ERC712 permit signature |  |

### withdraw

[](#write-methods-withdraw)

    function withdraw(address asset, uint256 amount, address to) public virtual override returns (uint256)

Withdraws an amount of underlying asset from the reserve, burning the equivalent aTokens owned. For example, if a user has 100 aUSDC and calls withdraw(), they will receive 100 USDC, burning the 100 aUSDC.

If user has any existing debt backed by the underlying token, then the maximum amount available to withdraw is the amount that will not leave user's health factor < 1 after withdrawal.

When withdrawing to another address, msg.sender should have aToken that will be burned by Pool.

Reserves with a Loan To Value parameter of 0% must be disabled as collateral (using Pool.setUserUseReserveAsCollateral or by fully withdrawing the supplied balance) before other assets can be withdrawn.

#### Input Parameters:

[](#write-methods-withdraw-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset to withdraw, not the aToken |  |
| amount | uint256 | The underlying amount to be withdrawn (the amount supplied), expressed in wei units. Use type(uint).max to withdraw the entire aToken balance |  |
| to | address | The address that will receive the underlying asset. This will be the same as msg.sender if the user wants to receive the tokens into their own wallet, or use a different address if the beneficiary is a different wallet |  |

#### Return Values:

[](#write-methods-withdraw-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The final amount withdrawn |  |

### borrow

[](#write-methods-borrow)

    function borrow(    address asset,    uint256 amount,    uint256 interestRateMode,    uint16 referralCode,    address onBehalfOf) public virtual override

Allows users to borrow a specific amount of the reserve underlying asset, provided the borrower has already supplied enough collateral, or they were given enough allowance by a credit delegator on the corresponding debt token (VariableDebtToken). For example, if a user borrows 100 USDC passing their own address as onBehalfOf, they will receive 100 USDC into their wallet and 100 variable debt tokens.

NOTE: If onBehalfOf is not the same as msg.sender, then onBehalfOf must have supplied enough collateral via supply() and have delegated credit to msg.sender via approveDelegation().

Referral program is currently inactive, you can pass 0 as referralCode. This program may be activated in the future through an Aave governance proposal.

#### Input Parameters:

[](#write-methods-borrow-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset to borrow |  |
| amount | uint256 | The amount to be borrowed, expressed in wei units |  |
| interestRateMode | uint256 | Should always be passed a value of 2 (variable rate mode) |  |
| referralCode | uint16 | Referral supply is currently inactive, you can pass 0. This code is used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-men |  |
| onBehalfOf | address | This should be the address of the borrower calling the function if they want to borrow against their own collateral, or the address of the credit delegator if the caller has been given credit delegation allowance |  |

### repay

[](#write-methods-repay)

    function repay(    address asset,    uint256 amount,    uint256 interestRateMode,    address onBehalfOf) public virtual override returns (uint256)

Repays a borrowed amount on a specific reserve, burning the equivalent debt tokens owned. For example, if a user repays 100 USDC, the 100 variable debt tokens owned by the onBehalfOf address will be burned.

When repaying, the Pool contract must have allowance to spend funds on behalf of msg.sender for at least the amount for the asset you are repaying with. This can be done via the standard ERC20 approve() method on the underlying token contract.

You cannot call repay() multiple times in the same block.

#### Input Parameters:

[](#write-methods-repay-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the borrowed underlying asset previously borrowed |  |
| amount | uint256 | The amount to repay, expressed in wei units. Use type(uint256).max in order to repay the whole debt, ONLY when the repayment is not executed on behalf of a 3rd party. In case of repayments on behalf of another user, it's recommended to send an amount slightly higher than the current borrowed amount |  |
| interestRateMode | uint256 | Only available option is 2 (variableRateMode) |  |
| onBehalfOf | address | The address of the user who will get their debt reduced/removed. This should be the address of the user calling the function if they want to reduce/remove their own debt, or the address of any other borrower whose debt should be removed |  |

### repayWithPermit

[](#write-methods-repaywithpermit)

    function repayWithPermit(    address asset,    uint256 amount,    uint256 interestRateMode,    address onBehalfOf,    uint256 deadline,    uint8 permitV,    bytes32 permitR,    bytes32 permitS) public virtual override returns (uint256)

Repay with transfer approval of the borrowed asset to be repaid, done via permit function. This method removes the need for separate approval tx before repaying asset to the pool. See: [https://eips.ethereum.org/EIPS/eip-2612](https://eips.ethereum.org/EIPS/eip-2612).

Permit signature must be signed by msg.sender with spender value as Pool address.

#### Input Parameters:

[](#write-methods-repaywithpermit-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the borrowed underlying asset previously borrowed. The same asset as used in permit v, r, and s |  |
| amount | uint256 | The amount to repay, expressed in wei units. Use type(uint256).max in order to repay the whole debt to pay without leaving aToken dust. The same amount as used in permit v,r,s |  |
| interestRateMode | uint256 | Only available option is 2 (variableRateMode) |  |
| onBehalfOf | address | The address of the user who will get their debt reduced/removed. This should be the address of the user calling the function if they want to reduce/remove their own debt, or the address of any other borrower whose debt should be removed |  |
| deadline | uint256 | The unix timestamp up until which the permit signature is valid |  |
| permitV | uint8 | The v parameter of the ERC712 permit signature |  |
| permitR | bytes32 | The r parameter of the ERC712 permit signature |  |
| permitS | bytes32 | The s parameter of the ERC712 permit signature |  |

#### Return Values:

[](#write-methods-repaywithpermit-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The final amount repaid |  |

### repayWithATokens

[](#write-methods-repaywithatokens)

    function repayWithATokens(address asset, uint256 amount, uint256 interestRateMode) public virtual override returns (uint256)

Allows a user to repay a borrowed amount on a specific reserve using the reserve aTokens, burning the equivalent debt tokens. For example, a user repays 100 USDC using 100 aUSDC, burning 100 variable debt tokens. Passing uint256.maxas the amount will clean up any residual aToken dust balance, if the user aToken balance is not enough to cover the whole debt.

#### Input Parameters:

[](#write-methods-repaywithatokens-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the borrowed underlying asset previously borrowed |  |
| amount | uint256 | The amount to repay. Use type(uint256).max in order to repay the whole debt for asset to pay without leaving aToken dust |  |
| interestRateMode | uint256 | Only available option is 2 (variableRateMode) |  |

#### Return Values:

[](#write-methods-repaywithatokens-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The final amount repaid |  |

### setUserUseReserveAsCollateral

[](#write-methods-setuserusereserveascollateral)

    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) public virtual override

Allows suppliers to enable/disable a specific supplied asset as collateral. Sets the asset of msg.sender to be used as collateral or not.

An asset in [Isolation Mode](https://aave.com/docs/developers/aave-v3) can be enabled to use as collateral only if no other asset is already enabled to use as collateral.

An asset with LTV parameter of 0% cannot be enabled as collateral.

The user won’t be able to disable an asset as collateral if they have an outstanding debt position which could be left with the Health Factor < HEALTH\_FACTOR\_LIQUIDATION\_THRESHOLD on disabling the given asset as collateral.

#### Input Parameters:

[](#write-methods-setuserusereserveascollateral-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset supplied |  |
| useAsCollateral | bool | true if the user wants to use the supply as collateral, false otherwise |  |

### liquidationCall

[](#write-methods-liquidationcall)

    function liquidationCall(    address collateralAsset,    address debtAsset,    address user,    uint256 debtToCover,    bool receiveAToken) public virtual override

Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1.

When the health factor of a position is below 1, the caller (liquidator) repays the debtToCover amount of debt of the user getting liquidated. This is part or all of the outstanding borrowed amount on behalf of the borrower. The caller then receives a proportional amount of the collateralAsset (discounted amount of collateral) plus a liquidation bonus to cover market risk.

Liquidators can decide if they want to receive an equivalent amount of collateral aTokens instead of the underlying asset. When the liquidation is completed successfully, the health factor of the position is increased, bringing the health factor above 1.

Liquidators can only close a certain amount of collateral defined by a close factor. Currently the **close factor is 0.5**. In other words, liquidators can only liquidate a maximum of 50% of the amount pending to be repaid in a position. The liquidation discount applies to this amount.

*   _In most scenarios_, profitable liquidators will choose to liquidate as much as they can (50% of the user position).
    
*   debtToCover parameter can be set to uint(-1) and the protocol will proceed with the highest possible liquidation allowed by the close factor.
    
*   To check a user's health factor, use \[getUserAccountData()\].
    

Liquidators must approve() the Pool contract to use debtToCover of the underlying ERC20 of the asset used for the liquidation.

#### Input Parameters:

[](#write-methods-liquidationcall-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| collateralAsset | address | The address of the underlying asset used as collateral, to receive as result of the liquidation |  |
| debtAsset | address | The address of the underlying borrowed asset to be repaid with the liquidation |  |
| user | address | The address of the borrower getting liquidated |  |
| debtToCover | uint256 | The debt amount of borrowed asset the liquidator will repay |  |
| receiveAToken | bool | true if the liquidator wants to receive the aTokens equivalent of the purchased collateral, false if they want to receive the underlying collateral asset directly |  |

### flashLoan

[](#write-methods-flashloan)

    function flashLoan(    address receiverAddress,    address[] calldata assets,    uint256[] calldata amounts,    uint256[] calldata interestRateModes,    address onBehalfOf,    bytes calldata params,    uint16 referralCode) public virtual override

Allows users to access liquidity of the pool for a given list of assets within one transaction, as long as the amount taken plus a fee is returned. The receiver must approve the Pool contract for at least the _amount borrowed + fee_, otherwise the transaction will revert.

The flash loan fee is waived for approved FLASH\_BORROWER.

There are security concerns for developers of flashloan receiver contracts that must be taken into consideration. For further details, visit [Flash Loan Developers Guide](https://aave.com/docs/developers/flash-loans).

Referral program is currently inactive, you can pass 0 as referralCode. This program may be activated in the future through an Aave governance proposal.

#### Input Parameters:

[](#write-methods-flashloan-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| receiverAddress | address | The address of the contract receiving the flash-borrowed funds, implementing the IFlashLoanReceiver interface |  |
| assets | address\[\] | The addresses of the assets being flash-borrowed |  |
| amounts | uint256\[\] | The amounts of the assets being flash-borrowed. This needs to contain the same number of entries as assets |  |
| interestRateModes | uint256\[\] | The types of the debt position to open if the flash loan is not returned: 0 -> Don't open any debt, the amount + fee must be paid in this case or just revert if the funds can't be transferred from the receiver. 2 -> Open variable rate borrow position for the value of the amount flash-borrowed to the onBehalfOf address |  |
| onBehalfOf | address | The address that will receive the debt if the associated interestRateModes is 1 or 2. onBehalfOf must already have approved sufficient borrow allowance of the associated asset to msg.sender |  |
| params | bytes | Variadic packed params to pass to the receiver as extra information |  |
| referralCode | uint16 | Referral supply is currently inactive, you can pass 0. This code is used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-men |  |

### flashLoanSimple

[](#write-methods-flashloansimple)

    function flashLoanSimple(    address receiverAddress,    address asset,    uint256 amount,    bytes calldata params,    uint16 referralCode) public virtual override

Allows users to access liquidity of the pool for a given asset within one transaction, as long as the amount taken plus a fee is returned. The receiver must approve the Pool contract for at least the _amount borrowed + fee_, otherwise the transaction will revert.

This function does not waive the fee for approved FLASH\_BORROWER, nor does it allow for opening a debt position instead of repaying.

There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.

Referral program is currently inactive, you can pass 0 as referralCode. This program may be activated in the future through an Aave governance proposal.

#### Input Parameters:

[](#write-methods-flashloansimple-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| receiverAddress | address | The address of the contract receiving the flash-borrowed funds, implementing the IFlashLoanReceiver interface |  |
| asset | address | The address of the asset being flash-borrowed |  |
| amount | uint256 | The amount of the asset being flash-borrowed |  |
| params | bytes | Variadic packed params to pass to the receiver as extra information |  |
| referralCode | uint16 | Referral supply is currently inactive, you can pass 0. This code is used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-men |  |

### mintToTreasury

[](#write-methods-minttotreasury)

    function mintToTreasury(address[] calldata assets) external virtual override

Mints the assets accrued through the reserve factor to the treasury in the form of aTokens for the given list of assets.

#### Input Parameters:

[](#write-methods-minttotreasury-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| assets | address\[\] | The list of reserves for which the minting needs to be executed |  |

### finalizeTransfer

[](#write-methods-finalizetransfer)

    function finalizeTransfer(    address asset,    address from,    address to,    uint256 amount,    uint256 balanceFromBefore,    uint256 balanceToBefore) external virtual override

Validates and finalizes an aToken transfer. It is only callable by the overlying aToken of the asset.

#### Input Parameters:

[](#write-methods-finalizetransfer-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the aToken |  |
| from | address | The user from which the aTokens are transferred |  |
| to | address | The user receiving the aTokens |  |
| amount | uint256 | The amount being transferred/withdrawn |  |
| balanceFromBefore | uint256 | The aToken balance of the from user before the transfer |  |
| balanceToBefore | uint256 | The aToken balance of the to user before the transfer |  |

### setUserEMode

[](#write-methods-setuseremode)

    function setUserEMode(uint8 categoryId) external virtual override

Allows a user to use the protocol in efficiency mode. The category id must be a valid id already defined by _Pool or Risk Admins_.

Will revert if user is borrowing non-compatible asset or if the change will drop the Health Factor < HEALTH\_FACTOR\_LIQUIDATION\_THRESHOLD.

#### Input Parameters:

[](#write-methods-setuseremode-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| categoryId | uint8 | The eMode category id (0 - 255) defined by Risk or Pool Admins. categoryId set to 0 is a non eMode category |  |

### mintUnbacked

[](#write-methods-mintunbacked)

    function mintUnbacked(    address asset,    uint256 amount,    address onBehalfOf,    uint16 referralCode) external virtual override onlyBridge

Allows contracts, with BRIDGE role permission, to mint an amount of unbacked aTokens to the onBehalfOf address. This method is part of the V3 [Portals](https://aave.com/docs/developers/aave-v3) feature.

Only available to the addresses with BRIDGE role. Bridge addresses can be whitelisted by Aave Governance.

Referral program is currently inactive, you can pass 0 as referralCode. This program may be activated in the future through an Aave governance proposal.

#### Input Parameters:

[](#write-methods-mintunbacked-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset to mint |  |
| amount | uint256 | The amount to mint |  |
| onBehalfOf | address | The address that will receive the aTokens |  |
| referralCode | uint16 | Referral supply is currently inactive, you can pass 0. This code is used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-men |  |

### backUnbacked

[](#write-methods-backunbacked)

    function backUnbacked(    address asset,    uint256 amount,    uint256 fee) external virtual override onlyBridge returns (uint256)

Allows contracts, with BRIDGE role permission, to back the current unbacked underlying aTokens with amount and pay fee. This method is part of the V3 [Portals](https://aave.com/docs/developers/aave-v3) feature.

Only available to the addresses with BRIDGE role. Bridge addresses can be whitelisted by the governance.

#### Input Parameters:

[](#write-methods-backunbacked-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset to back |  |
| amount | uint256 | The amount of asset supplied to back the unbacked tokens |  |
| fee | uint256 | The amount paid in fees |  |

#### Return Value:

[](#write-methods-backunbacked-return-value)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The final amount backed, representing the portion of assets that were successfully supplied to back the unbacked aTokens, including any fees that were taken into account. |  |

### initReserve

[](#write-methods-initreserve)

    function initReserve(    address asset,    address aTokenAddress,    address stableDebtAddress,    address variableDebtAddress,    address interestRateStrategyAddress) external virtual override onlyPoolConfigurator

Initializes a reserve, activating it, assigning an aToken and debt tokens and an interest rate strategy.

#### Input Parameters:

[](#write-methods-initreserve-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| aTokenAddress | address | The address of the aToken that will be assigned to the reserve |  |
| stableDebtAddress | address | The address of the StableDebtToken that will be assigned to the reserve (deprecated) |  |
| variableDebtAddress | address | The address of the VariableDebtToken that will be assigned to the reserve |  |
| interestRateStrategyAddress | address | The address of the interest rate strategy contract |  |

### dropReserve

[](#write-methods-dropreserve)

    function dropReserve(address asset) external virtual override onlyPoolConfigurator

Drop a reserve.

#### Input Parameters:

[](#write-methods-dropreserve-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

### setReserveInterestRateStrategyAddress

[](#write-methods-setreserveinterestratestrategyaddress)

    function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress) external virtual override onlyPoolConfigurator

Updates the address of the interest rate strategy contract.

#### Input Parameters:

[](#write-methods-setreserveinterestratestrategyaddress-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| rateStrategyAddress | address | The address of the interest rate strategy contract |  |

### setConfiguration

[](#write-methods-setconfiguration)

    function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration) external virtual override onlyPoolConfigurator

Sets the configuration bitmap of the reserve as a whole.

#### Input Parameters:

[](#write-methods-setconfiguration-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| configuration | DataTypes.ReserveConfigurationMap | The new configuration bitmap |  |

The [DataTypes.ReserveConfigurationMap](https://github.com/aave-dao/aave-v3-origin/blob/3aad8ca184159732e4b3d8c82cd56a8707a106a2/src/core/contracts/protocol/libraries/types/DataTypes.sol#L79) struct is composed of the following fields:

| bit | Description |  |
| --- | --- | --- |
| 0-15 | LTV |  |
| 16-31 | Liquidation threshold |  |
| 32-47 | Liquidation bonus |  |
| 48-55 | Decimals |  |
| 56 | Reserve is active |  |
| 57 | Reserve is frozen |  |
| 58 | Borrowing is enabled |  |
| 59 | Stable rate borrowing enabled (deprecated) |  |
| 60 | Asset is paused |  |
| 61 | Borrowing in isolation mode is enabled |  |
| 62 | Siloed borrowing is enabled |  |
| 63 | Flashloaning is enabled |  |
| 64-79 | Reserve factor |  |
| 80-115 | Borrow cap in whole tokens, borrowCap == 0 => no cap |  |
| 116-151 | Supply cap in whole tokens, supplyCap == 0 => no cap |  |
| 152-167 | Liquidation protocol fee |  |
| 168-175 | eMode category (deprecated) |  |
| 176-211 | Unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled |  |
| 212-251 | Debt ceiling for isolation mode with (ReserveConfiguration::DEBT\_CEILING\_DECIMALS) decimals |  |
| 252 | Virtual accounting is enabled |  |
| 253-255 | Unused |  |

### updateBridgeProtocolFee

[](#write-methods-updatebridgeprotocolfee)

    function updateBridgeProtocolFee(uint256 protocolFee) external virtual override onlyPoolConfigurator

Updates the protocol fee on the bridging.

#### Input Parameters:

[](#write-methods-updatebridgeprotocolfee-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| protocolFee | uint256 | The part of the premium sent to the protocol treasury |  |

### updateFlashloanPremiums

[](#write-methods-updateflashloanpremiums)

    function updateFlashloanPremiums(uint128 flashLoanPremiumTotal, uint128 flashLoanPremiumToProtocol) external virtual override onlyPoolConfigurator

Updates flash loan premiums. A flash loan premium consists of two parts:

*   A part is sent to aToken holders as extra, one time accumulated interest
    
*   A part is collected by the protocol treasury
    

The total premium is calculated on the total borrowed amount. The premium to protocol is calculated on the total premium, being a percentage of flashLoanPremiumTotal.

#### Input Parameters:

[](#write-methods-updateflashloanpremiums-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| flashLoanPremiumTotal | uint128 | The total premium, expressed in bps |  |
| flashLoanPremiumToProtocol | uint128 | The part of the premium sent to the protocol treasury, expressed in bps |  |

### configureEModeCategory

[](#write-methods-configureemodecategory)

    function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory category) external virtual override onlyPoolConfigurator

Configures a new category for the eMode. In eMode, the protocol allows very high borrowing power to borrow assets of the same category. The category 0 is reserved for volatile heterogeneous assets and it's always disabled.

Each eMode category has a custom ltv and liquidation threshold. Each eMode category may or may not have a custom oracle to override the individual assets price oracles.

#### Input Parameters:

[](#write-methods-configureemodecategory-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| id | uint8 | The total premium, expressed in bps |  |
| category | DataTypes.EModeCategory | The configuration of the category |  |

The [DataTypes.EModeCategory](https://github.com/aave-dao/aave-v3-origin/blob/3aad8ca184159732e4b3d8c82cd56a8707a106a2/src/core/contracts/protocol/libraries/types/DataTypes.sol#L114) struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| ltv | uint16 | The custom Loan to Value for the eMode category |  |
| liquidationThreshold | uint16 | The custom liquidation threshold for the eMode category |  |
| liquidationBonus | uint16 | The liquidation bonus for the eMode category |  |
| collateralBitmap | uint128 | Bitmap of collateral assets in the category |  |
| label | string | The custom label describing the eMode category |  |
| borrowableBitmap | uint128 | Bitmap of borrowable assets in the category |  |

### resetIsolationModeTotalDebt

[](#write-methods-resetisolationmodetotaldebt)

    function resetIsolationModeTotalDebt(address asset) external virtual override onlyPoolConfigurator

Resets the isolation mode total debt of the given asset to zero. It requires the given asset to have a zero debt ceiling.

#### Input Parameters:

[](#write-methods-resetisolationmodetotaldebt-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset to reset the isolationModeTotalDebt |  |

### rescueTokens

[](#write-methods-rescuetokens)

    function rescueTokens(address token, address to, uint256 amount) external virtual override onlyPoolAdmin

Rescue and transfer tokens locked in this contract.

Only available to [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#pooladmin) role. Pool admin is selected by the governance.

#### Input Parameters:

[](#write-methods-rescuetokens-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| token | address | The address of the token |  |
| to | address | The address of the recipient |  |
| amount | uint256 | The amount of token to transfer |  |

View Methods
------------

[](#view-methods)

### getUserAccountData

[](#view-methods-getuseraccountdata)

    function getUserAccountData(address user) external view virtual override returns (    uint256 totalCollateralBase,    uint256 totalDebtBase,    uint256 availableBorrowsBase,    uint256 currentLiquidationThreshold,    uint256 ltv,    uint256 healthFactor)

Returns the user account data across all the reserves.

#### Input Parameters:

[](#view-methods-getuseraccountdata-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| user | address | The address of the user |  |

#### Return Values:

[](#view-methods-getuseraccountdata-return-values)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| totalCollateralBase | uint256 | The total collateral of the user in the base currency used by the price feed |  |
| totalDebtBase | uint256 | The total debt of the user in the base currency used by the price feed |  |
| availableBorrowsBase | uint256 | The borrowing power left of the user in the base currency used by the price feed |  |
| currentLiquidationThreshold | uint256 | The liquidation threshold of the user |  |
| ltv | uint256 | The loan to value of the user |  |
| healthFactor | uint256 | The current health factor of the user |  |

### getConfiguration

[](#view-methods-getconfiguration)

    function getConfiguration(address asset) external view virtual override returns (DataTypes.ReserveConfigurationMap memory)

Returns the configuration of the reserve.

#### Input Parameters:

[](#view-methods-getconfiguration-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getconfiguration-return-values)

| Type | Description |  |
| --- | --- | --- |
| DataTypes.ReserveConfigurationMap | The configuration of the reserve |  |

The [DataTypes.ReserveConfigurationMap](https://github.com/aave-dao/aave-v3-origin/blob/3aad8ca184159732e4b3d8c82cd56a8707a106a2/src/core/contracts/protocol/libraries/types/DataTypes.sol#L79) struct is composed of the following fields:

| bit | Description |  |
| --- | --- | --- |
| 0-15 | LTV |  |
| 16-31 | Liquidation threshold |  |
| 32-47 | Liquidation bonus |  |
| 48-55 | Decimals |  |
| 56 | Reserve is active |  |
| 57 | Reserve is frozen |  |
| 58 | Borrowing is enabled |  |
| 59 | Stable rate borrowing enabled (deprecated) |  |
| 60 | Asset is paused |  |
| 61 | Borrowing in isolation mode is enabled |  |
| 62 | Siloed borrowing enabled |  |
| 63 | Flashloaning enabled |  |
| 64-79 | Reserve factor |  |
| 80-115 | Borrow cap in whole tokens, borrowCap == 0 => no cap |  |
| 116-151 | Supply cap in whole tokens, supplyCap == 0 => no cap |  |
| 152-167 | Liquidation protocol fee |  |
| 168-175 | eMode category (deprecated) |  |
| 176-211 | Unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled |  |
| 212-251 | Debt ceiling for isolation mode with (ReserveConfiguration::DEBT\_CEILING\_DECIMALS) decimals |  |
| 252 | Virtual accounting is enabled for the reserve |  |
| 253-255 | Unused |  |

### getUserConfiguration

[](#view-methods-getuserconfiguration)

    function getUserConfiguration(address user) external view virtual override returns (DataTypes.UserConfigurationMap memory)

Returns the configuration of the user across all the reserves.

#### Input Parameters:

[](#view-methods-getuserconfiguration-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| user | address | The user address |  |

#### Return Values:

[](#view-methods-getuserconfiguration-return-values)

| Type | Description |  |
| --- | --- | --- |
| DataTypes.UserConfigurationMap | The configuration of the user |  |

The [DataTypes.UserConfigurationMap](https://github.com/aave-dao/aave-v3-origin/blob/3aad8ca184159732e4b3d8c82cd56a8707a106a2/src/core/contracts/protocol/libraries/types/DataTypes.sol#L105) struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| data | uint256 | Bitmap of the users collaterals and borrows. It is divided into pairs of bits, one pair per asset. The first bit indicates if an asset is used as collateral by the user, the second whether an asset is borrowed by the user. The corresponding assets are in the same position as getReservesList(). For example, if the hex value returned is 0x40020, which represents a decimal value of 262176, then in binary it is 1000000000000100000. If we format the binary value into pairs, starting from the right, we get 1 00 00 00 00 00 00 10 00 00. If we start from the right and move left in the above binary pairs, the third pair is 10. Therefore the 1 indicates that third asset from the reserveList is used as collateral, and 0 indicates it has not been borrowed by this user |  |

### getReserveNormalizedIncome

[](#view-methods-getreservenormalizedincome)

    function getReserveNormalizedIncome(address asset) external view virtual override returns (uint256)

Returns the ongoing normalized income for the reserve.

A value of 1e27 means there is no income. As time passes, the yield is accrued. A value of 2\*1e27 means for each unit of asset, one unit of income has been accrued.

#### Input Parameters:

[](#view-methods-getreservenormalizedincome-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getreservenormalizedincome-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The reserve's normalized income |  |

### getReserveNormalizedVariableDebt

[](#view-methods-getreservenormalizedvariabledebt)

    function getReserveNormalizedVariableDebt(address asset) external view virtual override returns (uint256)

Returns the normalized variable debt per unit of asset.

A value of 1e27 means there is no debt. As time passes, the debt is accrued. A value of 2\*1e27 means that for each unit of debt, one unit worth of interest has been accumulated.

#### Input Parameters:

[](#view-methods-getreservenormalizedvariabledebt-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getreservenormalizedvariabledebt-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The reserve normalized variable debt |  |

### getReservesList

[](#view-methods-getreserveslist)

    function getReservesList() external view virtual override returns (address[] memory)

Returns the list of the underlying assets of all the initialized reserves. It does not include dropped reserves.

#### Return Values:

[](#view-methods-getreserveslist-return-values)

| Type | Description |  |
| --- | --- | --- |
| address\[\] | The addresses of the underlying assets of the initialized reserves |  |

### getReserveAddressById

[](#view-methods-getreserveaddressbyid)

    function getReserveAddressById(uint16 id) external view returns (address)

Returns the address of the underlying asset of a reserve by the reserve id as stored in the [DataTypes.ReserveData](https://github.com/aave-dao/aave-v3-origin/blob/3aad8ca184159732e4b3d8c82cd56a8707a106a2/src/core/contracts/protocol/libraries/types/DataTypes.sol#L42) struct.

#### Input Parameters:

[](#view-methods-getreserveaddressbyid-input-parameters)

#### Return Values:

[](#view-methods-getreserveaddressbyid-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the reserve associated with id |  |

### getEModeCategoryData

[](#view-methods-getemodecategorydata)

    function getEModeCategoryData(uint8 id) external view virtual override returns (DataTypes.EModeCategory memory)

Returns the data of an eMode category.

Each eMode category has a custom LTV and liquidation threshold. Each eMode category may or may not have a custom oracle to override the individual assets' price oracles.

#### Input Parameters:

[](#view-methods-getemodecategorydata-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| id | uint8 | The id of the category |  |

#### Return Values:

[](#view-methods-getemodecategorydata-return-values)

| Type | Description |  |
| --- | --- | --- |
| DataTypes.EModeCategory | The configuration data of the category |  |

The [DataTypes.EModeCategory](https://github.com/aave-dao/aave-v3-origin/blob/3aad8ca184159732e4b3d8c82cd56a8707a106a2/src/core/contracts/protocol/libraries/types/DataTypes.sol#L114) struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| ltv | uint16 | The custom Loan to Value for the eMode category |  |
| liquidationThreshold | uint16 | The custom liquidation threshold for the eMode category |  |
| liquidationBonus | uint16 | The liquidation bonus for the eMode category |  |
| collateralBitmap | uint128 | Bitmap of collateral assets in the category |  |
| label | string | The custom label describing the eMode category |  |
| borrowableBitmap | uint128 | Bitmap of borrowable assets in the category |  |

### getReserveData

[](#view-methods-getreservedata)

    function getReserveData(address asset) external view virtual override returns (DataTypes.ReserveData memory)

Returns the state and configuration of the reserve.

#### Input Parameters:

[](#view-methods-getreservedata-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getreservedata-return-values)

| Type | Description |  |
| --- | --- | --- |
| DataTypes.ReserveData | The state and configuration data of the reserve |  |

The [DataTypes.ReserveData](https://github.com/aave-dao/aave-v3-origin/blob/3aad8ca184159732e4b3d8c82cd56a8707a106a2/src/core/contracts/protocol/libraries/types/DataTypes.sol#L42) struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| configuration | ReserveConfigurationMap | Stores the [reserve configuration](https://github.com/aave-dao/aave-v3-origin/blob/3aad8ca184159732e4b3d8c82cd56a8707a106a2/src/core/contracts/protocol/libraries/types/DataTypes.sol#L42) |  |
| liquidityIndex | uint128 | The yield generated by the reserve during time interval since lastUpdatedTimestamp. Expressed in ray |  |
| currentLiquidityRate | uint128 | The current supply rate. Expressed in ray |  |
| variableBorrowIndex | uint128 | The yield accrued by reserve during time interval since lastUpdatedTimestamp. Expressed in ray |  |
| currentVariableBorrowRate | uint128 | The current variable borrow rate. Expressed in ray |  |
| \_\_deprecatedStableBorrowRate | uint128 | DEPRECATED on v3.2.0 |  |
| lastUpdateTimestamp | uint40 | The timestamp of when reserve data was last updated. Used for yield calculation |  |
| id | uint16 | The id of the reserve. It represents the reserve’s position in the list of active reserves |  |
| liquidationGracePeriodUntil | uint40 | The timestamp until liquidations are not allowed on the reserve. If set to the past, liquidations will be allowed |  |
| aTokenAddress | address | The address of associated aToken |  |
| \_\_deprecatedStableDebtTokenAddress | address | DEPRECATED on v3.2.0 |  |
| variableDebtTokenAddress | address | The address of associated variable debt token |  |
| interestRateStrategyAddress | address | The address of interest rate strategy |  |
| accruedToTreasury | uint128 | The current treasury balance (scaled) |  |
| unbacked | uint128 | The outstanding unbacked aTokens minted through the bridging feature |  |
| isolationModeTotalDebt | uint128 | The outstanding debt borrowed against this asset in isolation mode |  |
| virtualUnderlyingBalance | uint128 | The virtual balance of the underlying asset for yield calculation purposes |  |

### getUserEMode

[](#view-methods-getuseremode)

    function getUserEMode(address user) external view virtual override returns (uint256)

Returns eMode the user is using. 0 is a non eMode category.

#### Input Parameters:

[](#view-methods-getuseremode-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| user | address | The address of the user |  |

#### Return Values:

[](#view-methods-getuseremode-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The eMode id |  |

### FLASHLOAN\_PREMIUM\_TOTAL

[](#view-methods-flashloan-premium-total)

    function FLASHLOAN_PREMIUM_TOTAL() public view virtual override returns (uint128)

Returns the percent of total flashloan premium paid by the borrower.

A part of this premium is added to reserve's liquidity index i.e. paid to the liquidity provider and the other part is paid to the protocol i.e. accrued to the treasury.

#### Return Values:

[](#view-methods-flashloan-premium-total-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint128 | The total fee on flashloans |  |

### BRIDGE\_PROTOCOL\_FEE

[](#view-methods-bridge-protocol-fee)

    function BRIDGE_PROTOCOL_FEE() public view virtual override returns (uint256)

Returns the part of the bridge fees sent to protocol.

#### Return Values:

[](#view-methods-bridge-protocol-fee-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The percentage of available liquidity to borrow, expressed in bps |  |

### FLASHLOAN\_PREMIUM\_TO\_PROTOCOL

[](#view-methods-flashloan-premium-to-protocol)

    function FLASHLOAN_PREMIUM_TO_PROTOCOL() public view virtual override returns (uint128)

Returns the percent of flashloan premium that is accrued to the treasury.

#### Return Values:

[](#view-methods-flashloan-premium-to-protocol-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint128 | The percentage of available liquidity to borrow, expressed in bps |  |

### MAX\_NUMBER\_RESERVES

[](#view-methods-max-number-reserves)

    function MAX_NUMBER_RESERVES() public view virtual override returns (uint16)

Returns the maximum number of reserves supported to be listed in this Pool.

#### Return Values:

[](#view-methods-max-number-reserves-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint16 | The maximum number of reserves supported |  |

Pure Methods
------------

[](#pure-methods)

### getRevision

[](#pure-methods-getrevision)

    function getRevision() internal pure virtual override returns (uint256)

Returns the revision number of the contract. Needs to be defined in the inherited class as a constant.

Returns 0x1.

#### Return Values:

[](#pure-methods-getrevision-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The revision number |  |</content>
</page>

<page>
  <title>Wrapped Token Gateway</title>
  <url>https://aave.com/docs/developers/smart-contracts/wrapped-token-gateway</url>
  <content>[](#wrapped-token-gateway)

The Aave Protocol operates exclusively with ERC-20 [reserve](https://aave.com/docs/primitives/reserve) tokens. To accommodate network gas tokens, the WrappedTokenGateway (previously called WETHGateway) is a helper contract that enables gas tokens (ETH, POL, etc.) to be wrapped or unwrapped to perform Aave Pool methods:

*   Supply
    
*   Borrow
    
*   Repay
    
*   Withdraw
    

The smart contract source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/WrappedTokenGatewayV3.sol).

Write Methods
-------------

[](#write-methods)

### depositETH

[](#write-methods-depositeth)

    function depositETH(    address,    address onBehalfOf,    uint16 referralCode) external payable override

Wraps and supplies gas tokens to the Aave Protocol. A corresponding amount of the wrapped aTokens are minted to the onBehalfOf address.

The amount of network gas tokens to be supplied is specified in the msg.value field of the transaction.

#### Input Parameters:

[](#write-methods-depositeth-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| onBehalfOf | address | The address of the user who will receive the aTokens representing the supplied tokens |  |
| referralCode | uint16 | Inactive, can pass 0 as placeholder |  |

### withdrawETH

[](#write-methods-withdraweth)

    function withdrawETH(    address,    uint256 amount,    address to) external override

Withdraws amount of the supplied wrapped gas token, unwraps it and transfers to the to address. If the amount is uint(-1), the entire balance is withdrawn.

The WrappedTokenGateway contract must have an approved token allowance to spend aWETH on behalf of the user, example: IERC20(aWETHAddress).approve(wrappedTokenGatewayAddress, amount)

#### Input Parameters:

[](#write-methods-withdraweth-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| amount | uint256 | amount of aWETH to withdraw and receive native ETH |  |
| to | address | The address of the user who will receive native ETH |  |

### repayETH

[](#write-methods-repayeth)

    function repayETH(    address,    uint256 amount,    uint256 rateMode,    address onBehalfOf) external payable override

Repays a borrow position of onBehalfOf's address for the specified amount (or for the whole amount, if amount of uint256(-1) is passed).

The amount of network gas token to be repaid must also be specified in the msg.value field of the transaction.

#### Input Parameters:

[](#write-methods-repayeth-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| amount | uint256 | The amount to repay, or uint256(-1) if the user wants to repay everything |  |
| rateMode | uint256 | Should always be passed a value of 2 (variable rate mode) |  |
| onBehalfOf | address | The address for which msg.sender is repaying |  |

### borrowETH

[](#write-methods-borroweth)

    function borrowETH(    address,    uint256 amount,    uint256 interestRateMode,    uint16 referralCode) external override

Borrows amount of unwrapped network gas tokens to msg.sender.

The WrappedTokenGateway contract must have an approved [credit delegation](https://aave.com/docs/developers/credit-delegation) to borrow WETH (or corresponding wrapped gas token of the network) on behalf of the the caller, example: IVariableDebtToken(wethAddress).approveDelegation(wrappedTokenGatewayAddress, amount)

#### Input Parameters:

[](#write-methods-borroweth-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| amount | uint256 | The amount of ETH to borrow |  |
| interestRateMode | uint256 | Should always be passed a value of 2 (variable rate mode) |  |
| referralCode | uint16 | Integrators are assigned a referral code and can potentially receive rewards |  |

### withdrawETHWithPermit

[](#write-methods-withdrawethwithpermit)

    function withdrawETHWithPermit(    address,    uint256 amount,    address to,    uint256 deadline,    uint8 permitV,    bytes32 permitR,    bytes32 permitS) external override

Withdraws amount of the supplied wrapped gas token, unwraps it and transfers to the to address. If the amount is uint(-1), the entire balance is withdrawn.

#### Input Parameters:

[](#write-methods-withdrawethwithpermit-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| amount | uint256 | The amount of aWETH to withdraw and receive native ETH |  |
| to | address | The address of the user who will receive native ETH |  |
| deadline | uint256 | Timestamp of signature expiration |  |
| permitV | uint8 | V parameter of ERC712 permit sig |  |
| permitR | bytes32 | R parameter of ERC712 permit sig |  |
| permitS | bytes32 | S parameter of ERC712 permit sig |  |

View Methods
------------

[](#view-methods)

### getWETHAddress

[](#view-methods-getwethaddress)

    function getWETHAddress() external view returns (address)

Get WETH address used by WrappedTokenGatewayV3.

#### Return Values:

[](#view-methods-getwethaddress-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The WETH address used by WrappedTokenGatewayV3 |  |</content>
</page>

<page>
  <title>L2 Pool</title>
  <url>https://aave.com/docs/developers/smart-contracts/l2-pool</url>
  <content>L2Pool
------

[](#l2pool)

The main transaction cost on L2 comes from calldata. To minimize this cost, Aave V3 uses a different contract on L2 networks that allows calldata of Pool methods to be compressed.

L2Pool is the contract for the L2 optimized user facing methods of the protocol that takes byte encoded input arguments. It exposes the liquidity management methods that can be invoked using either Solidity or Web3 libraries. The L2Pool contract is a calldata optimized extension of the Pool contract allowing users to pass compact calldata representation to reduce transaction costs on L2 rollups.

Pool methods not exposed in L2Pool.sol (such as flashLoan, setUserEMode etc.) are the same on L2 as on other versions of protocol. Refer to [Pool](https://aave.com/docs/developers/smart-contracts/pool) docs for the rest of the methods.

Since there are a limited set of supported assets that are already given an individual id, we use the 16 bit asset id in the encoded arguments instead of 160 bit asset address.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/pool/L2Pool.sol).

Threre is an additional [L2Encoder](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/L2Encoder.sol) helper contract with view methods to encode transaction params for compressed methods.

Methods
-------

[](#methods)

### supply

[](#methods-supply)

    function supply(bytes32 args) external override

Calldata efficient wrapper of the supply function on behalf of the caller. Supplies asset into the protocol, minting the same amount of corresponding aTokens, and transferring them to msg.sender.

You can use data returned from encodeSupplyParams() method in [L2Encoder](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/L2Encoder.sol) helper contract to pass to this method.

#### Input Parameters:

[](#methods-supply-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| args | bytes32 | 
Arguments for the supply function packed in one bytes32  
bit 0-15: uint16 assetId - the index of the asset in the reservesList  
bit 16-143: uint128 shortenedAmount - cast to 256 bits at decode time, if type(uint128).max the value will be expanded to type(uint256).max  
bit 144-159: uint16 referralCode - used for 3rd party integrations

 |  |

### supplyWithPermit

[](#methods-supplywithpermit)

    function supplyWithPermit(bytes32 args, bytes32 r, bytes32 s) external override

Calldata efficient wrapper of the supplyWithPermit function on behalf of the caller. Supply with transfer approval of supplied asset via permit function. This method removes the need for separate approval transaction before supplying asset to the pool.

You can use data returned from encodeSupplyWithPermitParams() method in [L2Encoder](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/L2Encoder.sol) helper contract to pass to this method.

#### Input Parameters:

[](#methods-supplywithpermit-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| args | bytes32 | 
Arguments for the supply function packed in one bytes32  
bit 0-15: uint16 assetId - the index of the asset in the reservesList  
bit 16-143: uint128 shortenedAmount - cast to 256 bits at decode time, if type(uint128).max the value will be expanded to type(uint256).max  
bit 144-159: uint16 referralCode - used for 3rd party integrations  
bit 160-191: uint32 shortenedDeadline - shortened deadline from the original uint256  
bit 192-199: uint8 permitV - the V parameter of ERC712 permit signature

 |  |
| r | bytes32 | The R parameter of ERC712 permit signature |  |
| s | bytes32 | The S parameter of ERC712 permit signature |  |

### withdraw

[](#methods-withdraw)

    function withdraw(bytes32 args) external override returns (uint256)

Calldata efficient wrapper of the withdraw function, withdrawing to the caller. Withdraws amount of the underlying asset, i.e. redeems the underlying token and burns the aTokens.

If the user has any existing debt backed by the underlying token, the maximum amount available to withdraw is the amount that will not leave the user with a health factor < 1 after the withdrawal.

You can use data returned from encodeWithdrawParams() method in [L2Encoder](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/L2Encoder.sol) helper contract to pass to this method.

#### Input Parameters:

[](#methods-withdraw-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| args | bytes32 | 
Arguments for the withdraw function packed in one bytes32  
bit 0-15: uint16 assetId - the index of the asset in the reservesList  
bit 16-143: uint128 shortenedAmount - cast to 256 bits at decode time, if type(uint128).max the value will be expanded to type(uint256).max

 |  |

#### Return Value:

[](#methods-withdraw-return-value)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| amount | uint256 | The final amount of the underlying asset withdrawn, denominated in the base unit of the asset (e.g., wei for ETH, smallest unit for ERC-20 tokens). This is the amount actually transferred to the caller, accounting for constraints like liquidity and health factor. |  |

### borrow

[](#methods-borrow)

    function borrow(bytes32 args) external override

Calldata efficient wrapper of the borrow function, borrowing on behalf of the caller. Borrows amount of asset with interestRateMode, sending the amount to msg.sender, with the debt being incurred by onBehalfOf.

You can use data returned from encodeBorrowParams() method in [L2Encoder](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/L2Encoder.sol) helper contract to pass to this method.

#### Input Parameters:

[](#methods-borrow-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| args | bytes32 | 
Arguments for the borrow function packed in one bytes32  
bit 0-15: uint16 assetId - the index of the asset in the reservesList  
bit 16-143: uint128 shortenedAmount - cast to 256 bits at decode time, if type(uint128).max the value will be expanded to type(uint256).max  
bit 144 - 151: uint8 shortenedInterestRateMode  
bit 152 - 167: uint16 referralCode - used for 3rd party integrations

 |  |

### repay

[](#methods-repay)

    function repay(bytes32 args) external override returns (uint256)

Calldata efficient wrapper of the repay function, repaying on behalf of the caller. Repays debt of an asset for the given interestRateMode.

You can use data returned from encodeRepayParams() method in [L2Encoder](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/L2Encoder.sol) helper contract to pass to this method.

#### Input Parameters:

[](#methods-repay-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| args | bytes32 | 
Arguments for the repay function packed in one bytes32  
bit 0-15: uint16 assetId - the index of the asset in the reservesList  
bit 16-143: uint128 shortenedAmount - cast to 256 bits at decode time, if type(uint128).max the value will be expanded to type(uint256).max  
bit 144 - 151: uint8 shortenedInterestRateMode

 |  |

#### Return Values:

[](#methods-repay-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The final amount repaid |  |

### repayWithPermit

[](#methods-repaywithpermit)

    function repayWithPermit(bytes32 args, bytes32 r, bytes32 s) external override returns (uint256)

Calldata efficient wrapper of the repayWithPermit function, repaying on behalf of the caller. Repay with transfer approval of borrowed asset via permit function. This method removes the need for separate approval transaction before repaying asset to the pool.

You can use data returned from encodeRepayWithPermitParams() method in [L2Encoder](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/L2Encoder.sol) helper contract to pass to this method.​

#### Input Parameters:

[](#methods-repaywithpermit-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| args | bytes32 | 
Arguments for the repayWithPermit function packed in one bytes32  
bit 0-15: uint16 assetId - the index of the asset in the reservesList  
bit 16-143: uint128 shortenedAmount - cast to 256 bits at decode time, if type(uint128).max the value will be expanded to type(uint256).max  
bit 144 - 151: uint8 shortenedInterestRateMode  
bit 152-183: uint32 shortenedDeadline - shortened deadline from original uint256  
bit 184-191: uint8 permitV - the V parameter of ERC712 permit signature

 |  |
| r | bytes32 | The R parameter of ERC712 permit signature |  |
| s | bytes32 | The S parameter of ERC712 permit signature |  |

#### Return Values:

[](#methods-repaywithpermit-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The final amount repaid |  |

### repayWithATokens

[](#methods-repaywithatokens)

    function repayWithATokens(bytes32 args) external override returns (uint256)

Calldata efficient wrapper of the repayWithATokens function. Allows user to repay with aTokens of the underlying debt asset without any approvals, for example, Pay DAI debt using aDAI tokens.

You can use data data returned from encodeRepayWithATokensParams() method in [L2Encoder](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/L2Encoder.sol) helper contract to pass to this method.

#### Input Parameters:

[](#methods-repaywithatokens-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| args | bytes32 | 
Arguments for the repayWithATokens function packed in one bytes32  
bit 0-15: uint16 assetId - the index of the asset in the reservesList  
bit 16-143: uint128 shortenedAmount - cast to 256 bits at decode time, if type(uint128).max the value will be expanded to type(uint256).max  
bit 144 - 151: uint8 shortenedInterestRateMode

 |  |

#### Return Values:

[](#methods-repaywithatokens-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The final amount repaid |  |

### setUserUseReserveAsCollateral

[](#methods-setuserusereserveascollateral)

    function setUserUseReserveAsCollateral(bytes32 args) external override

Calldata efficient wrapper of the setUserUseReserveAsCollateral function. Sets the asset of msg.sender to be used as collateral or not.

You can use data returned from encodeSetUserUseReserveAsCollateral() method in [L2Encoder](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/L2Encoder.sol) helper contract to pass to this method.​

#### Input Parameters:

[](#methods-setuserusereserveascollateral-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| args | bytes32 | 
Arguments for the setUserUseReserveAsCollateral function packed in one bytes32  
bit 0-15: uint16 assetId - the index of the asset in the reservesList  
bit 16: 0 => enable useAsCollateral, 1 => disable useAsCollateral

 |  |

### liquidationCall

[](#methods-liquidationcall)

    function liquidationCall(bytes32 args1, bytes32 args2) external override

Calldata efficient wrapper of the liquidationCall function. Liquidate positions with a health factor below 1.

You can use data returned from encodeLiquidationCall() method in [L2Encoder](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/L2Encoder.sol) helper contract to pass to this method.​

#### Input Parameters:

[](#methods-liquidationcall-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| args1 | bytes32 | 
Part of the arguments for the liquidationCall function packed in one bytes32  
bit 0-15: uint16 collateralAssetId - the index of the collateral asset in the reservesList  
bit 16-31: uint16 debtAssetId - the index of the debt asset in the reservesList  
bit 32-191: address of the user being liquidated

 |  |
| args2 | bytes32 | 

Part of the arguments for the liquidationCall function packed in one bytes32  
bit 0-127: uint128 shortenedDebtToCover is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to type(uint256).max  
bit 128: receiveAToken - 0 => receive aToken, 1 => receive underlying asset

 |  |</content>
</page>

<page>
  <title>View Contracts</title>
  <url>https://aave.com/docs/developers/smart-contracts/view-contracts</url>
  <content>[](#view-contracts)

The Aave Protocol has several view contracts to assist with querying onchain data.

UiPoolDataProvider
------------------

[](#uipooldataprovider)

Contract that returns an array of all reserve or user data for a particular market (for example, liquidity, token addresses, rate strategy), used by the [Aave Interface](https://github.com/aave/interface/) to display Markets and Dashboard data. Compatible with both V2 and V3 of the Aave Protocol.

The [Aave Utilities SDK](https://github.com/aave/aave-utilities) includes an interface to make calls to this contract, and functions to format the response for frontend use-cases.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/UiPoolDataProviderV3.sol).

View Methods
------------

[](#view-methods)

### getReservesList

[](#view-methods-getreserveslist)

    function getReservesList(IPoolAddressesProvider provider) public view override returns (address[] memory)

Returns the list of initialised reserves in the Pool associated with the given [provider](https://aave.com/docs/developers/smart-contracts/pool-addresses-provider).

#### Input Parameters:

[](#view-methods-getreserveslist-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| provider | IPoolAddressesProvider | The given provider for the associated pool |  |

#### Return Values:

[](#view-methods-getreserveslist-return-values)

| Type | Description |  |
| --- | --- | --- |
| address\[\] | The list of initialised reserves in the Pool |  |

### getReservesData

[](#view-methods-getreservesdata)

    function getReservesData(IPoolAddressesProvider provider) public view override returns (AggregatedReserveData[] memory, BaseCurrencyInfo memory)

Returns BaseCurrencyInfo of the Pool and AggregatedReserveData\[\] for all the initialised reserves in the Pool associated with the given [provider](https://aave.com/docs/developers/smart-contracts/pool-addresses-provider).

#### Input Parameters:

[](#view-methods-getreservesdata-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| provider | IPoolAddressesProvider | The given provider for the associated pool |  |

#### Return Values:

[](#view-methods-getreservesdata-return-values)

| Type | Description |  |
| --- | --- | --- |
| BaseCurrencyInfo | The base currency information |  |
| AggregatedReserveData\[\] | The aggregated reserve data |  |

The BaseCurrencyInfo struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| marketReferenceCurrencyUnit | uint256 | Reference aka base currency of the Aave market |  |
| marketReferenceCurrencyPriceInUsd | int256 | Price of reference aka base currency in USD |  |
| networkBaseTokenPriceInUsd | int256 | Price of native token of the network/chain in USD |  |
| networkBaseTokenPriceDecimals | uint8 | Decimals of native token of the network/chain |  |

The AggregatedReserveData struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| underlyingAsset | address | The address of the underlying asset of the reserve |  |
| name | string | The name of the underlying reserve asset |  |
| symbol | string | The symbol of the underlying reserve asset |  |
| decimals | uint256 | The number of decimals of the reserve |  |
| baseLTVasCollateral | uint256 | The ltv of the reserve |  |
| reserveLiquidationThreshold | uint256 | The liquidation threshold of the reserve |  |
| reserveLiquidationBonus | uint256 | The liquidation bonus of the resurve |  |
| reserveFactor | uint256 | The reserve factor of the reserve |  |
| usageAsCollateralEnabled | bool | true if the asset is enabled to be used as collateral, false otherwise |  |
| borrowingEnabled | bool | true if borrowing is enabled, false otherwise |  |
| isActive | bool | true if reserve is active, false otherwise |  |
| isFrozen | bool | true if reserve is frozen, false otherwise |  |
| BASE DATA |  |  |  |
| liquidityIndex | uint128 | The liquidity index of the reserve |  |
| variableBorrowIndex | uint128 | The variable borrow index of the reserve |  |
| liquidityRate | uint128 | The liquidity rate of the reserve |  |
| variableBorrowRate | uint128 | The variable borrow rate of the reserve |  |
| lastUpdateTimestamp | uint40 | The timestamp of the last update of the reserve |  |
| aTokenAddress | address | The AToken address of the reserve |  |
| variableDebtTokenAddress | address | The VariableDebtToken address of the reserve |  |
| interestRateStrategyAddress | address | The address of the Interest Rate strategy |  |
|  |  |  |  |
| availableLiquidity | uint256 | The liquidity available |  |
| totalScaledVariableDebt | uint256 | The total scaled variable debt |  |
| priceInMarketReferenceCurrency | uint256 | Price of reference aka base currency of Aave market |  |
| priceOracle | address | The address of the price oracle used by the associated market |  |
| variableRateSlope1 | uint256 | The variable rate slope |  |
| variableRateSlope2 | uint256 | The variable rate slope |  |
| baseVariableBorrowRate | uint256 | The base variable borrow rate, expressed in ray |  |
| optimalUsageRatio | uint256 | The optimal usage ratio |  |
|  |  |  |  |
| V3 ONLY |  |  |  |
| isPaused | bool | true if the pool is paused, false otherwise |  |
| isSiloedBorrowing | bool | true if the asset is siloed for borrowing |  |
| accruedToTreasury | uint128 | The amount of tokens accrued to treasury that is to be minted |  |
| unbacked | uint128 | The amount of unbacked aTokens of the reserve |  |
| isolationModeTotalDebt | uint128 | The outstanding debt borrowed against this asset in isolation mode |  |
| flashLoanEnabled | bool | true is asset is available to borrow in flash loan transaction |  |
|  |  |  |  |
| debtCeiling | uint256 | The debt ceiling of the reserve |  |
| debtCeilingDecimals | uint256 | The debt ceiling decimals |  |
| eModeCategoryId | uint8 | The eMode id of the reserve |  |
| borrowCap | uint256 | The borrow cap of the reserve |  |
| supplyCap | uint256 | The supply cap of the reserve |  |
| borrowableInIsolation | bool | true is asset available to borrow against isolated collateral assets |  |
| v3.1 |  |  |  |
| virtualAccActive | bool | true if virtual accounting is enabled for a reserve |  |
| virtualUnderlyingBalance | uint128 | Balance of reserve if virtual accounting is used |  |

### getUserReservesData

[](#view-methods-getuserreservesdata)

    function getUserReservesData(IPoolAddressesProvider provider, address user) external view override returns (UserReserveData[] memory, uint8)

Returns UserReserveData\[\] for all user reserves in the Pool associated with the given [provider](https://aave.com/docs/core-contracts/interfaces/IPoolAddressesProvider).

#### Input Parameters:

[](#view-methods-getuserreservesdata-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| provider | IPoolAddressesProvider | The given provider for the associated pool |  |
| user | address | The address of the user |  |

### UserReserveData

[](#view-methods-userreservedata)

| Type | Description |  |
| --- | --- | --- |
| UserReserveData\[\] | The user reserve data |  |

The [UserReserveData](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/interfaces/IUiPoolDataProviderV3.sol) struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| underlyingAsset | address | The address of the underlying asset supplied/borrowed |  |
| scaledATokenBalance | uint256 | The scaled balance of the aToken. scaledBalance = balance/liquidityIndex |  |
| usageAsCollateralEnabledOnUser | bool | true if the supplied asset is enabled to be used as collateral, false otherwise |  |
| scaledVariableDebt | uint256 | The scaled balance of borrow position: (current balance = scaled balance \* liquidity index) |  |

### getEModes

[](#view-methods-getemodes)

Returns an array of all available E-mode categories in the Pool associated with the [provider](https://aave.com/docs/developers/smart-contracts/pool-addresses-provider).

    function getEModes(IPoolAddressesProvider provider) external view returns (Emode[] memory)

#### Input Parameters:

[](#view-methods-getemodes-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| provider | IPoolAddressesProvider | The PoolAddressesProvider for the associated Pool to fetch EMode categories for |  |

#### Return Parameters:

[](#view-methods-getemodes-return-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| categories | Emode\[\] | The list of E-Modes available in the pool |  |

#### Emode

[](#view-methods-getemodes-emode)

The Emode struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| id | uint8 | The unique identifier of the E-Mode |  |
| eMode | DataTypes.EModeCategory | The E-Mode configuration details |  |

#### DataTypes.EModeCategory

[](#view-methods-getemodes-datatypesemodecategory)

The EModeCategory struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| ltv | uint16 | Loan-to-Value ratio for the E-Mode category |  |
| liquidationThreshold | uint16 | The threshold at which liquidation is triggered |  |
| liquidationBonus | uint16 | The bonus applied during liquidation |  |
| collateralBitmap | uint128 | Bitmap representing eligible collateral for this E-Mode |  |
| label | string | The label describing the E-Mode category |  |
| borrowableBitmap | uint128 | Bitmap representing borrowable assets for this E-Mode |  |

WalletBalanceProvider
---------------------

[](#walletbalanceprovider)

Fetches tokens balances for all underlying tokens of Aave reserves for one user address.

This contract is not used within the Aave Protocol. It is an accessory contract used to reduce the number of calls towards the blockchain from the Aave backend.

For getting ETH (native chain token) balance use MOCK\_ETH\_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/WalletBalanceProvider.sol).

View Methods
------------

[](#view-methods)

### balanceOf

[](#view-methods-balanceof)

    function balanceOf(address user, address token) public view returns (uint256)

Checks the token balance of a wallet in a token contract. Returns the balance of the token for user (ETH included with MOCK\_ETH\_ADDRESS).

#### Input Parameters:

[](#view-methods-balanceof-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| user | address | The address of the user |  |
| token | address | The address of the token |  |

#### Return Values:

[](#view-methods-balanceof-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The balance of the token for user. Returns 0 for a non-contract address |  |

### batchBalanceOf

[](#view-methods-batchbalanceof)

    function batchBalanceOf(address[] calldata users, address[] calldata tokens) external view returns (uint256[] memory)

Returns balances for a list of users and tokens (ETH included with MOCK\_ETH\_ADDRESS).

#### Input Parameters:

[](#view-methods-batchbalanceof-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| users | address\[\] | The list of users |  |
| tokens | address\[\] | The list of tokens |  |

#### Return Values:

[](#view-methods-batchbalanceof-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256\[\] | A list of balances for each user |  |

### getUserWalletBalances

[](#view-methods-getuserwalletbalances)

    function getUserWalletBalances(address provider, address user) external view returns (address[] memory, uint256[] memory)

Provides balances of user wallet for all reserves available on the pool.

#### Input Parameters:

[](#view-methods-getuserwalletbalances-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| provider | address | The address of the provider |  |
| user | address | The address of the user |  |

#### Return Values:

[](#view-methods-getuserwalletbalances-return-values)

| Type | Description |  |
| --- | --- | --- |
| address\[\] | A list of user wallets |  |
| uint256\[\] | A list of balances for each user |  |

UiIncentiveDataProviderV3
-------------------------

[](#uiincentivedataproviderv3)

Contract that returns an array of all reserve incentives or user claimable rewards within a particular market, used by the [Aave Labs Interface](https://github.com/aave/interface/) to display incentives data. Compatible with both V2 and V3 of the Aave Protocol.

The [Aave Utilities SDK](https://github.com/aave/aave-utilities) includes an interface to make calls to this contract, and functions to format the response for frontend use-cases.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/UiIncentiveDataProviderV3.sol).

View Methods
------------

[](#view-methods)

#### getFullReservesIncentiveData

[](#view-methods-getuserwalletbalances-getfullreservesincentivedata)

    function getFullReservesIncentiveData(IPoolAddressesProvider provider, address user)    external    view    override    returns (AggregatedReserveIncentiveData[] memory, UserReserveIncentiveData[] memory)

Returns both AggregatedReserveIncentiveData\[\] and UserReserveIncentiveData\[\] for the given user for the pool associated with the given [provider](https://aave.com/docs/core_contracts/interfaces/IPoolAddressesProvider).

#### Input Parameters:

[](#view-methods-getuserwalletbalances-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| provider | IPoolAddressesProvider | The given provider for the associated pool |  |
| user | address | The address of the user |  |

#### Return Values:

[](#view-methods-getuserwalletbalances-return-values)

| Type | Description |  |
| --- | --- | --- |
| AggregatedReserveIncentiveData\[\] | The aggregated reserve incentive data |  |
| UserReserveIncentiveData\[\] | The user reserve incentive data |  |

The AggregatedReserveIncentiveData struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| underlyingAsset | address | Address of the asset supplied/borrowed in Pool |  |
| aIncentiveData | IncentiveData | Details of rewards distributed for supplying to Aave Pool i.e. rewards for aToken holders |  |
| vIncentiveData | IncentiveData | Details of rewards distributed for variable debt borrowed from Aave Pool i.e. rewards for vToken holders |  |

The UserReserveIncentiveData struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| underlyingAsset | address | Address of the asset supplied/borrowed in Pool |  |
| aTokenIncentivesUserData | UserIncentiveData | Details of user rewards received for supplying to Aave Pool i.e. rewards for aToken |  |
| vTokenIncentivesUserData | UserIncentiveData | Details of user rewards received for borrowing at variable rate from Aave Pool i.e. rewards for vToken |  |

#### getReservesIncentivesData

[](#view-methods-getuserwalletbalances-getreservesincentivesdata)

    function getReservesIncentivesData(IPoolAddressesProvider provider) external view override returns (AggregatedReserveIncentiveData[] memory)

Returns AggregatedReserveIncentiveData\[\] for the pool associated with the given [provider](https://aave.com/docs/developers/smart-contracts/pool-addresses-provider).

#### Input Parameters:

[](#view-methods-getuserwalletbalances-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| provider | IPoolAddressesProvider | The given provider for the associated pool |  |

#### Return Values:

[](#view-methods-getuserwalletbalances-return-values)

| Type | Description |  |
| --- | --- | --- |
| AggregatedReserveIncentiveData\[\] | The aggregated reserve incentive data |  |

The AggregatedReserveIncentiveData struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| underlyingAsset | address | Address of the asset supplied/borrowed in Pool |  |
| aIncentiveData | IncentiveData | Details of rewards distributed for supplying to Aave Pool i.e. rewards for aToken holders |  |
| vIncentiveData | IncentiveData | Details of rewards distributed for variable debt borrowed from Aave Pool i.e. rewards for vToken holders |  |

#### getUserReservesIncentivesData

[](#view-methods-getuserwalletbalances-getuserreservesincentivesdata)

    function getUserReservesIncentivesData(IPoolAddressesProvider provider, address user) external view override returns (UserReserveIncentiveData[] memory)

Returns the UserReserveIncentiveData\[\] for the given user for the pool associated with the given [provider](https://aave.com/docs/developers/smart-contracts/pool-addresses-provider).

#### Input Parameters:

[](#view-methods-getuserwalletbalances-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| provider | IPoolAddressesProvider | The given provider for the associated pool |  |

#### Return Values:

[](#view-methods-getuserwalletbalances-return-values)

| Type | Description |  |
| --- | --- | --- |
| UserReserveIncentiveData\[\] | The user reserve incentive data |  |

The UserReserveIncentiveData struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| underlyingAsset | address | Address of the asset supplied/borrowed in Pool |  |
| aTokenIncentivesUserData | UserIncentiveData | Details of user rewards received for supplying to Aave Pool i.e. rewards for aToken |  |
| vTokenIncentivesUserData | UserIncentiveData | Details of user rewards received for borrowing at variable rate from Aave Pool i.e. rewards for vToken |  |

AaveProtocolDataProvider
------------------------

[](#aaveprotocoldataprovider)

The AaveProtocolDataProvider is a peripheral contract to collect and pre-process information from the [Pool](https://aave.com/docs/developers/smart-contracts/pool). This contract contains methods for querying token addresses, reserve parameters, and user account information. The methods of the PoolDataProvider are more granular than the UiPoolDataProvider, which queries data for reserve tokens or user balances simultaneously.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/helpers/AaveProtocolDataProvider.sol).

View Methods
------------

[](#view-methods)

### getAllReservesTokens

[](#view-methods-getallreservestokens)

    function getAllReservesTokens() external view returns (TokenData[] memory)

Returns a list of the existing reserves in the pool, pairs include the symbol and tokenAddress. Handles MKR and ETH in a different way since they do not have standard symbol functions.

#### Return Values:

[](#view-methods-getallreservestokens-return-values)

| Type | Description |  |
| --- | --- | --- |
| TokenData\[\] | The list of reserves, pairs of symbols and addresses |  |

The TokenData struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| symbol | string | The symbol of the underlying reserve asset |  |
| tokenAddress | address | The address of the underlying reserve asset |  |

### getAllATokens

[](#view-methods-getallatokens)

    function getAllATokens() external view returns (TokenData[] memory)

Returns a list of the existing ATokens in the pool, pairs include the symbol and tokenAddress.

#### Return Values:

[](#view-methods-getallatokens-return-values)

| Type | Description |  |
| --- | --- | --- |
| TokenData\[\] | The list of ATokens, pairs of symbols and addresses |  |

The TokenData struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| symbol | string | The symbol of aToken of the reserve |  |
| tokenAddress | address | The address of aToken of the reserve |  |

### getReserveConfigurationData

[](#view-methods-getreserveconfigurationdata)

    function getReserveConfigurationData(address asset) external view returns (    uint256 decimals,    uint256 ltv,    uint256 liquidationThreshold,    uint256 liquidationBonus,    uint256 reserveFactor,    bool usageAsCollateralEnabled,    bool borrowingEnabled,    bool stableBorrowRateEnabled,    bool isActive,    bool isFrozen)

Returns the configuration data of the reserve as described below. Does not return borrow and supply caps, nor pause flag for compatibility.

#### Input Parameters:

[](#view-methods-getreserveconfigurationdata-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getreserveconfigurationdata-return-values)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| decimals | uint256 | The number of decimals of the reserve |  |
| ltv | uint256 | The ltv of the reserve |  |
| liquidationThreshold | uint256 | The liquidation threshold of the reserve |  |
| liquidationBonus | uint256 | The liquidation bonus of the reserve |  |
| reserveFactor | uint256 | The reserve factor of the reserve |  |
| usageAsCollateralEnabled | bool | true if the usage as collateral is enabled, false otherwise |  |
| borrowingEnabled | bool | true if borrowing is enabled, false otherwise |  |
| stableBorrowRateEnabled | bool | Always false (deprecated) |  |
| isActive | bool | true if reserve is active, false otherwise |  |
| isFrozen | bool | true if reserve is frozen, false otherwise |  |

### getReserveCaps

[](#view-methods-getreservecaps)

    function getReserveCaps(address asset) external view returns (uint256 borrowCap, uint256 supplyCap)

Returns the caps parameters of the reserve.

#### Input Parameters:

[](#view-methods-getreservecaps-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

### Return Values:

[](#view-methods-return-values)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| borrowCap | uint256 | The borrow cap of the reserve |  |
| supplyCap | uint256 | The supply cap of the reserve |  |

### getPaused

[](#view-methods-getpaused)

    function getPaused(address asset) external view returns (bool isPaused)

Returns true if the pool isPaused.

#### Input Parameters:

[](#view-methods-getpaused-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getpaused-return-values)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| isPaused | bool | true if the pool is paused, false otherwise |  |

### getSiloedBorrowing

[](#view-methods-getsiloedborrowing)

    function getSiloedBorrowing(address asset) external view override returns (bool)

Returns the siloed borrowing flag. It returns true if the asset is [siloed for borrowing](https://aave.com/docs/whats-new/siloed-borrowing.md).

#### Input Parameters:

[](#view-methods-getsiloedborrowing-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getsiloedborrowing-return-values)

| Type | Description |  |
| --- | --- | --- |
| bool | true if the asset is siloed for borrowing |  |

### getLiquidationProtocolFee

[](#view-methods-getliquidationprotocolfee)

    function getLiquidationProtocolFee(address asset) external view override returns (uint256)

Returns the protocol fee on the liquidation bonus.

#### Input Parameters:

[](#view-methods-getliquidationprotocolfee-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getliquidationprotocolfee-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The protocol fee on liquidation |  |

### getUnbackedMintCap

[](#view-methods-getunbackedmintcap)

    function getUnbackedMintCap(address asset) external view override returns (uint256)

Returns the unbacked mint cap of the reserve.

#### Input Parameters:

[](#view-methods-getunbackedmintcap-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getunbackedmintcap-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The unbacked mint cap of the reserve |  |

### getDebtCeiling

[](#view-methods-getdebtceiling)

    function getDebtCeiling(address asset) external view override returns (uint256)

Returns the debt ceiling of the reserve.

#### Input Parameters:

[](#view-methods-getdebtceiling-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getdebtceiling-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The debt ceiling of the reserve |  |

### getReserveData

[](#view-methods-getreservedata)

    function getReserveData(address asset) external view override returns (    uint256 unbacked,    uint256 accruedToTreasuryScaled,    uint256 totalAToken,    uint256 totalStableDebt,    uint256 totalVariableDebt,    uint256 liquidityRate,    uint256 variableBorrowRate,    uint256 stableBorrowRate,    uint256 averageStableBorrowRate,    uint256 liquidityIndex,    uint256 variableBorrowIndex,    uint40 lastUpdateTimestamp)

Returns the reserve data.

#### Input Parameters:

[](#view-methods-getreservedata-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getreservedata-return-values)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| unbacked | uint256 | The amount of unbacked aTokens of the reserve |  |
| accruedToTreasuryScaled | uint256 | The scaled amount of tokens accrued to treasury that is to be minted |  |
| totalAToken | uint256 | The total supply of the aToken |  |
| totalStableDebt | uint256 | The total stable debt of the reserve (deprecated) |  |
| totalVariableDebt | uint256 | The total variable debt of the reserve |  |
| liquidityRate | uint256 | The liquidity rate of the reserve |  |
| variableBorrowRate | uint256 | The variable borrow rate of the reserve |  |
| stableBorrowRate | uint256 | The stable borrow rate of the reserve (deprecated) |  |
| averageStableBorrowRate | uint256 | The average stable borrow rate of the reserve (deprecated) |  |
| liquidityIndex | uint256 | The liquidity index of the reserve |  |
| variableBorrowIndex | uint256 | The variable borrow index of the reserve |  |
| lastUpdateTimestamp | uint40 | The timestamp of the last update of the reserve |  |

### getATokenTotalSupply

[](#view-methods-getatokentotalsupply)

    function getATokenTotalSupply(address asset) external view override returns (uint256)

Returns the total supply of aTokens for a given asset.

#### Input Parameters:

[](#view-methods-getatokentotalsupply-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getatokentotalsupply-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The total supply of the aToken |  |

### getTotalDebt

[](#view-methods-gettotaldebt)

    function getTotalDebt(address asset) external view override returns (uint256)

Returns the total debt for a given asset.

#### Input Parameters:

[](#view-methods-gettotaldebt-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-gettotaldebt-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The total borrows for an asset |  |

### getUserReserveData

[](#view-methods-getuserreservedata)

    function getUserReserveData(address asset, address user) external view returns (    uint256 currentATokenBalance,    uint256 currentStableDebt,    uint256 currentVariableDebt,    uint256 principalStableDebt,    uint256 scaledVariableDebt,    uint256 stableBorrowRate,    uint256 liquidityRate,    uint40 stableRateLastUpdated,    bool usageAsCollateralEnabled)

Returns the following user reserve data.

#### Input Parameters:

[](#view-methods-getuserreservedata-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| user | address | The address of the user |  |

#### Return Values:

[](#view-methods-getuserreservedata-return-values)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| currentATokenBalance | uint256 | The current AToken balance of the user |  |
| currentStableDebt | uint256 | The current stable debt of the user (deprecated) |  |
| currentVariableDebt | uint256 | The current variable debt of the user |  |
| principalStableDebt | uint256 | The principal stable debt of the user (deprecated) |  |
| scaledVariableDebt | uint256 | The scaled variable debt of the user |  |
| stableBorrowRate | uint256 | The stable borrow rate of the user (deprecated) |  |
| liquidityRate | uint256 | The liquidity rate of the reserve |  |
| stableRateLastUpdated | uint40 | The timestamp of the last update of the user stable rate (deprecated) |  |
| usageAsCollateralEnabled | bool | true if the user is using the asset as collateral, else false |  |

### getReserveTokensAddresses

[](#view-methods-getreservetokensaddresses)

    function getReserveTokensAddresses(address asset) external view override returns (    address aTokenAddress,    address stableDebtTokenAddress,    address variableDebtTokenAddress)

Returns the addresses of the aToken, stableDebtToken and variableDebtToken of the reserve.

#### Input Parameters:

[](#view-methods-getreservetokensaddresses-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getreservetokensaddresses-return-values)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| aTokenAddress | address | The AToken address of the reserve |  |
| stableDebtTokenAddress | address | The StableDebtToken address of the reserve (deprecated) |  |
| variableDebtTokenAddress | address | The VariableDebtToken address of the reserve |  |

### getInterestRateStrategyAddress

[](#view-methods-getinterestratestrategyaddress)

    function getInterestRateStrategyAddress(address asset) external view override returns (address irStrategyAddress)

Returns the address of the Interest Rate strategy.

#### Input Parameters:

[](#view-methods-getinterestratestrategyaddress-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |

#### Return Values:

[](#view-methods-getinterestratestrategyaddress-return-values)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| irStrategyAddress | address | The address of the Interest Rate strategy |  |

Pure Methods
------------

[](#pure-methods)

#### getDebtCeilingDecimals

[](#view-methods-getinterestratestrategyaddress-getdebtceilingdecimals)

    function getDebtCeilingDecimals() external pure override returns (uint256)

Returns the debt ceiling decimals.

#### Return Values:

[](#view-methods-getinterestratestrategyaddress-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The debt ceiling decimals |  |</content>
</page>

<page>
  <title>Incentives</title>
  <url>https://aave.com/docs/developers/smart-contracts/incentives</url>
  <content>[](#incentives)

The [UiIncentiveDataProvider](https://aave.com/docs/developers/smart-contracts/view-contracts) provides methods to query all active incentive emissions, and claimable user incentives for a particular Aave market.

RewardsController
-----------------

[](#rewardscontroller)

RewardsController is the main rewards contract where the user interacts to claim the rewards of their positions. It is an abstract contract template to build Distributors contracts for ERC20 rewards to protocol participants. RewardsController inherits from [RewardsDistributor](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/rewards/RewardsDistributor.sol) to handle the distribution of rewards. The users of the incentivized ERC20 assets will accrue value if they hold their tokens in possession without the need for staking or blocking the assets inside a contract.

The users can claim all the rewards or an individual reward per transaction, with a variety of functions that allow more granularity at claim.

At every transfer, the asset must call the handleAction method to account for the user's rewards.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/rewards/RewardsController.sol).

Write Methods
-------------

[](#write-methods)

### initialize

[](#write-methods-initialize)

    function initialize(address) external initializer

Initialize RewardsController instance.

#### Input Parameters:

[](#write-methods-initialize-input-parameters)

| Type | Description |  |
| --- | --- | --- |
| address | Unused but required due to being initialized by PoolAddressProvider.\_updateImpl() |  |

### configureAssets

[](#write-methods-configureassets)

    function configureAssets(RewardsDataTypes.RewardsConfigInput[] memory config) external override onlyEmissionManager

Configure assets to incentivize with an emission of rewards per second until the end of distribution.

#### Input Parameters:

[](#write-methods-configureassets-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| config | RewardsDataTypes.RewardsConfigInput\[\] | The emission per second following rewards unit decimals |  |

The [RewardsDataTypes.RewardsConfigInput](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/rewards/libraries/RewardsDataTypes.sol) struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| emissionPerSecond | uint88 | The emission per second following rewards unit decimals |  |
| totalSupply | uint256 | The total supply of the asset to incentivize |  |
| distributionEnd | uint32 | The end of the distribution of the incentives for an asset |  |
| asset | address | The asset address to incentivize |  |
| reward | address | The reward token address |  |
| transferStrategy | ITransferStrategy | The TransferStrategy address with the install hook and claim logic |  |
| rewardOracle | IEACAggregatorProxy | The Price Oracle of a reward to visualize the incentives at the UI frontend. Must follow Chainlink Aggregator IEACAggregatorProxy interface to be compatible. |  |

### setTransferStrategy

[](#write-methods-settransferstrategy)

    function setTransferStrategy(address reward, ITransferStrategyBase transferStrategy) external onlyEmissionManager

Sets a TransferStrategy logic contract that determines the logic of the rewards transfer.

#### Input Parameters:

[](#write-methods-settransferstrategy-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| reward | address | The address of the reward token |  |
| transferStrategy | address | The address of the TransferStrategy logic contract |  |

### setRewardOracle

[](#write-methods-setrewardoracle)

    function setRewardOracle(address reward, IEACAggregatorProxy rewardOracle) external onlyEmissionManager

Sets an Aave Oracle contract to enforce rewards with a source of value.

At the moment of reward configuration, the Incentives Controller performs a check to see if the reward asset oracle is compatible with IEACAggregator proxy. This check is enforced for integrators to show incentives at the current Aave UI without needing to set up an external price registry.

#### Input Parameters:

[](#write-methods-setrewardoracle-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| reward | address | The address of the reward to set the price aggregator |  |
| rewardOracle | IEACAggregatorProxy | The address of price aggregator that follows the IEACAggregatorProxy interface |  |

### handleAction

[](#write-methods-handleaction)

    function handleAction(address user, uint256 totalSupply, uint256 userBalance) external override

Called by the corresponding asset on transfer hook to update the rewards distribution of a user.

#### Input Parameters:

[](#write-methods-handleaction-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| user | address | The address of the user |  |
| totalSupply | uint256 | The user balance of the asset |  |
| userBalance | uint256 | The total supply of the asset |  |

### claimRewards

[](#write-methods-claimrewards)

    function claimRewards(    address[] calldata assets,    uint256 amount,    address to,    address reward) external override returns (uint256)

Claims reward for a user to the desired address, on all the assets of the pool, accumulating the pending rewards. Rewards are received by the to address.

#### Input Parameters:

[](#write-methods-claimrewards-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| assets | address\[\] | The list of assets to check eligible distributions before claiming rewards. Pass a/s/vToken addresses |  |
| amount | uint256 | The amount of rewards to claim, expressed in wei. Pass MAX\_UINT to claim the entire unclaimed reward balance |  |
| to | address | The address that will be receiving the rewards |  |
| reward | address | The address of the reward token (e.g., stkAAVE) |  |

#### Return Values:

[](#write-methods-claimrewards-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The amount of rewards claimed for one specific reward |  |

The msg.sender must be an authorized claimer set using the setClaimer() method, via a Governance Vote.

### claimRewardsOnBehalf

[](#write-methods-claimrewardsonbehalf)

    function claimRewardsOnBehalf(    address[] calldata assets,    uint256 amount,    address user,    address to,    address reward) external override onlyAuthorizedClaimers(msg.sender, user) returns (uint256)

Claims rewards for a user on behalf, on all the assets of the pool, accumulating the pending rewards of the assets passed by the first argument. The caller must be whitelisted via the allowClaimOnBehalf function by the EmissionManager role held by Aave Governance. Rewards are received by the to address.

#### Input Parameters:

[](#write-methods-claimrewardsonbehalf-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| assets | address\[\] | The list of assets to check eligible distributions before claiming rewards. Pass a/s/vToken addresses |  |
| amount | uint256 | The amount of rewards to claim, expressed in wei. Pass MAX\_UINT to claim the entire unclaimed reward balance |  |
| user | address | The address to check and claim rewards |  |
| to | address | The address that will be receiving the rewards |  |
| reward | address | The address of the reward token being claimed (e.g., stkAAVE) |  |

#### Return Values:

[](#write-methods-claimrewardsonbehalf-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The amount of rewards claimed |  |

### claimRewardsToSelf

[](#write-methods-claimrewardstoself)

    function claimRewardsToSelf(address[] calldata assets, uint256 amount, address reward) external override returns (uint256)

Claims reward for msg.sender, on all the assets of the pool, accumulating the pending rewards passed by the first input parameter. Rewards are received by msg.sender.

#### Input Parameters:

[](#write-methods-claimrewardstoself-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| assets | address\[\] | The list of assets to check eligible distributions before claiming rewards. Pass a/s/vToken addresses |  |
| amount | uint256 | The amount of rewards to claim, expressed in wei. Pass MAX\_UINT to claim the entire unclaimed reward balance |  |
| reward | address | The address of the reward token |  |

#### Return Values:

[](#write-methods-claimrewardstoself-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The amount of rewards claimed for one specific reward |  |

### claimAllRewards

[](#write-methods-claimallrewards)

    function claimAllRewards(address[] calldata assets, address to) external override returns (address[] memory rewardsList, uint256[] memory claimedAmounts)

Claims all rewards for a user to the desired address, on all the assets of the pool, accumulating the pending rewards passed by the first input parameter. Rewards are received by the to address.

#### Input Parameters:

[](#write-methods-claimallrewards-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| assets | address\[\] | The list of assets to check eligible distributions before claiming rewards (aToken or variableDebtToken addresses) |  |
| to | address | The address that will be receiving the rewards |  |

#### Return Values:

[](#write-methods-claimallrewards-return-values)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| rewardsList | address\[\] | The list of addresses of the reward tokens |  |
| claimedAmounts | uint256\[\] | The list that contains the claimed amount per reward, following the same order as rewardsList |  |

### claimAllRewardsOnBehalf

[](#write-methods-claimallrewardsonbehalf)

    function claimAllRewardsOnBehalf(    address[] calldata assets,    address user,    address to) external override onlyAuthorizedClaimers(msg.sender, user) returns (address[] memory rewardsList, uint256[] memory claimedAmounts)

Claims all rewards for a user on behalf, on all the assets of the pool, accumulating the pending rewards passed by the first input parameter. The caller must be whitelisted via the allowClaimOnBehalf function by the EmissionManager role held by Aave Governance. Rewards are received by the to address.

#### Input Parameters:

[](#write-methods-claimallrewardsonbehalf-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| assets | address\[\] | The list of assets to check eligible distributions before claiming rewards. Pass a/s/vToken addresses |  |
| user | address | The address to check and claim rewards |  |
| to | address | The address that will be receiving the rewards |  |

#### Return Values:

[](#write-methods-claimallrewardsonbehalf-return-values)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| rewardsList | address\[\] | The list of addresses of the reward tokens |  |
| claimedAmounts | uint256\[\] | The list that contains the claimed amount per reward, following the same order as rewardsList |  |

### claimAllRewardsToSelf

[](#write-methods-claimallrewardstoself)

    function claimAllRewardsToSelf(address[] calldata assets) external override returns (address[] memory rewardsList, uint256[] memory claimedAmounts)

Claims all rewards accrued by msg.sender, on all assets of the pool, accumulating the pending rewards by the first input parameter. Rewards are received by msg.sender.

#### Input Parameters:

[](#write-methods-claimallrewardstoself-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| assets | address\[\] | The list of assets to check eligible distributions before claiming rewards. Pass a/s/vToken addresses |  |

#### Return Values:

[](#write-methods-claimallrewardstoself-return-values)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| rewardsList | address\[\] | The list of addresses of the reward tokens |  |
| claimedAmounts | uint256\[\] | The list that contains the claimed amount per reward, following the same order as rewardsList |  |

### setClaimer

[](#write-methods-setclaimer)

    function setClaimer(address user, address caller) external override onlyEmissionManager

Whitelists an address to claim rewards on behalf of another address. Can only be called by the EmissionManager.

#### Input Parameters:

[](#write-methods-setclaimer-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| user | address | The address of the user |  |
| caller | address | The address of the claimer |  |

View Methods
------------

[](#view-methods)

### getClaimer

[](#view-methods-getclaimer)

    function getClaimer(address user) external view override returns (address)

Returns the whitelisted claimer for a certain address. It returns the 0x0 address if it is not set.

#### Input Parameters:

[](#view-methods-getclaimer-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| user | address | The address of the user |  |

#### Return Values:

[](#view-methods-getclaimer-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The claimer address |  |

### getRewardOracle

[](#view-methods-getrewardoracle)

    function getRewardOracle(address reward) external view override returns (address)

Get the price aggregator oracle address.

| Name | Type | Description |  |
| --- | --- | --- | --- |
| reward | address | The address of the reward token |  |

#### Return Values:

[](#view-methods-getrewardoracle-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the reward oracle |  |

### getTransferStrategy

[](#view-methods-gettransferstrategy)

    function getTransferStrategy(address reward) external view override returns (address)

Returns the Transfer Strategy implementation contract address being used for a reward address.

| Name | Type | Description |  |
| --- | --- | --- | --- |
| reward | address | The address of the reward |  |

#### Return Values:

[](#view-methods-gettransferstrategy-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the TransferStrategy contract |  |

Pure Methods
------------

[](#pure-methods)

    function getRevision() internal pure override returns (uint256)

Returns the revision of the implementation contract.

#### Return Values:

[](#view-methods-gettransferstrategy-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The current revision version |  |</content>
</page>

<page>
  <title>Tokenization</title>
  <url>https://aave.com/docs/developers/smart-contracts/tokenization</url>
  <content>[](#tokenization)

AToken
------

[](#atoken)

aTokens are tokens minted and burnt upon supply and withdraw of assets to an Aave market. aTokens denote the amount of crypto assets supplied to the protocol and the yield earned on those assets. The aTokens’ value is pegged to the value of the corresponding supplied asset at a 1:1 ratio and can be safely stored, transferred or traded. All yield collected by the aTokens' reserves are distributed to aToken holders directly by continuously increasing their wallet balance.

This contract is the implementation of the interest bearing token for the Aave Protocol. It inherits the [ScaledBalanceTokenBase](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/tokenization/base/ScaledBalanceTokenBase.sol) and [EIP712Base](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/tokenization/base/EIP712Base.sol) token contracts.

All standard EIP20 methods are implemented for aTokens, such as balanceOf, transfer, transferFrom, approve, totalSupply etc.

balanceOf will always return the most up to date balance of the user, which includes their principal balance and the yield generated by the principal balance.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/tokenization/AToken.sol).

Write Methods
-------------

[](#write-methods)

### initialize

[](#write-methods-initialize)

    function initialize(    IPool initializingPool,    address treasury,    address underlyingAsset,    IAaveIncentivesController incentivesController,    uint8 aTokenDecimals,    string calldata aTokenName,    string calldata aTokenSymbol,    bytes calldata params) public virtual

Called when aToken instance is initialized.

#### Input Parameters:

[](#write-methods-initialize-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| initializingPool | IPool | The address of the associated pool |  |
| treasury | address | The address of the treasury |  |
| underlyingAsset | address | The address of the underlying asset |  |
| incentivesController | IAaveIncentivesController | The address of the incentives controller for this aToken |  |
| aTokenDecimals | uint8 | The decimals of the underlying asset |  |
| aTokenName | string | The name of the aToken |  |
| aTokenSymbol | string | The symbol of the aToken |  |
| params | bytes | A set of encoded parameters for additional initialization |  |

### mint

[](#write-methods-mint)

    function mint(    address caller,    address onBehalfOf,    uint256 amount,    uint256 index) external virtual override onlyPool returns (bool)

Mints amount aTokens to user.

#### Input Parameters:

[](#write-methods-mint-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| caller | address | The address performing the mint |  |
| onBehalfOf | address | The address of the user that will receive the minted aTokens |  |
| amount | uint256 | The amount of tokens getting minted |  |
| index | uint256 | The next liquidity index of the reserve |  |

#### Return Values:

[](#write-methods-mint-return-values)

| Type | Description |  |
| --- | --- | --- |
| bool | true if the the previous balance of the user was 0 |  |

### burn

[](#write-methods-burn)

    function burn(    address from,    address receiverOfUnderlying,    uint256 amount,    uint256 index) external virtual override onlyPool

Burns aTokens from user and sends the equivalent amount of underlying to receiverOfUnderlying.

In some instances, the mint event could be emitted from a burn transaction if the amount to burn is less than the interest that the user accrued.

#### Input Parameters:

[](#write-methods-burn-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| from | address | The address from which the aTokens will be burned |  |
| receiverOfUnderlying | address | The address that will receive the underlying asset |  |
| amount | uint256 | The amount of tokens that will be burned |  |
| index | uint256 | The next liquidity index of the reserve |  |

### mintToTreasury

[](#write-methods-minttotreasury)

    function mintToTreasury(uint256 amount, uint256 index) external override onlyPool

Mints aTokens to the reserve treasury.

#### Input Parameters:

[](#write-methods-minttotreasury-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| amount | uint256 | The amount of tokens getting minted |  |
| index | uint256 | The address that will receive the underlying asset |  |

### transferOnLiquidation

[](#write-methods-transferonliquidation)

    function transferOnLiquidation(    address from,    address to,    uint256 value) virtual override onlyPool

Transfers aTokens in the event of a borrow being liquidated, in case the liquidator reclaims the aToken.

#### Input Parameters:

[](#write-methods-transferonliquidation-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| from | address | The address getting liquidated, current owner of the aTokens |  |
| to | address | The recipient of aTokens |  |
| value | uint256 | The amount of tokens getting transferred |  |

### transferUnderlyingTo

[](#write-methods-transferunderlyingto)

    function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool

Transfers the underlying asset to target.

Used by the [Pool](https://aave.com/docs/developers/pool/Pool.md) to transfer assets in borrow(), withdraw() and flashLoan().

#### Input Parameters:

[](#write-methods-transferunderlyingto-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| user | address | The recipient of the underlying |  |
| amount | uint256 | The amount getting transferred |  |

### handleRepayment

[](#write-methods-handlerepayment)

    function handleRepayment(address user, address onBehalfOf, uint256 amount) external virtual override onlyPool

Handles the underlying received by the aToken after the transfer has been completed.

The default implementation is empty as with standard ERC20 tokens, nothing needs to be done after the transfer is concluded. However in the future there may be aTokens that allow for example to stake the underlying to receive LM rewards. In that case, handleRepayment() would perform the staking of the underlying asset.

#### Input Parameters:

[](#write-methods-handlerepayment-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| user | address | The user executing the repayment |  |
| onBehalfOf | address\` | The address for which the borrow position is repaid |  |
| amount | uint256 | The amount getting repaid |  |

### permit

[](#write-methods-permit)

    function permit(    address owner,    address spender,    uint256 value,    uint256 deadline,    uint8 v,    bytes32 r,    bytes32 s) external override

Allows a user to permit another account (or contract) to use their funds using a signed message. This enables gas-less transactions and single approval/transfer transactions. Allow passing a signed message to approve spending.

Implements the permit function as for EIP-2612.

#### Input Parameters:

[](#write-methods-permit-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| owner | address | The owner of the funds |  |
| spender | address | The spender of the funds |  |
| value | uint256 | The amount the spender is permitted to spend |  |
| deadline | uint256 | The deadline timestamp, use type(uint256).max for max/no deadline |  |
| v | uint8 | The V signature parameter |  |
| r | bytes32 | The R signature parameter |  |
| s | bytes32 | The S signature parameter |  |

Example of signing and utilizing permit:

    import { signTypedData_v4 } from "eth-sig-util";import { fromRpcSig } from "ethereumjs-util";// ... other importsimport aTokenAbi from "./aTokenAbi.json";// ... setup your web3 providerconst aTokenAddress = "ATOKEN_ADDRESS";const aTokenContract = new web3.eth.Contract(aTokenAbi, aTokenAddress);const privateKey = "YOUR_PRIVATE_KEY_WITHOUT_0x";const chainId = 1;const owner = "OWNER_ADDRESS";const spender = "SPENDER_ADDRESS";const value = 100; // Amount the spender is permittedconst nonce = 1; // The next valid nonce, use `_nonces()`const deadline = 1600093162;const permitParams = {  types: {    EIP712Domain: [      { name: "name", type: "string" },      { name: "version", type: "string" },      { name: "chainId", type: "uint256" },      { name: "verifyingContract", type: "address" },    ],    Permit: [      { name: "owner", type: "address" },      { name: "spender", type: "address" },      { name: "value", type: "uint256" },      { name: "nonce", type: "uint256" },      { name: "deadline", type: "uint256" },    ],  },  primaryType: "Permit",  domain: {    name: "aTOKEN_NAME",    version: "1",    chainId: chainId,    verifyingContract: aTokenAddress,  },  message: {    owner,    spender,    value,    nonce,    deadline,  },};const signature = signTypedData_v4(Buffer.from(privateKey, "hex"), {  data: permitParams,});// The signature can now be used to execute the transactionconst { v, r, s } = fromRpcSig(signature);await aTokenContract.methods  .permit({    owner,    spender,    value,    deadline,    v,    r,    s,  })  .send()  .catch((e) => {    throw Error(`Error permitting: ${e.message}`);  });

### rescueTokens

[](#write-methods-rescuetokens)

    function rescueTokens(    address token,    address to,    uint256 amount) external override onlyPoolAdmin

Rescue and transfer tokens locked in this contract. Only callable by [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#roles-pool-admin).

#### Input Parameters:

[](#write-methods-rescuetokens-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| token | address | The address of the token |  |
| to | address | The address of the recipient |  |
| amount | uint256 | The amount of token to transfer |  |

View Methods
------------

[](#view-methods)

### balanceOf

[](#view-methods-balanceof)

    function balanceOf(address user)    public    view    virtual    override(IncentivizedERC20, IERC20)    returns (uint256)

Returns the amount of tokens owned by user.

Overrides the base function.

#### Input Parameters:

[](#view-methods-balanceof-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| user | address | The address of the user |  |

#### Return Values:

[](#view-methods-balanceof-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The amount of tokens owned by user |  |

### totalSupply

[](#view-methods-totalsupply)

    function totalSupply() public view virtual override(IncentivizedERC20, IERC20 returns (uint256)

Returns the amount of tokens in existence.

Overrides the base function.

#### Return Values:

[](#view-methods-totalsupply-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The amount of tokens in existence |  |

### RESERVE\_TREASURY\_ADDRESS

[](#view-methods-reserve-treasury-address)

    function RESERVE_TREASURY_ADDRESS() external view override returns (address)

Returns the address of the Aave treasury, controlled by governance, receiving the fees on this aToken.

#### Return Values:

[](#view-methods-reserve-treasury-address-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the Aave treasury |  |

### UNDERLYING\_ASSET\_ADDRESS

[](#view-methods-underlying-asset-address)

    function UNDERLYING_ASSET_ADDRESS() external view override returns (address)

Returns the address of the underlying reserve asset of this aToken (E.g. WETH for aWETH).

#### Return Values:

[](#view-methods-underlying-asset-address-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the underlying asset |  |

### DOMAIN\_SEPARATOR

[](#view-methods-domain-separator)

    function DOMAIN_SEPARATOR() public view override(IAToken, EIP712Base) returns (bytes32)

Get the domain separator for the token at the current chain.

Return cached value if chainId matches cache, otherwise recomputes separator.

Overrides the base function to fully implement IAToken.

#### Return Values:

[](#view-methods-domain-separator-return-values)

| Type | Description |  |
| --- | --- | --- |
| bytes32 | The domain separator of the token at current chain |  |

### nonces

[](#view-methods-nonces)

    function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256)

Returns the nonce value for address specified as parameter. This is the nonce used when calling permit().

Overrides the base function to fully implement IAToken.

#### Input Parameters:

[](#view-methods-nonces-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| owner | address | The address of the owner |  |

#### Return Values:

[](#view-methods-nonces-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The nonce of the owner |  |

Example:

    const token = new Contract(aTokenAddress, aToken.abi, provider);await token.nonces(user);

Pure Methods
------------

[](#pure-methods)

### getRevision

[](#pure-methods-getrevision)

    function getRevision() internal pure virtual override returns (uint256)

Returns the revision number of the contract. Needs to be defined in the inherited class as a constant.

Returns 0x1.

#### Return Values:

[](#pure-methods-getrevision-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The revision number |  |

StaticATokenFactory
-------------------

[](#staticatokenfactory)

The StataTokenFactory is a factory and registry contract that manages all deployed StataToken instances for a specified Aave pool. It allows deploying new StataToken instances on demand and validates that there is only one StataToken instance per underlying asset. This contract maintains a mapping between underlying assets and their corresponding StataToken addresses.

StataTokens are ERC-4626 compliant tokens that wrap Aave's aTokens to provide a non-rebasing yield accrual mechanism.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/tokenization/StataTokenFactory.sol).

Write Methods
-------------

[](#write-methods)

### initialize

[](#write-methods-initialize)

    function initialize() external initializer

Initializes the StataTokenFactory contract. This function is part of the Initializable pattern and is required to initialize the contract after deployment. In this implementation, it does not perform any actions.

### createStataTokens

[](#write-methods-createstatatokens)

    function createStataTokens(address[] memory underlyings) external returns (address[] memory)

Creates new StataToken instances for the given underlying assets if they do not already exist. For each provided underlying asset, the function checks if a StataToken already exists. If it does, the existing StataToken address is returned. If not, it deploys a new StataToken for that underlying asset, registers it, and returns the new address.

#### Input Parameters:

[](#write-methods-createstatatokens-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| underlyings | address\[\] | An array of underlying asset addresses |  |

#### Return Values:

[](#write-methods-createstatatokens-return-values)

| Type | Description |  |
| --- | --- | --- |
| address\[\] | An array of StataToken addresses corresponding to the provided underlying assets |  |

#### Emits:

[](#write-methods-createstatatokens-emits)

*   StataTokenCreated(address indexed stataToken, address indexed underlying) event for each new StataToken created.
    

#### Reverts:

[](#write-methods-createstatatokens-reverts)

*   NotListedUnderlying(address underlying) if the underlying asset is not listed in the Aave pool.
    

View Methods
------------

[](#view-methods)

### getStataTokens

[](#view-methods-getstatatokens)

    function getStataTokens() external view returns (address[] memory)

Returns all StataToken instances deployed via this factory.

#### Return Values:

[](#view-methods-getstatatokens-return-values)

| Type | Description |  |
| --- | --- | --- |
| address\[\] | An array of all StataToken contract addresses |  |

### getStataToken

[](#view-methods-getstatatoken)

    function getStataToken(address underlying) external view returns (address)

Returns the StataToken address for a given underlying asset.

#### Input Parameters:

[](#view-methods-getstatatoken-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| underlying | address | The address of the underlying asset |  |

#### Return Values:

[](#view-methods-getstatatoken-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the corresponding StataToken; returns address(0) if not found |  |

### POOL

[](#view-methods-pool)

    function POOL() external view returns (IPool)

Returns the address of the Aave pool associated with this factory.

#### Return Values:

[](#view-methods-pool-return-values)

| Type | Description |  |
| --- | --- | --- |
| IPool | The address of the associated Aave pool |  |

### PROXY\_ADMIN

[](#view-methods-proxy-admin)

    function PROXY_ADMIN() external view returns (address)

Returns the address of the proxy admin used for the StataToken proxies.

#### Return Values:

[](#view-methods-proxy-admin-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the proxy admin |  |

### TRANSPARENT\_PROXY\_FACTORY

[](#view-methods-transparent-proxy-factory)

    function TRANSPARENT_PROXY_FACTORY() external view returns (ITransparentProxyFactory)

Returns the address of the transparent proxy factory used for creating new StataToken proxies.

#### Return Values:

[](#view-methods-transparent-proxy-factory-return-values)

| Type | Description |  |
| --- | --- | --- |
| ITransparentProxyFactory | The address of the transparent proxy factory |  |

### STATA\_TOKEN\_IMPL

[](#view-methods-stata-token-impl)

    function STATA_TOKEN_IMPL() external view returns (address)

Returns the address of the StataToken implementation used when deploying new StataToken instances.

#### Return Values:

[](#view-methods-stata-token-impl-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the StataToken implementation |  |

VariableDebtToken
-----------------

[](#variabledebttoken)

Implements a variable debt token to track the borrowing positions of users at variable rate mode.

transfer and approve functionalities are disabled as variable debt tokens are non-transferable.

The vToken value is pegged 1:1 to the value of underlying borrowed asset and represents the current total amount owed to the protocol i.e. principal debt + interest accrued.

The VariableDebtToken contract inherits the [DebtTokenBase](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/tokenization/base/DebtTokenBase.sol) and [ScaledBalanceTokenBase](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/tokenization/base/ScaledBalanceTokenBase.sol) token contracts.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/tokenization/VariableDebtToken.sol).

Write Methods
-------------

[](#write-methods)

### initialize

[](#write-methods-initialize)

    function initialize(    IPool initializingPool,    address underlyingAsset,    IAaveIncentivesController incentivesController,    uint8 debtTokenDecimals,    string memory debtTokenName,    string memory debtTokenSymbol,    bytes calldata params) external virtual

Called when variableDebtToken instance is initialised.

#### Input Parameters:

[](#write-methods-initialize-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| initializingPool | IPool | The pool contract that is initializing this contract |  |
| underlyingAsset | address | The address of the underlying asset of this aToken (E.g. WETH for aWETH) |  |
| incentivesController | IAaveIncentivesController | The smart contract managing potential incentives distribution |  |
| debtTokenDecimals | uint8 | The decimals of the variableDebtToken, same as the underlying asset's |  |
| debtTokenName | string | The name of the variable debt token |  |
| debtTokenSymbol | string | The symbol of the variable debt token |  |
| params | bytes | A set of encoded parameters for additional initialization |  |

### mint

[](#write-methods-mint)

    function mint(    address user,    address onBehalfOf,    uint256 amount,    uint256 index) external virtual override onlyPool returns (bool, uint256)

Mints the variable debt token to the onBehalfOf address.

#### Input Parameters:

[](#write-methods-mint-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| user | address | The address receiving the borrowed underlying, being the delegatee in case of credit delegate, or same as onBehalfOf otherwise |  |
| onBehalfOf | address | The address receiving the variable debt tokens |  |
| amount | uint256 | The amount of variable debt tokens to mint |  |
| index | uint256 | The variable debt index of the reserve |  |

#### Return Values:

[](#write-methods-mint-return-values)

| Type | Description |  |
| --- | --- | --- |
| bool | true if the previous balance of the user is 0, false otherwise |  |
| uint256 | The scaled total debt of the reserve |  |

### burn

[](#write-methods-burn)

    function burn(    address from,    uint256 amount,    uint256 index) external virtual override onlyPool returns (uint256)

Burns user variable debt.

In some instances, a burn transaction will emit a mint event if the amount to burn is less than the interest that the user accrued.

#### Input Parameters:

[](#write-methods-burn-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| from | address | The address from which the debt will be burned |  |
| amount | uint256 | The amount of debt tokens that will be burned |  |
| index | uint256 | The variable debt index of the reserve |  |

#### Return Values:

[](#write-methods-burn-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The scaled total debt of the reserve |  |

View Methods
------------

[](#view-methods)

### UNDERLYING\_ASSET\_ADDRESS

[](#view-methods-underlying-asset-address)

    function UNDERLYING_ASSET_ADDRESS() external view override returns (address)

Returns the address of the underlying asset of this variableDebtToken (e.g. WETH for variableDebtWETH)

#### Return Values:

[](#view-methods-underlying-asset-address-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the underlying asset |  |

### balanceOf

[](#view-methods-balanceof)

    function balanceOf(address account) public view virtual override returns (uint256)

Returns the amount of tokens owned by account - the most up to date accumulated debt (principal + interest) of the user.

Standard ERC20 function.

#### Input Parameters:

[](#view-methods-balanceof-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| account | address | The balance of this address |  |

#### Return Values:

[](#view-methods-balanceof-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The amount of tokens owned by account |  |

### totalSupply

[](#view-methods-totalsupply)

    function totalSupply() public view virtual override returns (uint256)

Returns the amount of tokens in existence - the most up to date total debt accrued by all protocol users for that specific variable rate of debt token.

Standard ERC20 function.

#### Return Values:

[](#view-methods-totalsupply-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The amount of tokens in existence |  |

Pure Methods
------------

[](#pure-methods)

### getRevision

[](#pure-methods-getrevision)

    function getRevision() internal pure virtual override returns (uint256)

Returns the revision number of the contract. Needs to be defined in the inherited class as a constant.

Returns 0x1.

#### Return Values:

[](#pure-methods-getrevision-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The revision number |  |

NOT SUPPORTED OPERATIONS
------------------------

[](#not-supported-operations)

Being non-transferrable, the variable debt token does not implement any of the standard ERC20 functions for transfer and allowance.

The following functions below will revert with the error code 80, OPERATION\_NOT\_SUPPORTED: transfer, allowance, approve, transferFrom, increaseAllowance, decreaseAllowance.</content>
</page>

<page>
  <title>Interest Rate Strategy</title>
  <url>https://aave.com/docs/developers/smart-contracts/interest-rate-strategy</url>
  <content>[](#interest-rate-strategy)

Borrow / WithdrawSupply / RepayBorrow rateSupply rate

Implements the calculation of the interest rates depending on the reserve state. The model of interest rate is based on two slopes, one before the OPTIMAL\_USAGE\_RATIO point of usage and another from that point to 100%.

An instance of this same contract can't be used across different Aave markets due to the caching of the [PoolAddressesProvider](https://aave.com/docs/developers/smart-contracts/pool-addresses-provider).

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/misc/DefaultReserveInterestRateStrategyV2.sol).

View Methods
------------

[](#view-methods)

### getVariableRateSlope1

[](#view-methods-getvariablerateslope1)

    function getVariableRateSlope1(address reserve) external view returns (uint256)

Returns the variable rate slope below the optimal usage ratio for the specified reserve. This is the variable rate when the usage ratio is between 0 and OPTIMAL\_USAGE\_RATIO.

#### Input Parameters:

[](#view-methods-getvariablerateslope1-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| reserve | address | The address of the reserve |  |

#### Return Values:

[](#view-methods-getvariablerateslope1-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The variable rate slope |  |

### getVariableRateSlope2

[](#view-methods-getvariablerateslope2)

    function getVariableRateSlope2(address reserve) external view returns (uint256)

Returns the variable rate slope above the optimal usage ratio for the specified reserve. This is the variable rate when the usage ratio is greater than OPTIMAL\_USAGE\_RATIO.

#### Input Parameters:

[](#view-methods-getvariablerateslope2-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| reserve | address | The address of the reserve |  |

#### Return Values:

[](#view-methods-getvariablerateslope2-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The variable rate slope |  |

### getBaseVariableBorrowRate

[](#view-methods-getbasevariableborrowrate)

    function getBaseVariableBorrowRate(address reserve) external view override returns (uint256)

Returns the base variable borrow rate for the specified reserve.

#### Input Parameters:

[](#view-methods-getbasevariableborrowrate-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| reserve | address | The address of the reserve |  |

#### Return Values:

[](#view-methods-getbasevariableborrowrate-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The base variable borrow rate, expressed in ray |  |

### getMaxVariableBorrowRate

[](#view-methods-getmaxvariableborrowrate)

    function getMaxVariableBorrowRate(address reserve) external view override returns (uint256)

Returns the maximum variable borrow rate for the specified reserve.

#### Input Parameters:

[](#view-methods-getmaxvariableborrowrate-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| reserve | address | The address of the reserve |  |

#### Return Values:

[](#view-methods-getmaxvariableborrowrate-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The maximum variable borrow rate, expressed in ray |  |

### calculateInterestRates

[](#view-methods-calculateinterestrates)

    function calculateInterestRates(    DataTypes.CalculateInterestRatesParams memory params) external view override returns (uint256, uint256)

Calculates the interest rates depending on the reserve's state and configurations. This function returns only two values: the liquidity rate and the variable borrow rate.

#### Input Parameters:

[](#view-methods-calculateinterestrates-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| params | DataTypes.CalculateInterestRatesParams | The parameters needed to calculate interest rates |  |

The DataTypes.CalculateInterestRatesParams struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| unbacked | uint256 | The amount of unbacked tokens |  |
| liquidityAdded | uint256 | The liquidity added during the operation |  |
| liquidityTaken | uint256 | The liquidity taken during the operation |  |
| totalDebt | uint256 | The total borrowed from the reserve |  |
| reserveFactor | uint256 | The reserve portion of the interest that goes to the treasury of the market |  |
| reserve | address | The address of the reserve |  |
| usingVirtualBalance | bool | Flag to indicate if the virtual balance is being used |  |
| virtualUnderlyingBalance | uint256 | The virtual balance of underlying asset used for mintable assets |  |

#### Return Values:

[](#view-methods-calculateinterestrates-return-values)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| liquidityRate | uint256 | The liquidity rate, expressed in ray |  |
| variableBorrowRate | uint256 | The variable borrow rate, expressed in ray |  |</content>
</page>

<page>
  <title>ACL Manager</title>
  <url>https://aave.com/docs/developers/smart-contracts/acl-manager</url>
  <content>ACLManager
----------

[](#aclmanager)

The Access Control List Manager (ACLManager) is the main registry of system roles and permissions.

The Aave Protocol implements an access control list to segregate powers and/or benefits that can be allocated to different entities on the protocol. The ACL\_MANAGER contract is managed by the [PoolAddressesProvider](https://aave.com/docs/developers/smart-contracts/pool-addresses-provider) contract.

ACLManager keeps track of the individual roles and its holders, and allows a _Role Admin_ to manage roles. _Role Admin_ is itself a role that is managed by the DEFAULT\_ADMIN\_ROLE.

The DEFAULT\_ADMIN\_ROLE is held by the [ACL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#acl_admin), and should be initialized in the [PoolAddressesProvider](https://aave.com/docs/developers/smart-contracts/poola-ddresses-provider) beforehand.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/configuration/ACLManager.sol).

Roles
-----

[](#roles)

Below we outline the responsibilities/powers of the roles and the specific methods that are only accessible to the holders of these roles.

The [FLASH\_BORROWER](https://aave.com/docs/developers/smart-contracts/acl-manager#flash_borrower) and [BRIDGE](https://aave.com/docs/developers/smart-contracts/acl-manager#bridge) roles have few direct responsibilities and can primarily access specific features of the protocol, while ADMIN roles have the power and responsibility to handle risk or configuration parameters.

### FLASH\_BORROWER

[](#roles-flash-borrower)

Holders of this role will have the premium on flash loans waived (this does not include the simple flash loan).

#### Methods Accessible:

[](#roles-flash-borrower-methods-accessible)

**[Pool](https://aave.com/docs/developers/smart-contracts/pool)**:

*   [flashLoan()](https://aave.com/docs/developers/smart-contracts/pool#flashloan)
    

### BRIDGE

[](#roles-bridge)

Holders can leverage the [Portals](https://aave.com/docs/developers/aave-v3#features-portals) feature.

#### Methods Accessible:

[](#roles-bridge-methods-accessible)

**[Pool](https://aave.com/docs/developers/pool)**:

*   [mintUnbacked()](https://aave.com/docs/developers/smart-contracts/pool#mintunbacked)
    
*   [backUnbacked()](https://aave.com/docs/developers/smart-contracts/pool#backunbacked)
    

### ASSET\_LISTING\_ADMIN

[](#roles-asset-listing-admin)

Holders of this role can:

*   Update asset oracle sources and the fallback oracle.
    
*   Add new assets to the Aave market.
    

#### Methods Accessible:

[](#roles-asset-listing-admin-methods-accessible)

**[AaveOracle](https://aave.com/docs/developers/smart-contracts/oracles)**:

*   [setAssetSources()](https://aave.com/docs/developers/smart-contracts/oracles#write-methods-setassetsources)
    
*   [setFallbackOracle()](https://aave.com/docs/developers/smart-contracts/oracles#write-methods-setfallbackoracle)
    

**[PoolConfigurator](https://aave.com/docs/developers/smart-contracts/pool-configurator)**:

*   [initReserves()](https://aave.com/docs/developers/smart-contracts/pool-configurator#initreserves)
    

### RISK\_ADMIN

[](#roles-risk-admin)

Holders of this role can:

*   Update the grace period of Oracle Sentinels.
    
*   Update reserve parameters such as reserve factor, caps, E-Mode category, borrowing enabled, freeze/unfreeze, LTV, liquidation threshold, liquidation bonus (cannot pause/unpause or activate/deactivate a reserve).
    
*   Create new and update existing E-Mode categories (not category 0).
    
*   Update unbacked mint cap and liquidation protocol fee.
    

#### Methods Accessible:

[](#roles-risk-admin-methods-accessible)

**[PoolConfigurator](https://aave.com/docs/developers/smart-contracts/pool-configurator)**:

*   [setReserveBorrowing()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setreserveborrowing)
    
*   [configureReserveAsCollateral()](https://aave.com/docs/developers/smart-contracts/pool-configurator#configurereserveascollateral)
    
*   [setReserveFreeze()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setreservefreeze)
    
*   [setBorrowableInIsolation()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setborrowableinisolation)
    
*   [setReserveFactor()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setreservefactor)
    
*   [setDebtCeiling()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setdebtceiling)
    
*   [setSiloedBorrowing()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setsiloedborrowing)
    
*   [setBorrowCap()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setborrowcap)
    
*   [setSupplyCap()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setsupplycap)
    
*   [setLiquidationProtocolFee()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setliquidationprotocolfee)
    
*   [setEModeCategory()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setemodecategory)
    
*   [setAssetCollateralInEMode()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setassetcollateralinemode)
    
*   [setUnbackedMintCap()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setunbackedmintcap)
    
*   [setReserveInterestRateStrategyAddress()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setreserveinterestratestrategyaddress)
    
*   [setReserveInterestRateData()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setreserveinterestratedata)
    
*   [disableLiquidationGracePeriod()](https://aave.com/docs/developers/smart-contracts/pool-configurator#disableliquidationgraceperiod)
    
*   [setReserveFlashLoaning()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setreserveflashloaning)
    

**[PriceOracleSentinel](https://aave.com/docs/developers/smart-contracts/oracles)**:

*   setGracePeriod()
    

### ACL\_ADMIN

[](#roles-acl-admin)

Holders of this role manage the role admins in the ACLManager. The DEFAULT\_ADMIN\_ROLE is held by the ACL\_ADMIN, and should be initialized in the PoolAddressesProvider beforehand.

#### Methods Accessible:

[](#roles-acl-admin-methods-accessible)

**[ACLManager](https://aave.com/docs/developers/smart-contracts/acl-manager)**:

*   [setRoleAdmin()](https://aave.com/docs/developers/smart-contracts/acl-manager#setroleadmin)
    
*   [addPoolAdmin()](https://aave.com/docs/developers/smart-contracts/acl-manager#addpooladmin)
    
*   [removePoolAdmin()](https://aave.com/docs/developers/smart-contracts/acl-manager#removepooladmin)
    
*   [addEmergencyAdmin()](https://aave.com/docs/developers/smart-contracts/acl-manager#addemergencyadmin)
    
*   [removeEmergencyAdmin()](https://aave.com/docs/developers/smart-contracts/acl-manager#removeemergencyadmin)
    
*   [addRiskAdmin()](https://aave.com/docs/developers/smart-contracts/acl-manager#addriskadmin)
    
*   [removeRiskAdmin()](https://aave.com/docs/developers/smart-contracts/acl-manager#removeriskadmin)
    
*   [addFlashBorrower()](https://aave.com/docs/developers/smart-contracts/acl-manager#addflashborrower)
    
*   [removeFlashBorrower()](https://aave.com/docs/developers/smart-contracts/acl-manager#removeflashborrower)
    
*   [addBridge()](https://aave.com/docs/developers/smart-contracts/acl-manager#addbridge)
    
*   [removeBridge()](https://aave.com/docs/developers/smart-contracts/acl-manager#removebridge)
    
*   [addAssetListingAdmin()](https://aave.com/docs/developers/smart-contracts/acl-manager#addassetlistingadmin)
    
*   [removeAssetListingAdmin()](https://aave.com/docs/developers/smart-contracts/acl-manager#removeassetlistingadmin)
    

### EMERGENCY\_ADMIN

[](#roles-emergency-admin)

Holders of this role can pause and unpause the pool or an individual reserve.

#### Methods Accessible:

[](#roles-emergency-admin-methods-accessible)

**[PoolConfigurator](https://aave.com/docs/developers/smart-contracts/pool-configurator)**:

*   [setReservePause()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setreservepause)
    
*   [setPoolPause()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setpoolpause)
    
*   [setReserveActive()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setreserveactive)
    
*   [setReserveFreeze()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setreservefreeze)
    

### POOL\_ADMIN

[](#roles-pool-admin)

Holders of this role can update token implementations, drop, (un)pause and (de)activate reserves, update premiums along with everything the [ASSET\_LISTING\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#asset_listing_admin) and [RISK\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#risk_admin) can do.

All deployers have resigned their [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#pool_admin) roles. All instances of the [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#pool_admin) role, across all V3 networks, are now governed by the \[Guardians multisig\] or by the [Governance Bridge executors](https://github.com/aave/governance-crosschain-bridges).

#### Methods Accessible:

[](#roles-pool-admin-methods-accessible)

All methods accessible to ASSET\_LISTING\_ADMIN.

All methods accessible to RISK\_ADMIN.

**[AToken](https://aave.com/docs/developers/smart-contracts/tokenization)**:

*   [rescueTokens()](https://aave.com/docs/developers/smart-contracts/tokenization)
    

**[Pool](https://aave.com/docs/developers/smart-contracts/pool)**:

*   [rescueTokens()](https://aave.com/docs/developers/smart-contracts/pool#rescuetokens)
    

**[IncentivizedERC20](https://aave.com/docs/developers/smart-contracts/tokenization)**:

*   [setIncentivesController()](https://aave.com/docs/developers/smart-contracts/tokenization)
    

**[PoolConfigurator](https://aave.com/docs/developers/smart-contracts/pool-configurator)**:

*   [dropReserve()](https://aave.com/docs/developers/smart-contracts/pool-configurator#dropreserve)
    
*   [updateAToken()](https://aave.com/docs/developers/smart-contracts/pool-configurator#updateatoken)
    
*   [updateVariableDebtToken()](https://aave.com/docs/developers/smart-contracts/pool-configurator#updatevariabledebttoken)
    
*   [setReserveActive()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setreserveactive)
    
*   [updateBridgeProtocolFee()](https://aave.com/docs/developers/smart-contracts/pool-configurator#updatebridgeprotocolfee)
    
*   [updateFlashloanPremiumTotal()](https://aave.com/docs/developers/smart-contracts/pool-configurator#updateflashloanpremiumtotal)
    
*   [updateFlashloanPremiumToProtocol()](https://aave.com/docs/developers/smart-contracts/pool-configurator#updateflashloanpremiumtoprotocol)
    
*   [setAssetBorrowableInEMode()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setassetborrowableinemode)
    
*   [setReserveInterestRateData()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setreserveinterestratedata)
    
*   [setReserveInterestRateStrategyAddress()](https://aave.com/docs/developers/smart-contracts/pool-configurator#setreserveinterestratestrategyaddress)
    

**[PriceOracleSentinel](https://aave.com/docs/developers/smart-contracts/oracles)**:

*   [setSequencerOracle()](https://aave.com/docs/developers/smart-contracts/oracles#write-methods-setsequenceroracle)
    

Write Methods
-------------

[](#write-methods)

### setRoleAdmin

[](#write-methods-setroleadmin)

    function setRoleAdmin(bytes32 role, bytes32 adminRole) external override onlyRole(DEFAULT_ADMIN_ROLE)

Sets the role as admin of a specific role. By default, the adminRole for all roles is [DEFAULT\_ADMIN\_ROLE](https://aave.com/docs/developers/smart-contracts/acl-manager#acl_admin).

#### Input Parameters:

[](#write-methods-setroleadmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| role | bytes32 | The role to be managed by the admin role - keccak256 hash of one of the following: POOL\_ADMIN, EMERGENCY\_ADMIN, RISK\_ADMIN, FLASH\_BORROWER, BRIDGE, ASSET\_LISTING\_ADMIN |  |
| adminRole | bytes32 | The admin role. 0x00 is reserved for the DEFAULT\_ADMIN\_ROLE |  |

### addPoolAdmin

[](#write-methods-addpooladmin)

    function addPoolAdmin(address admin) external override

Adds a new admin as _Pool Admin_. The address is added to the list of members with the [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#pool_admin) role. Holders of this role can update token implementations, drop, (un)pause and (de)activate reserves, update premiums and do everything the [ASSET\_LISTING\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#asset_listing_admin) and [RISK\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#risk_admin) can do.

This method can only be called by the _Role Admin_, specified by _Aave Governance_, responsible for managing the [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#pool_admin) role.

#### Input Parameters:

[](#write-methods-addpooladmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| admin | address | The address which will be granted the POOL\_ADMIN role |  |

### removePoolAdmin

[](#write-methods-removepooladmin)

    function removePoolAdmin(address admin) external override

Removes an admin as _Pool Admin_. The given address is removed from the list of members with the [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#pool_admin) role.

This method can only be called by the _Role Admin_, specified by _Aave Governance_, responsible for managing the [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#pool_admin) role.

#### Input Parameters:

[](#write-methods-removepooladmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| admin | address | The address for which the POOL\_ADMIN role permissions will be removed |  |

### addEmergencyAdmin

[](#write-methods-addemergencyadmin)

    function addEmergencyAdmin(address admin) external override

Adds a new admin as an _Emergency Admin_. The address is added to the list of members with the [EMERGENCY\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#emergency_admin) role. Holders of this role can pause and unpause the pool or an individual reserve.

This method can only be called by the _Role Admin_, specified by _Aave Governance_, responsible for managing the [EMERGENCY\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#emergency_admin) role.

#### Input Parameters:

[](#write-methods-addemergencyadmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| admin | address | The address which will be granted the EMERGENCY\_ADMIN role |  |

### removeEmergencyAdmin

[](#write-methods-removeemergencyadmin)

    function removeEmergencyAdmin(address admin) external override

Removes an admin as _Emergency Admin_. The given address is removed from the list of members with the [EMERGENCY\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#emergency_admin) role.

This method can only be called by the _Role Admin_, specified by _Aave Governance_, responsible for managing the [EMERGENCY\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#emergency_admin) role.

#### Input Parameters:

[](#write-methods-removeemergencyadmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| admin | address | The address for which the EMERGENCY\_ADMIN role permissions will be removed |  |

### addRiskAdmin

[](#write-methods-addriskadmin)

    function addRiskAdmin(address admin) external override

Adds a new admin as a _Risk Admin_. The address is added to the list of members with the [RISK\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#risk_admin) role. Holders of this role can update grace period of Oracle Sentinels, reserve params, unbacked mint cap, liquidation fee and eMode categories.

#### Input Parameters:

[](#write-methods-addriskadmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| admin | address | The address which will be granted the RISK\_ADMIN role |  |

### removeRiskAdmin

[](#write-methods-removeriskadmin)

    function removeRiskAdmin(address admin) external override

Removes an admin as _Risk Admin_. The given address is removed from the list of members with the [RISK\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#risk_admin) role.

#### Input Parameters:

[](#write-methods-removeriskadmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| admin | address | The address for which the RISK\_ADMIN role permissions will be removed |  |

### addFlashBorrower

[](#write-methods-addflashborrower)

    function addFlashBorrower(address borrower) external override

Adds a new borrower address as _Flash Borrower_. The address is added to the list of members with the [FLASH\_BORROWER](https://aave.com/docs/developers/smart-contracts/acl-manager#flash_borrower) role. Holders of this role do not pay premium for flash loan (does not apply to flashLoanSimple).

#### Input Parameters:

[](#write-methods-addflashborrower-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| borrower | address | The address which will be granted the FLASH\_BORROWER role |  |

### removeFlashBorrower

[](#write-methods-removeflashborrower)

    function removeFlashBorrower(address borrower) external override

Removes an admin as _Flash Borrower_. The given borrower address is removed from the list of members with the [FLASH\_BORROWER](https://aave.com/docs/developers/smart-contracts/acl-manager#flash_borrower) role.

#### Input Parameters:

[](#write-methods-removeflashborrower-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| borrower | address | The address for which the FLASH\_BORROWER role permissions will be removed |  |

### addBridge

[](#write-methods-addbridge)

    function addBridge(address bridge) external override

Adds a new address as [BRIDGE](https://aave.com/docs/developers/smart-contracts/acl-manager#bridge). The contract address is added to the list of _bridges_. Holders of this role can leverage the [Portals](https://aave.com/docs/whats_new/portals) feature to seamlessly move supplied assets across Aave V3 markets on different networks.

This method can only be called by the _Role Admin_, specified by _Aave Governance_, responsible for managing the [BRIDGE](https://aave.com/docs/developers/smart-contracts/acl-manager#bridge) role.

#### Input Parameters:

[](#write-methods-addbridge-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| bridge | address | The address which will be granted BRIDGE role |  |

### removeBridge

[](#write-methods-removebridge)

    function removeBridge(address bridge) external override

Removes an address as [BRIDGE](https://aave.com/docs/developers/smart-contracts/acl-manager#bridge). The given contract address is removed from the list of _bridges_.

This method can only be called by the _Role Admin_, specified by _Aave Governance_, responsible for managing [BRIDGE](https://aave.com/docs/developers/smart-contracts/acl-manager#bridge) role.

#### Input Parameters:

[](#write-methods-removebridge-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| bridge | address | The address for which BRIDGE role permissions will be removed |  |

### addAssetListingAdmin

[](#write-methods-addassetlistingadmin)

    function addAssetListingAdmin(address admin) external override

Adds a new admin as _Asset Listing Admin_. The address is added to the list of members with the [ASSET\_LISTING\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#asset_listing_admin) role. Holder of this role can update oracles and add new assets to the Aave market.

#### Input Parameters:

[](#write-methods-addassetlistingadmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| admin | address | The address which will be granted ASSET\_LISTING\_ADMIN role |  |

### removeAssetListingAdmin

[](#write-methods-removeassetlistingadmin)

    function removeAssetListingAdmin(address admin) external override

Removes an admin as _Asset Listing Admin_. The given address is removed from the list of members with the [ASSET\_LISTING\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#asset_listing_admin) role.

#### Input Parameters:

[](#write-methods-removeassetlistingadmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| admin | address | The address for which ASSET\_LISTING\_ADMIN role permissions will be removed |  |

View Methods
------------

[](#view-methods)

### isPoolAdmin

[](#view-methods-ispooladmin)

    function isPoolAdmin(address admin) external view override returns (bool)

Returns true if the address has the [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#pool_admin) role, false otherwise.

#### Input Parameters:

[](#view-methods-ispooladmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| admin | address | The address to check |  |

#### Return Values:

[](#view-methods-ispooladmin-return-values)

| Type | Description |  |
| --- | --- | --- |
| bool | true if the given address is POOL\_ADMIN, false otherwise |  |

### isEmergencyAdmin

[](#view-methods-isemergencyadmin)

    function isEmergencyAdmin(address admin) external view override returns (bool)

Returns true if the address has the [EMERGENCY\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#emergency_admin) role, false otherwise.

#### Input Parameters:

[](#view-methods-isemergencyadmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| admin | address | The address to check |  |

#### Return Values:

[](#view-methods-isemergencyadmin-return-values)

| Type | Description |  |
| --- | --- | --- |
| bool | true if the given address is EMERGENCY\_ADMIN, false otherwise |  |

### isRiskAdmin

[](#view-methods-isriskadmin)

    function isRiskAdmin(address admin) external view override returns (bool)

Returns true if the address has the [RISK\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#risk_admin) role, false otherwise.

#### Input Parameters:

[](#view-methods-isriskadmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| admin | address | The address to check |  |

#### Return Values:

[](#view-methods-isriskadmin-return-values)

| Type | Description |  |
| --- | --- | --- |
| bool | true if the given address is RISK\_ADMIN, false otherwise |  |

### isFlashBorrower

[](#view-methods-isflashborrower)

    function isFlashBorrower(address borrower) external view override returns (bool)

Returns true if the address has the [FLASH\_BORROWER](https://aave.com/docs/developers/smart-contracts/acl-manager#flash_borrower) role, false otherwise.

#### Input Parameters:

[](#view-methods-isflashborrower-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| borrower | address | The address to check |  |

#### Return Values:

[](#view-methods-isflashborrower-return-values)

| Type | Description |  |
| --- | --- | --- |
| bool | true if the given address is FLASH\_BORROWER, false otherwise |  |

### isBridge

[](#view-methods-isbridge)

    function isBridge(address bridge) external view override returns (bool)

Returns true if the address has [BRIDGE](https://aave.com/docs/developers/smart-contracts/acl-manager#bridge) role, false otherwise.

#### Input Parameters:

[](#view-methods-isbridge-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| bridge | address | The address to check |  |

#### Return Values:

[](#view-methods-isbridge-return-values)

| Type | Description |  |
| --- | --- | --- |
| bool | true if the given address is BRIDGE, false otherwise |  |

### isAssetListingAdmin

[](#view-methods-isassetlistingadmin)

    function isAssetListingAdmin(address admin) external view override returns (bool)

Returns true if the address has the [ASSET\_LISTING\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#asset_listing_admin) role, false otherwise.

#### Input Parameters:

[](#view-methods-isassetlistingadmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| admin | address | The address to check |  |

#### Return Values:

[](#view-methods-isassetlistingadmin-return-values)

| Type | Description |  |
| --- | --- | --- |
| bool | true if the given address is ASSET\_LISTING\_ADMIN, false otherwise |  |</content>
</page>

<page>
  <title>Oracles</title>
  <url>https://aave.com/docs/developers/smart-contracts/oracles</url>
  <content>AaveOracle
----------

[](#aaveoracle)

Contract to get asset prices and manage price sources.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/misc/AaveOracle.sol).

This contract is owned by the Aave Governance.

Write Methods
-------------

[](#write-methods)

### setAssetSources

[](#write-methods-setassetsources)

    function setAssetSources(address[] calldata assets, address[] calldata sources) external override onlyAssetListingOrPoolAdmins

Sets the price sources for given list of assets.

This method can only be called by a POOL\_ADMIN or ASSET\_LISTING\_ADMIN. Please look at the [ACLManager](https://aave.com/docs/developers/smart-contracts/acl-manager) contract for further details on system roles.

#### Input Parameters:

[](#write-methods-setassetsources-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| assets | address\[\] | The addresses of the assets for which source is being set |  |
| sources | address\[\] | The address of the source of each asset. Length of assets and sources array should be same |  |

### setFallbackOracle

[](#write-methods-setfallbackoracle)

    function setFallbackOracle(address fallbackOracle) external override onlyAssetListingOrPoolAdmins

Sets/updates the fallbackOracle.

This method can only be called by a POOL\_ADMIN or ASSET\_LISTING\_ADMIN. Please look at the [ACLManager](https://aave.com/docs/developers/smart-contracts/acl-manager) contract for further details on system roles.

#### Input Parameters:

[](#write-methods-setfallbackoracle-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| fallbackOracle | address | The address of the fallback oracle |  |

View Methods
------------

[](#view-methods)

### getAssetPrice

[](#view-methods-getassetprice)

    function getAssetPrice(address asset) public view override returns (uint256)

Returns the price of the supported asset in [BASE\_CURRENCY](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/interfaces/IPriceOracleGetter.sol) of the Aave Market in wei.

#### Input Parameters:

[](#view-methods-getassetprice-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the asset |  |

#### Return Values:

[](#view-methods-getassetprice-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The price of the asset in BASE\_CURRENCY of the Aave market in wei |  |

### getAssetsPrices

[](#view-methods-getassetsprices)

    function getAssetsPrices(address[] calldata assets) external view override returns (uint256[] memory)

Returns a list of prices from a list of the supported assets addresses in [BASE\_CURRENCY](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/interfaces/IPriceOracleGetter.sol) of the Aave Market. All prices are in wei.

#### Input Parameters:

[](#view-methods-getassetsprices-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| assets | address\[\] | The list of assets addresses for which price is being queried |  |

#### Return Values:

[](#view-methods-getassetsprices-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256\[\] | The prices of the given assets in BASE\_CURRENCY of the Aave market in wei |  |

### getSourceOfAsset

[](#view-methods-getsourceofasset)

    function getSourceOfAsset(address asset) external view override returns (address)

Returns the address of the price source for an asset address.

#### Input Parameters:

[](#view-methods-getsourceofasset-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the asset |  |

#### Return Values:

[](#view-methods-getsourceofasset-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the source |  |

### getFallbackOracle

[](#view-methods-getfallbackoracle)

    function getFallbackOracle() external view returns (address)

Returns the address of the fallback oracle.

#### Return Values:

[](#view-methods-getfallbackoracle-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the fallback oracle |  |

PriceOracleSentinel
-------------------

[](#priceoraclesentinel)

The PriceOracleSentinel contract validates if the operations are allowed depending on the PriceOracle health.

This feature introduces a grace period for liquidations and disables borrowing under specific circumstances.

This feature has been specifically designed for L2s to handle eventual downtime of the sequencer (but can be extended to handle other cases, even on L1s, in the future).

Once the PriceOracle gets up after an outage or downtime, users can make their positions healthy during a grace period. The PriceOracle is considered healthy once its completely up and the grace period has passed.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/misc/PriceOracleSentinel.sol).

Write Methods
-------------

[](#write-methods)

### setSequencerOracle

[](#write-methods-setsequenceroracle)

    function setSequencerOracle(address newSequencerOracle) external onlyPoolAdmin

Updates the address of the sequencer oracle.

This method can only be called by PoolAdmin.

This method can only be called by the _Role Admin_, specified by _Aave Governance_, responsible for managing the [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/aclmanager#pool_admin) role.

#### Input Parameters:

[](#write-methods-setsequenceroracle-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| newSequencerOracle | address | The address of the new Sequencer Oracle to be set |  |

### setGracePeriod

[](#write-methods-setgraceperiod)

    function setGracePeriod(uint256 newGracePeriod) public onlyRiskOrPoolAdmins

Updates the duration of the grace period.

Can only be called by PoolAdmin or RiskAdmin.

#### Input Parameters:

[](#write-methods-setgraceperiod-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| newGracePeriod | uint256 | The duration of new grace period in seconds |  |

View Methods
------------

[](#view-methods)

### isBorrowAllowed

[](#view-methods-isborrowallowed)

    function isBorrowAllowed() external view override returns (bool)

Returns true if the borrow operation is allowed. The operation is not allowed when PriceOracle is down or the grace period has not passed.

#### Return Values:

[](#view-methods-isborrowallowed-return-values)

| Type | Description |  |
| --- | --- | --- |
| bool | Returns true if the borrow operation is allowed (the PriceOracle is up and grace period has passed), false otherwise |  |

### isLiquidationAllowed

[](#view-methods-isliquidationallowed)

    function isLiquidationAllowed() external view override returns (bool)

Returns true if the liquidation operation is allowed. The operation is not allowed when PriceOracle is down or the grace period has not passed.

#### Return Values:

[](#view-methods-isliquidationallowed-return-values)

| Type | Description |  |
| --- | --- | --- |
| bool | Returns true if the liquidation operation is allowed (the PriceOracle is up and grace period has passed), false otherwise |  |

### getSequencerOracle

[](#view-methods-getsequenceroracle)

    function getSequencerOracle() external view returns (address)

Returns the SequencerOracle.

#### Return Values:

[](#view-methods-getsequenceroracle-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the sequencer oracle contract |  |

### getGracePeriod

[](#view-methods-getgraceperiod)

    function getGracePeriod() external view returns (uint256)

Returns the grace period.

#### Return Values:

[](#view-methods-getgraceperiod-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The duration of the grace period in seconds |  |</content>
</page>

<page>
  <title>Pool Addresses Provider</title>
  <url>https://aave.com/docs/developers/smart-contracts/pool-addresses-provider</url>
  <content>PoolAddressesProvider
---------------------

[](#pooladdressesprovider)

The PoolAddressesProvider contract is the main registry of addresses that are part of, or connected to the Protocol, including permissioned roles. It acts as a factory of proxies and is the admin of those, and therefore has the right to change its implementations.

The addresses provider manages various protocol modules and has the ability to update pointers (e.g. update the [ACLManager](https://aave.com/docs/developers/smart-contracts/acl-manager) contract) or update the implementation of proxy contracts (e.g. update the [Pool](https://aave.com/docs/developers/smart-contracts/pool) implementation).

It specifies the initial holder of the [DEFAULT\_ADMIN\_ROLE](https://aave.com/docs/developers/smart-contracts/acl-manager), it is immutable, and the address will never change.

Whenever the [Pool](https://aave.com/docs/developers/smart-contracts/pool) contract is needed, we recommended you fetch the correct address from this PoolAddressesProvider smart contract.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/configuration/PoolAddressesProvider.sol).

Write Methods
-------------

[](#write-methods)

### setMarketId

[](#write-methods-setmarketid)

    function setMarketId(string memory newMarketId) external override onlyOwner

Updates the identifier of the Aave market by associating an id with a specific PoolAddressesProvider. This can be used to create an on-chain registry of pool addresses providers to identify and validate multiple Aave markets.

#### Input Parameters:

[](#write-methods-setmarketid-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| newMarketId | string | The new id of the market |  |

### setAddress

[](#write-methods-setaddress)

    function setAddress(bytes32 id, address newAddress) external override onlyOwner

Sets the address of the protocol contract stored at the given id, replacing the address saved in the addresses map.

For example, utils.keccak256(utils.toUtf8Bytes("INCENTIVES\_CONTROLLER")), is set to the address of INCENTIVES\_CONTROLLER.

Use this function carefully, as it will do a hard replacement of the current address in the addresses map.

#### Input Parameters:

[](#write-methods-setaddress-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| id | bytes32 | keccak256 hash of UTF8Bytes string representing contract |  |
| newAddress | address | The new address to be set corresponding to the id |  |

### setAddressAsProxy

[](#write-methods-setaddressasproxy)

    function setAddressAsProxy(bytes32 id, address newImplementationAddress) external override onlyOwner

Updates the implementation address of a proxy contract with a specified id.

If there is no proxy registered, it will instantiate one and set the implementation as the newImplementationAddress.

Use this function carefully, only for ids that do not have an explicit setter function in order to avoid unexpected consequences.

#### Input Parameters:

[](#write-methods-setaddressasproxy-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| id | bytes32 | The id of the proxy contract |  |
| newImplementationAddress | address | The address of new implementation contract corresponding to the proxy |  |

### setPoolImpl

[](#write-methods-setpoolimpl)

    function setPoolImpl(address newPoolImpl) external override onlyOwner

Updates the implementation of the [Pool](https://aave.com/docs/developers/smart-contracts/pool) contract, or creates a proxy.

#### Input Parameters:

[](#write-methods-setpoolimpl-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| newPoolImpl | address | The address of new Pool implementation contract |  |

### setPoolConfiguratorImpl

[](#write-methods-setpoolconfiguratorimpl)

    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external override onlyOwner

Updates the implementation of the [PoolConfigurator](https://aave.com/docs/developers/smart-contracts/pool-configurator) contract, or creates a proxy.

#### Input Parameters:

[](#write-methods-setpoolconfiguratorimpl-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| newPoolConfiguratorImpl | address | The address of new PoolConfigurator implementation contract |  |

### setPriceOracle

[](#write-methods-setpriceoracle)

    function setPriceOracle(address newPriceOracle) external override onlyOwner

Updates the address of the price oracle.

#### Input Parameters:

[](#write-methods-setpriceoracle-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| newPriceOracle | address | The address of new price oracle |  |

### setACLManager

[](#write-methods-setaclmanager)

    function setACLManager(address newAclManager) external override onlyOwner

Updates the address of the Access Control List Manager.

#### Input Parameters:

[](#write-methods-setaclmanager-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| newAclManager | address | The address of the new ACLManager |  |

### setACLAdmin

[](#write-methods-setacladmin)

    function setACLAdmin(address newAclAdmin) external override onlyOwner

Updates the address of the Access Control List Admin.

#### Input Parameters:

[](#write-methods-setacladmin-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| newAclAdmin | address | The address of new ACLAdmin |  |

### setPriceOracleSentinel

[](#write-methods-setpriceoraclesentinel)

    function setPriceOracleSentinel(address newPriceOracleSentinel) external override onlyOwner

Updates the address of the price oracle sentinel.

#### Input Parameters:

[](#write-methods-setpriceoraclesentinel-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| newPriceOracleSentinel | address | The address of new PriceOracleSentinel |  |

### setPoolDataProvider

[](#write-methods-setpooldataprovider)

    function setPoolDataProvider(address newDataProvider) external override onlyOwner

Updates the address of the data provider.

#### Input Parameters:

[](#write-methods-setpooldataprovider-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| newDataProvider | address | The address of new DataProvider |  |

View Methods
------------

[](#view-methods)

### getMarketId

[](#view-methods-getmarketid)

    function getMarketId() external view override returns (string memory)

Returns the market id of the associated Aave market.

#### Return Values:

[](#view-methods-getmarketid-return-values)

| Type | Description |  |
| --- | --- | --- |
| string | A string representation of the market id |  |

### getAddress

[](#view-methods-getaddress)

    function getAddress(bytes32 id) public view override returns (address)

Returns the address of protocol contract stored at the given id. The returned address might be an EOA or a contract, which may be proxied. It will return ZERO if there is no registered address with the given id.

#### Input Parameters:

[](#view-methods-getaddress-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| id | bytes32 | The id. For example, the Protocol Data Provider uses id 0x1 |  |

#### Return Values:

[](#view-methods-getaddress-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address associated with the id passed |  |

#### Example:

[](#view-methods-getaddress-example)

    // Get address of incentive controllerimport { utils } from "@ethers/lib/utils";
    const id = utils.keccak256(utils.toUtf8Bytes("INCENTIVES_CONTROLLER"));const address = poolAddressProvider.getAddress(id);

### getPool

[](#view-methods-getpool)

    function getPool() external view override returns (address)

Returns the address of the latest Pool proxy contract.

#### Return Values:

[](#view-methods-getpool-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the associated Pool proxy |  |

### getPoolConfigurator

[](#view-methods-getpoolconfigurator)

    function getPoolConfigurator() external view override returns (address)

Returns the address of the PoolConfigurator proxy. Used for configuration methods, like init reserves or update token implementation etc, of the market.

#### Return Values:

[](#view-methods-getpoolconfigurator-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The PoolConfigurator proxy address |  |

### getPriceOracle

[](#view-methods-getpriceoracle)

    function getPriceOracle() external view override returns (address)

Returns the address of the Price Oracle used by the market.

#### Return Values:

[](#view-methods-getpriceoracle-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the price oracle used by the associated market |  |

### getACLManager

[](#view-methods-getaclmanager)

    function getACLManager() external view override returns (address)

Returns the address of the Access Control List Manager (ACLManager) that manages the system role of the market.

#### Return Values:

[](#view-methods-getaclmanager-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the ACLManger contract managing the system role of the associated market |  |

### getACLAdmin

[](#view-methods-getacladmin)

    function getACLAdmin() external view override returns (address)

Returns the address of the Access Control List Admin (ACLAdmin) of the market which holds the DEFAULT\_ADMIN\_ROLE in ACLManager.

#### Return Values:

[](#view-methods-getacladmin-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the Access Control List admin of the associated market |  |

### getPriceOracleSentinel

[](#view-methods-getpriceoraclesentinel)

    function getPriceOracleSentinel() external view override returns (address)

Returns the address of the price oracle sentinel.

#### Return Values:

[](#view-methods-getpriceoraclesentinel-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the PriceOracleSentinel of the associated market |  |

### getPoolDataProvider

[](#view-methods-getpooldataprovider)

    function getPoolDataProvider() external view override returns (address)

Returns the address of latest pool data provider.

#### Return Values:

[](#view-methods-getpooldataprovider-return-values)

| Type | Description |  |
| --- | --- | --- |
| address | The address of the pool data provider of the associated market |  |</content>
</page>

<page>
  <title>Pool Configurator</title>
  <url>https://aave.com/docs/developers/smart-contracts/pool-configurator</url>
  <content>[](#pool-configurator)

The PoolConfigurator contract implements the configuration methods for the Aave Protocol. The 'write methods' below are grouped by permissioned system roles that are managed by [ACLManager](https://aave.com/docs/developers/smart-contracts/acl-manager).

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/pool/PoolConfigurator.sol).

Write Methods
-------------

[](#write-methods)

Only Asset Listing Or Pool Admins Methods
-----------------------------------------

[](#only-asset-listing-or-pool-admins-methods)

### initReserves

[](#only-asset-listing-or-pool-admins-methods-initreserves)

    function initReserves(ConfiguratorInputTypes.InitReserveInput[] calldata input) external override onlyAssetListingOrPoolAdmins

Initializes multiple reserves using the array of initialization parameters as input.

#### Input Parameters:

[](#only-asset-listing-or-pool-admins-methods-initreserves-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| input | ConfiguratorInputTypes.InitReserveInput\[\] | The array of initialization parameters |  |

The [ConfiguratorInputTypes.InitReserveInput\[\]](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/libraries/types/ConfiguratorInputTypes.sol) struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| aTokenImpl | address | The address of the aToken contract implementation |  |
| variableDebtTokenImpl | address | The address of the variable debt token contract |  |
| useVirtualBalance | bool | true if reserve is utilising virtual balance accounting |  |
| interestRateStrategyAddress | address | The address of the interest rate strategy contract for this reserve |  |
| underlyingAsset | address | The address of the underlying asset |  |
| treasury | address | The address of the treasury |  |
| incentivesController | address | The address of the incentives controller for this aToken |  |
| aTokenName | string | The name of the aToken |  |
| aTokenSymbol | string | The symbol of the aToken |  |
| variableDebtTokenName | string | The name of the variable debt token |  |
| variableDebtTokenSymbol | string | The symbol of the variable debt token |  |
| params | bytes | A set of encoded parameters for additional initialization |  |
| interestRateData | bytes | Encoded interest rate strategy data |  |

Only Emergency Admin Methods
----------------------------

[](#only-emergency-admin-methods)

### setPoolPause

[](#only-emergency-admin-methods-setpoolpause)

    function setPoolPause(bool paused) external override onlyEmergencyOrPoolAdmin

Pauses or unpauses all the protocol reserves. In the paused state all the protocol interactions are suspended.

#### Input Parameters:

[](#only-emergency-admin-methods-setpoolpause-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| paused | bool | true if the protocol needs to be paused, otherwise false |  |

Only Emergency Or Pool Admin Methods
------------------------------------

[](#only-emergency-or-pool-admin-methods)

### setReservePause

[](#only-emergency-or-pool-admin-methods-setreservepause)

    function setReservePause(address asset, bool paused) public override onlyEmergencyOrPoolAdmin

Pauses a reserve. A paused reserve does not allow any interaction (supply, borrow, repay, liquidate, atoken transfers).

#### Input Parameters:

[](#only-emergency-or-pool-admin-methods-setreservepause-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| paused | bool | true if pausing the reserve, false if unpausing the reserve |  |

Only Pool Admin Methods
-----------------------

[](#only-pool-admin-methods)

### dropReserve

[](#only-pool-admin-methods-dropreserve)

    function dropReserve(address asset) external override onlyPoolAdmin

Drops a reserve entirely.

#### Input Parameters:

[](#only-pool-admin-methods-dropreserve-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the reserve to drop |  |

### updateAToken

[](#only-pool-admin-methods-updateatoken)

    function updateAToken(ConfiguratorInputTypes.UpdateATokenInput calldata input) external override onlyPoolAdmin

Updates the aToken implementation for the reserve. Takes the aToken update parameters as input.

#### Input Parameters:

[](#only-pool-admin-methods-updateatoken-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| input | ConfiguratorInputTypes.UpdateATokenInput | The aToken update parameters |  |

The [ConfiguratorInputTypes.UpdateATokenInput](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/libraries/types/ConfiguratorInputTypes.sol) struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| treasury | address | The address of the treasury |  |
| incentivesController | address | The address of the incentives controller for this aToken |  |
| name | string | The name of the aToken |  |
| symbol | string | The symbol of the aToken |  |
| implementation | address | The new aToken implementation |  |
| params | bytes | A set of encoded parameters for additional initialization |  |

### updateVariableDebtToken

[](#only-pool-admin-methods-updatevariabledebttoken)

    function updateVariableDebtToken(ConfiguratorInputTypes.UpdateDebtTokenInput calldata input) external override onlyPoolAdmin

#### Input Parameters:

[](#only-pool-admin-methods-updatevariabledebttoken-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| input | ConfiguratorInputTypes.UpdateDebtTokenInput | The variableDebtToken update parameters |  |

The [ConfiguratorInputTypes.UpdateDebtTokenInput](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/libraries/types/ConfiguratorInputTypes.sol) struct is composed of the following fields:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| incentivesController | address | The address of the incentives controller for this variableDebtToken |  |
| name | string | The name of the variableDebtToken |  |
| symbol | string | The symbol of the variableDebtToken |  |
| implementation | address | The new variableDebtToken implementation |  |
| params | bytes | A set of encoded parameters for additional initialization |  |

### setReserveActive

[](#only-pool-admin-methods-setreserveactive)

    function setReserveActive(address asset, bool active) external override onlyPoolAdmin

Activate or deactivate a reserve.

#### Input Parameters:

[](#only-pool-admin-methods-setreserveactive-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| active | bool | true if the reserve needs to be active, false otherwise |  |

### updateBridgeProtocolFee

[](#only-pool-admin-methods-updatebridgeprotocolfee)

    function updateBridgeProtocolFee(uint256 newBridgeProtocolFee) external override onlyPoolAdmin

Updates the bridge fee collected by the protocol reserves.

#### Input Parameters:

[](#only-pool-admin-methods-updatebridgeprotocolfee-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| newBridgeProtocolFee | uint256 | The part of the fee sent to the protocol treasury, expressed in bps |  |

### setReserveFlashLoaning

[](#only-pool-admin-methods-setreserveflashloaning)

    function setReserveFlashLoaning(address asset, bool enabled) external override onlyRiskOrPoolAdmins

Enables or disables flash loans for a reserve.

#### Input Parameters:

[](#only-pool-admin-methods-setreserveflashloaning-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | Address of the reserve asset |  |
| enabled | bool | true to enable, false to disable |  |

### updateFlashloanPremiumTotal

[](#only-pool-admin-methods-updateflashloanpremiumtotal)

    function updateFlashloanPremiumTotal(uint128 newFlashloanPremiumTotal) external override onlyPoolAdmin

Updates the total flash loan premium. The premium is calculated on the total amount borrowed, and is expressed in bps.

The total flash loan premium consists of two parts:

*   A part is sent to aToken holders as extra balance, and
    
*   A part is collected by the protocol reserves.
    

#### Input Parameters:

[](#only-pool-admin-methods-updateflashloanpremiumtotal-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| newFlashloanPremiumTotal | uint128 | The total flashloan premium |  |

### updateFlashloanPremiumToProtocol

[](#only-pool-admin-methods-updateflashloanpremiumtoprotocol)

    function updateFlashloanPremiumToProtocol(uint128 newFlashloanPremiumToProtocol) external override onlyPoolAdmin

Updates the flash loan premium collected by protocol reserves. The premium to protocol is calculated on the total flashloan premium, and is expressed in bps.

#### Input Parameters:

[](#only-pool-admin-methods-updateflashloanpremiumtoprotocol-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| newFlashloanPremiumToProtocol | uint128 | The part of the flashloan premium sent to the protocol treasury |  |

Only Risk Or Pool Admins Methods
--------------------------------

[](#only-risk-or-pool-admins-methods)

### setReserveBorrowing

[](#only-risk-or-pool-admins-methods-setreserveborrowing)

    function setReserveBorrowing(address asset, bool enabled) external override onlyRiskOrPoolAdmins

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setreserveborrowing-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| enabled | bool | true if borrowing needs to be enabled, false otherwise |  |

### configureReserveAsCollateral

[](#only-risk-or-pool-admins-methods-configurereserveascollateral)

    function configureReserveAsCollateral(    address asset,    uint256 ltv,    uint256 liquidationThreshold,    uint256 liquidationBonus) external override onlyRiskOrPoolAdmins

Configures the reserve collateralization parameters. All the values are expressed in bps. A value of 10000 results in 100.00%. The liquidationBonus is always above 100%. A value of 105% means the liquidator will receive a 5% bonus.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-configurereserveascollateral-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| ltv | uint256 | The loan to value of the asset when used as collateral |  |
| liquidationThreshold | uint256 | The threshold at which loans using this asset as collateral will be considered undercollateralized |  |
| liquidationBonus | uint256 | The bonus liquidators receive to liquidate this asset |  |

### setReserveFreeze

[](#only-risk-or-pool-admins-methods-setreservefreeze)

    function setReserveFreeze(address asset, bool freeze) external override onlyRiskOrPoolAdmins

Freeze or unfreeze a reserve. A frozen reserve doesn't allow any new supply or borrow but allows repayments, liquidations, rate rebalances and withdrawals.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setreservefreeze-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| freeze | bool | true if the reserve needs to be frozen, false otherwise |  |

### setBorrowableInIsolation

[](#only-risk-or-pool-admins-methods-setborrowableinisolation)

    function setBorrowableInIsolation(address asset, bool borrowable) external override onlyRiskOrPoolAdmins

Sets the borrowable in isolation flag for the reserve. When this flag is set to true, the asset will be borrowable against isolated collaterals and the borrowed amount will be accumulated in the isolated collateral's total debt exposure. Only assets of the same family (e.g. USD stablecoins) should be borrowable in isolation mode to keep consistency in the debt ceiling calculations.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setborrowableinisolation-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| borrowable | bool | true if the asset should be borrowable in isolation, false otherwise |  |

### setReserveFactor

[](#only-risk-or-pool-admins-methods-setreservefactor)

    function setReserveFactor(address asset, uint256 newReserveFactor) external override onlyRiskOrPoolAdmins

Updates the reserve factor of a reserve.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setreservefactor-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| newReserveFactor | uint256 | The new reserve factor of the reserve |  |

### setDebtCeiling

[](#only-risk-or-pool-admins-methods-setdebtceiling)

    function setDebtCeiling(address asset, uint256 newDebtCeiling) external override onlyRiskOrPoolAdmins

Sets the debt ceiling for an asset.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setdebtceiling-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| newDebtCeiling | uint256 | The new debt ceiling |  |

### setSiloedBorrowing

[](#only-risk-or-pool-admins-methods-setsiloedborrowing)

    function setSiloedBorrowing(address asset, bool newSiloed) external override onlyRiskOrPoolAdmins

Sets siloed borrowing for an asset

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setsiloedborrowing-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| newSiloed | bool | The new siloed borrowing state - enable or disable siloed borrowing for the reserve |  |

### setBorrowCap

[](#only-risk-or-pool-admins-methods-setborrowcap)

    function setBorrowCap(address asset, uint256 newBorrowCap) external override onlyRiskOrPoolAdmins

Updates the borrow cap of a reserve. Allows [RISK\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager) and [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager) to add/update cap on the total borrow that can be borrowed from the reserve. Once the borrow cap is reached, no more borrow positions for the given reserve asset can be initiated.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setborrowcap-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| newBorrowCap | uint256 | The new borrow cap of the reserve in whole tokens. A borrow cap of 0 signifies that there is no cap |  |

### setSupplyCap

[](#only-risk-or-pool-admins-methods-setsupplycap)

    function setSupplyCap(address asset, uint256 newSupplyCap) external override onlyRiskOrPoolAdmins

Updates the supply cap of a reserve. Allows [RISK\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager) and [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager) to add/update liquidity supply cap on the reserve. Once the supply cap is reached, no more liquidity for the given reserve asset can be supplied to the pool.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setsupplycap-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| newSupplyCap | uint256 | The new supply cap of the reserve in whole tokens. A supply cap of 0 signifies that there is no cap |  |

### disableLiquidationGracePeriod

[](#only-risk-or-pool-admins-methods-disableliquidationgraceperiod)

    function disableLiquidationGracePeriod(address asset) external override onlyEmergencyOrPoolAdmin

Disables the liquidation grace period for a reserve.

#### Input Parameters

[](#only-risk-or-pool-admins-methods-disableliquidationgraceperiod-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | Address of the reserve asset |  |

### setLiquidationProtocolFee

[](#only-risk-or-pool-admins-methods-setliquidationprotocolfee)

    function setLiquidationProtocolFee(address asset, uint256 newFee) external override onlyRiskOrPoolAdmins

Updates the liquidation protocol fee of reserve.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setliquidationprotocolfee-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| newFee | uint256 | The new liquidation protocol fee of the reserve, expressed in bps |  |

### setEModeCategory

[](#only-risk-or-pool-admins-methods-setemodecategory)

    function setEModeCategory(    uint8 categoryId,    uint16 ltv,    uint16 liquidationThreshold,    uint16 liquidationBonus,    string calldata label) external override onlyRiskOrPoolAdmins

Adds a new efficiency mode (eMode) category. Allows [RISK\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager) and [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager) to configure existing or add new eModeCategory

If zero is provided as oracle address, the default asset oracles will be used to compute the overall debt and overcollateralization of the users using this category. The new ltv and liquidation threshold must be greater than the base ltvs and liquidation thresholds of all assets within the eMode category.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setemodecategory-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| categoryId | uint8 | The id of the category to be configured. categoryId ≠ 0. NOTE: category 0 is reserved for the default category i.e. non-eMode |  |
| ltv | uint16 | The loan to value for the associated eMode category. It must be less than or equal to the liquidationThreshold |  |
| liquidationThreshold | uint16 | The liquidation threshold associated with the category |  |
| liquidationBonus | uint16 | The liquidation bonus associated with the category |  |
| label | string | A custom label identifying the category |  |

### setAssetCollateralInEMode

[](#only-risk-or-pool-admins-methods-setassetcollateralinemode)

    function setAssetCollateralInEMode(address asset, uint8 categoryId, bool allowed) external override onlyRiskOrPoolAdmins

Assign collateral status to an asset for a particular efficiency mode (eMode) category. Allows [RISK\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager) and [POOL\_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager) to configure eModeCategory of an asset.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setassetcollateralinemode-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| categoryId | uint8 | eMode category id to set asset collateral status for |  |
| allowed | bool | true if asset is enabled as collateral in designated categoryId |  |

### setAssetBorrowableInEMode

[](#only-risk-or-pool-admins-methods-setassetborrowableinemode)

    function setAssetBorrowableInEMode(address asset, uint8 categoryId, bool borrowable) external override onlyRiskOrPoolAdmins

Configures if an asset can be borrowed in a specific eMode category.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setassetborrowableinemode-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | Address of the reserve asset |  |
| categoryId | uint8 | eMode category ID |  |
| borrowable | bool | true to enable, false to disable |  |

### setUnbackedMintCap

[](#only-risk-or-pool-admins-methods-setunbackedmintcap)

    function setUnbackedMintCap(address asset, uint256 newUnbackedMintCap) external override onlyRiskOrPoolAdmins

Updates the unbacked mint cap of reserve.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setunbackedmintcap-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| newUnbackedMintCap | uint256 | The new unbacked mint cap of the reserve |  |

### setReserveInterestRateData

[](#only-risk-or-pool-admins-methods-setreserveinterestratedata)

    function setReserveInterestRateData(address asset, bytes calldata rateData) external onlyRiskOrPoolAdmins

Sets custom interest rate parameters for a reserve.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setreserveinterestratedata-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | Address of the reserve asset |  |
| rateData | bytes | Encodes rate strategy parameters |  |

### setReserveInterestRateStrategyAddress

[](#only-risk-or-pool-admins-methods-setreserveinterestratestrategyaddress)

    function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress, bytes calldata rateData) external override onlyRiskOrPoolAdmins

Sets the interest rate strategy of a reserve.

#### Input Parameters:

[](#only-risk-or-pool-admins-methods-setreserveinterestratestrategyaddress-input-parameters)

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the underlying asset of the reserve |  |
| rateStrategyAddress | address | The address of the interest strategy contract |  |
| rateData | bytes | Encoded interst rate strategy data |  |

Pure Methods
------------

[](#pure-methods)

### getRevision

[](#pure-methods-getrevision)

    function getRevision() internal pure virtual override returns (uint256)

Returns the revision number of the contract. Needs to be defined in the inherited class as a constant.

Returns 0x1.

#### Return Values:

[](#pure-methods-getrevision-return-values)

| Type | Description |  |
| --- | --- | --- |
| uint256 | The revision number |  |</content>
</page>

<page>
  <title>Switch Adapters</title>
  <url>https://aave.com/docs/developers/smart-contracts/switch-adapters</url>
  <content>[](#switch-adapters)

These switch adapters integrate Aave's Flash Loans and the ParaSwap DEX aggregator smart contracts to facilitate advanced actions such as repaying borrow positions using collateral, switching collateral assets, switching borrow positions, and withdrawing and switching assets. They allow users to perform complex operations in a single transaction, leveraging the liquidity of the Aave protocol and the atomic switching capabilities of decentralized exchanges.

The table below outlines switch feature availability across V3 markets on the [Aave Labs interface](https://app.aave.com/):

| Market | Repay With Collateral | Collateral Switch | Debt Switch | Withdraw & Switch |  |
| --- | --- | --- | --- | --- | --- |
| Ethereum Core |  |  |  |  |  |
| Ethereum Prime |  |  |  |  |  |
| Ethereum EtherFi |  |  |  |  |  |
| Arbitrum |  |  |  |  |  |
| Avalanche |  |  |  |  |  |
| Base |  |  |  |  |  |
| BNB |  |  |  |  |  |
| Optimism |  |  |  |  |  |
| Polygon |  |  |  |  |  |
| Gnosis |  |  |  |  |  |
| Fantom |  |  |  |  |  |
| Harmony |  |  |  |  |  |
| Metis |  |  |  |  |  |
| Scroll |  |  |  |  |  |
| ZKsync |  |  |  |  |  |

Repay With Collateral
---------------------

[](#repay-with-collateral)

The ParaSwapRepayAdapter contract enables users to repay their borrow positions on Aave using their supplied collateral directly, without the need to unwind their positions or provide additional liquidity. It leverages Aave's Flash Loans and the ParaSwap DEX aggregator to switch the user's collateral for the borrowed asset and repay the borrow position in a single atomic transaction.

By using this adapter, users can efficiently manage their positions and reduce their borrow positions using their existing collateral, saving on transaction costs and avoiding manual steps.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/extensions/paraswap-adapters/ParaSwapRepayAdapter.sol).

Reference Integration: [useCollateralRepaySwap.tsx](https://github.com/aave/interface/blob/main/src/hooks/paraswap/useCollateralRepaySwap.tsx)

### Write Methods

[](#repay-with-collateral-write-methods)

#### executeOperation

[](#repay-with-collateral-write-methods-executeoperation)

    function executeOperation(    address asset,    uint256 amount,    uint256 premium,    address initiator,    bytes calldata params) external override nonReentrant returns (bool)

Uses the received funds from the flash loan to repay a borrow position on the protocol on behalf of the user. Then, pulls the collateral from the user and switches it to the debt asset to repay the flash loan.

The user should give this contract allowance to pull the aTokens in order to withdraw the underlying asset, switch it, and repay the flash loan.

Supports only one asset on the flash loan.

The params parameter should be the ABI-encoded values of the following:

*   IERC20Detailed debtAsset — The address of the borrow position asset
    
*   uint256 debtRepayAmount — The amount of the borrow position to be repaid
    
*   uint256 buyAllBalanceOffset — Offset in the ParaSwap calldata if switching all balance
    
*   uint256 rateMode — The rate mode of the borrow position to be repaid
    
*   bytes paraswapData — Data for the ParaSwap Adapter
    
*   PermitSignature permitSignature — Struct containing the permit signature, set to zeroes if not used
    

##### Input Parameters:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the flash-borrowed asset |  |
| amount | uint256 | The amount of the flash-borrowed asset |  |
| premium | uint256 | The fee of the flash-borrowed asset |  |
| initiator | address | The address of the flash loan initiator |  |
| params | bytes | The byte-encoded parameters passed when initiating the flash loan |  |

##### Return Values:

| Type | Description |  |
| --- | --- | --- |
| bool | True if the execution of the operation succeeds, false otherwise |  |

#### swapAndRepay

[](#repay-with-collateral-write-methods-swapandrepay)

    function swapAndRepay(    IERC20Detailed collateralAsset,    IERC20Detailed debtAsset,    uint256 collateralAmount,    uint256 debtRepayAmount,    uint256 debtRateMode,    uint256 buyAllBalanceOffset,    bytes calldata paraswapData,    PermitSignature calldata permitSignature) external nonReentrant

Switches the user's collateral for the debt asset and then repays the borrow position on the protocol on behalf of the user without using flash loans. This method can be used when the temporary transfer of the collateral asset to this contract does not affect the user's position.

The user should give this contract allowance to pull the aTokens in order to withdraw the underlying asset.

##### Input Parameters:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| collateralAsset | IERC20Detailed | The address of the collateral asset to be switched |  |
| debtAsset | IERC20Detailed | The address of the debt asset |  |
| collateralAmount | uint256 | The maximum amount of the collateral to be switched |  |
| debtRepayAmount | uint256 | The amount of the borrow position to be repaid, or maximum amount when repaying all |  |
| debtRateMode | uint256 | The rate mode of the borrow position to be repaid |  |
| buyAllBalanceOffset | uint256 | Offset in the ParaSwap calldata if switching all balance, otherwise 0 |  |
| paraswapData | bytes | Data for the ParaSwap Adapter |  |
| permitSignature | PermitSignature | Struct containing the permit signature, set to zeroes if not used |  |

#### PermitSignature Struct

[](#repay-with-collateral-write-methods-permitsignature-struct)

    struct PermitSignature {    uint256 deadline;    uint8 v;    bytes32 r;    bytes32 s;}

##### Members:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| deadline | uint256 | The deadline timestamp for the permit signature |  |
| v | uint8 | The V parameter of the ECDSA signature |  |
| r | bytes32 | The R parameter of the ECDSA signature |  |
| s | bytes32 | The S parameter of the ECDSA signature |  |

* * *

Collateral Switch
-----------------

[](#collateral-switch)

The ParaSwapLiquiditySwapAdapter contract allows users to switch their supplied collateral from one asset to another in a single transaction using Aave's Flash Loans and the ParaSwap DEX aggregator.

This adapter enables users to rebalance their collateral positions without needing to withdraw and re-supply assets manually. By leveraging flash loans, the user can switch their existing collateral to a new asset and supply it back into the Aave protocol in a single transaction.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/extensions/paraswap-adapters/ParaSwapLiquiditySwapAdapter.sol).

Reference Integration: [useCollateralSwap.tsx](https://github.com/aave/interface/blob/main/src/hooks/paraswap/useCollateralSwap.tsx)

### Write Methods

[](#collateral-switch-write-methods)

#### executeOperation

[](#collateral-switch-write-methods-executeoperation)

    function executeOperation(    address asset,    uint256 amount,    uint256 premium,    address initiator,    bytes calldata params) external override nonReentrant returns (bool)

Switches the received amount from the flash loan into the specified asset. The received funds from the switch are then supplied into the protocol on behalf of the user.

The user should give this contract allowance to pull the aTokens in order to withdraw the underlying asset and repay the flash loan.

The params parameter should be the ABI-encoded values of the following:

*   IERC20Detailed assetToSwapTo — The address of the underlying asset to be switched to and supplied
    
*   uint256 minAmountToReceive — The minimum amount to be received from the switch
    
*   uint256 swapAllBalanceOffset — Offset in the Augustus calldata if switching all balance, otherwise 0
    
*   bytes swapCalldata — Calldata for ParaSwap's Augustus Swapper contract
    
*   IParaSwapAugustus augustus — Address of ParaSwap's Augustus Swapper contract
    
*   PermitSignature permitParams — Struct containing the permit signature, set to zeroes if not used
    

##### Input Parameters:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| asset | address | The address of the flash-borrowed asset |  |
| amount | uint256 | The amount of the flash-borrowed asset |  |
| premium | uint256 | The fee of the flash-borrowed asset |  |
| initiator | address | The address of the flash loan initiator |  |
| params | bytes | The byte-encoded parameters passed when initiating the flash loan |  |

##### Return Values:

| Type | Description |  |
| --- | --- | --- |
| bool | True if the execution of the operation succeeds, false otherwise |  |

#### swapAndDeposit

[](#collateral-switch-write-methods-swapanddeposit)

    function swapAndDeposit(    IERC20Detailed assetToSwapFrom,    IERC20Detailed assetToSwapTo,    uint256 amountToSwap,    uint256 minAmountToReceive,    uint256 swapAllBalanceOffset,    bytes calldata swapCalldata,    IParaSwapAugustus augustus,    PermitSignature calldata permitParams) external nonReentrant

Switches an amount of an asset to another and supplies the new asset amount on behalf of the user without using a flash loan. This method can be used when the temporary transfer of the collateral asset to this contract does not affect the user's position.

The user should give this contract allowance to pull the aTokens in order to withdraw the underlying asset and perform the switch.

##### Input Parameters:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| assetToSwapFrom | IERC20Detailed | The address of the underlying asset to be switched from |  |
| assetToSwapTo | IERC20Detailed | The address of the underlying asset to be switched to and supplied |  |
| amountToSwap | uint256 | Amount to be switched, or maximum amount when switching all balance |  |
| minAmountToReceive | uint256 | Minimum amount to be received from the switch |  |
| swapAllBalanceOffset | uint256 | Offset in Augustus calldata if switching all balance, otherwise 0 |  |
| swapCalldata | bytes | Calldata for ParaSwap's Augustus Swapper contract |  |
| augustus | IParaSwapAugustus | Address of ParaSwap's Augustus Swapper contract |  |
| permitParams | PermitSignature | Struct containing the permit signature, set to zeroes if not used |  |

* * *

Borrow Position Switch
----------------------

[](#borrow-position-switch)

The ParaSwapDebtSwapAdapter contracts allow users to switch their borrow positions from one asset to another. They leverage Aave's Flash Loans and the ParaSwap DEX aggregator to perform the switch in a single atomic transaction.

There are two versions of the adapter:

*   **ParaSwapDebtSwapAdapterV3**: The standard version that supports switching any borrow position asset.
    
    *   Source Code: [GitHub](https://github.com/bgd-labs/aave-debt-swap/blob/main/src/contracts/ParaSwapDebtSwapAdapterV3.sol)
        
    *   Reference Integration: [useDebtSwitch.tsx](https://github.com/aave/interface/blob/main/src/hooks/paraswap/useDebtSwitch.tsx)
        
    
*   **ParaSwapDebtSwapAdapterV3GHO**: A specialized version that supports GHO, where GHO can be flash minted via the ERC-3156 interface.
    
    *   Source Code: [GitHub](https://github.com/bgd-labs/aave-debt-swap/blob/main/src/contracts/ParaSwapDebtSwapAdapterV3GHO.sol)
        
    *   Reference Integration: [useDebtSwitch.tsx](https://github.com/aave/interface/blob/main/src/hooks/paraswap/useDebtSwitch.tsx)
        
    

### ParaSwapDebtSwapAdapterV3

[](#borrow-position-switch-paraswapdebtswapadapterv3)

The ParaSwapDebtSwapAdapterV3 contract allows users to switch their borrow positions from one asset to another, enabling borrow position refinancing on the Aave protocol.

This adapter leverages Aave's Flash Loans and the ParaSwap DEX aggregator to perform the borrow position switch in a single transaction.

#### Write Methods

[](#borrow-position-switch-paraswapdebtswapadapterv3-write-methods)

##### executeOperation

    function executeOperation(    address[] calldata assets,    uint256[] calldata amounts,    uint256[] calldata,    address initiator,    bytes calldata params) external returns (bool)

Performs the borrow position switch operation using the received funds from the flash loan.

Performs the switch and repay operation using the borrowed funds from the flash loan, and then re-borrows the new borrow position asset to maintain the overall borrow position.

The params parameter should be the ABI-encoded values required for the operation, such as:

*   The addresses of the borrow position assets involved
    
*   The rate modes of the borrow positions
    
*   ParaSwap switch data
    
*   Any necessary permit signatures
    

##### Input Parameters:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| assets | address\[\] | The addresses of the assets being borrowed in the flash loan |  |
| amounts | uint256\[\] | The amounts of the assets being borrowed |  |
| premiums | uint256\[\] | The fees for the flash loans |  |
| initiator | address | The address of the flash loan initiator |  |
| params | bytes | Arbitrary data containing the parameters needed for the operation |  |

##### Return Values:

| Type | Description |  |
| --- | --- | --- |
| bool | True if the execution of the operation succeeds, false otherwise |  |

### ParaSwapDebtSwapAdapterV3GHO

[](#borrow-position-switch-paraswapdebtswapadapterv3gho)

The ParaSwapDebtSwapAdapterV3GHO contract is a specialized version of the borrow position switch adapter that supports GHO, allowing users to switch their borrow positions involving GHO. It utilizes the ERC-3156 flash mint interface for GHO.

Performs the switch and repay operation using the borrowed funds from the flash loan, and then re-borrows the borrow position asset to maintain the overall borrow position.

#### Write Methods

[](#borrow-position-switch-paraswapdebtswapadapterv3gho-write-methods)

##### onFlashLoan

    function onFlashLoan(    address initiator,    address token,    uint256 amount,    uint256 fee,    bytes calldata data) external override returns (bytes32)

This is the ERC-3156 Flash Loan callback function that gets called when the contract receives a flash loan (in this case, flash mint) from the GHO Flash Minter.

##### Input Parameters:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| initiator | address | The initiator of the flash loan |  |
| token | address | The address of the token being borrowed |  |
| amount | uint256 | The amount of tokens being borrowed |  |
| fee | uint256 | The fee for the flash loan |  |
| data | bytes | Arbitrary data containing the parameters needed for the operation |  |

##### Return Values:

| Type | Description |  |
| --- | --- | --- |
| bytes32 | The keccak256 hash of the string 'ERC3156FlashBorrower.onFlashLoan' |  |

* * *

Withdraw & Switch
-----------------

[](#withdraw-switch)

The ParaSwapWithdrawSwapAdapter contract allows users to withdraw their supplied assets from Aave and switch them to another asset in a single transaction using the ParaSwap DEX aggregator.

This adapter enables users to efficiently exit positions and switch their assets without having to perform multiple transactions, reducing gas costs and simplifying the user experience.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/extensions/paraswap-adapters/ParaSwapWithdrawSwapAdapter.sol).

Reference Integration: [WithdrawAndSwitchActions.tsx](https://github.com/aave/interface/blob/main/src/components/transactions/Withdraw/WithdrawAndSwitchActions.tsx)

### Write Methods

[](#withdraw-switch-write-methods)

#### withdrawAndSwap

[](#withdraw-switch-write-methods-withdrawandswap)

    function withdrawAndSwap(    IERC20Detailed assetToSwapFrom,    IERC20Detailed assetToSwapTo,    uint256 amountToSwap,    uint256 minAmountToReceive,    uint256 swapAllBalanceOffset,    bytes calldata swapCalldata,    IParaSwapAugustus augustus,    PermitSignature calldata permitParams) external nonReentrant

Switches an amount of an asset to another after a withdrawal and transfers the new asset to the user. The user should give this contract allowance to pull the aTokens in order to withdraw the underlying asset and perform the switch.

##### Input Parameters:

| Name | Type | Description |  |
| --- | --- | --- | --- |
| assetToSwapFrom | IERC20Detailed | The address of the underlying asset to be switched from |  |
| assetToSwapTo | IERC20Detailed | The address of the underlying asset to be switched to |  |
| amountToSwap | uint256 | Amount to be switched, or maximum amount when switching all balance |  |
| minAmountToReceive | uint256 | Minimum amount to be received from the switch |  |
| swapAllBalanceOffset | uint256 | Offset in Augustus calldata if switching all balance, otherwise 0 |  |
| swapCalldata | bytes | Calldata for ParaSwap's Augustus Swapper contract |  |
| augustus | IParaSwapAugustus | Address of ParaSwap's Augustus Swapper contract |  |
| permitParams | PermitSignature | Struct containing the permit signature, set to zeroes if not used |  |

#### executeOperation

[](#withdraw-switch-write-methods-executeoperation)

Note that in this contract, the executeOperation method is overridden but simply reverts with NOT\_SUPPORTED, so it's not intended to be used.</content>
</page>

<page>
  <title>GHO</title>
  <url>https://aave.com/docs/developers/gho</url>
  <content>[](#gho)

Aave V3 MarketFlash MintGHO Stability ModuleCross-chain•••Aave GovernanceGHOOwnsFacilitators

GHO is an ERC-20 token deployed on Ethereum that operates through a facilitator model. Facilitators are contracts approved by Aave Governance with the ability to mint and burn GHO, each subject to a governance-defined mint cap. This model allows for flexibility in expanding GHO's functionality while maintaining decentralized control over the supply.

Deployed Contracts
------------------

[](#deployed-contracts)

### Ethereum Mainnet

[](#deployed-contracts-ethereum-mainnet)

### Arbitrum

[](#deployed-contracts-arbitrum)

### Sepolia (Testnet)

[](#deployed-contracts-sepolia-testnet)

GHO Token
---------

[](#gho-token)

### transfer

[](#gho-token-transfer)

The simplest method for transferring ERC-20 tokens is transfer which can be used to send tokens to any address without a prior token approval. The limitation of transfer is that it must be executed directly by the token holder, so it cannot be used within a smart contract function call to retrieve funds from a user (EOA).

### transferFrom

[](#gho-token-transferfrom)

To transfer tokens within a smart contract function, transferFrom is the method that is used. The transferFrom function requires the sender to have approved the spender address for at least the transfer amount. There are two methods which can be used to perform the approval:

### approve

[](#gho-token-approve)

The standard ERC-20 approve requires an on-chain transaction from the token holder to a approve a specified spender and amount.

### permit

[](#gho-token-permit)

EIP-2612 permit is a type of token approval which requires two components:

*   A signed approval message from the token holder which encodes: owner, spender, amount, nonce, deadline, DOMAIN\_SEPARATOR
    
*   An on-chain permit transaction which can be executed from any address
    

The advantages to using permit in place of approve are that the gas cost of the transaction can be paid for by an address other than the token owner, and can reduce the number of transactions by batching the permit call with another action, an example of this is [supplyWithPermit](https://github.com/aave-dao/aave-v3-origin/blob/ec33f4fcc5546710c0faca5208af1775c761ac9c/src/contracts/protocol/pool/Pool.sol#L154) from Aave Protocol V3.

Facilitators
------------

[](#facilitators)

### Aave V3 Ethereum Market

[](#facilitators-aave-v3-ethereum-market)

Interacting with GHO via the Aave Pool Facilitator is very similar to interacting with a typical Aave reserve asset with two key differences:

*   GHO is minted, not supplied, therefore interest rate and available liquidity calculations are based on custom interest rate strategy and facilitator caps respectively
    
*   GHO has a discounted borrow rate for stkAAVE holders
    

Below are the technical guides for all GHO actions along with their contract references.

#### Minting

[](#facilitators-aave-v3-ethereum-market-minting)

Minting occurs through the borrow function of the Aave V3 Ethereum market. To mint GHO, the process is nearly identical to borrowing any other reserve. To mint, an address must have sufficient collateral which is performed by approving and then calling supply on the Aave Pool with an eligible collateral asset. Once an address has sufficient collateral, it is able to borrow up to a maximum collateral factor determined by its collateral asset composition.

Since GHO is created and not borrowed from suppliers, GHO is not subject to restrictions on available liquidity, and instead, the Facilitator cap and collateralization requirements define the limits to which GHO can be minted as calculated below.

availableFacilitatorCap = ghoReserveData.aaveFacilitatorButcketMaxCapacity - ghoReserveData.aaveFacilitatorBucketLevel

See [core functions](https://aave.com/docs/developers/smart-contracts/pool) for more information on integrating Aave borrow functionality.

#### Repay

[](#facilitators-aave-v3-ethereum-market-repay)

GHO is repaid just like any other asset, by approving the Pool contract to spend GHO tokens (by approval transaction or signed permit and repayWithPermit).

What is different about GHO is the calculation of accrued interest. See the discount dynamics section for more info on how accrued interest affects balances for repayment.

See [core functions](https://aave.com/docs/developers/smart-contracts/pool) for more information on integrating Aave repay functionality.

### Liquidation

[](#facilitators-liquidation)

When an address has a GHO borrow position, they are eligible to be liquidated under the same conditions as any other collateralized address. If the health factor of a GHO borrow falls below one, which occurs when the sum of borrow value exceeds the weighted average of liquidation thresholds of collateral assets, then any address is eligible to make a liquidationCall on the Pool contract.

The liquidationCall repays up to 100% of the GHO borrow position in exchange for an equivalent USD valuation of the collateral plus a liquidation bonus.

See the developers [liquidation guide](https://aave.com/docs/developers/liquidations) for more information.

### Flash Mint

[](#facilitators-flash-mint)

Since GHO is not borrowed like a typical Aave reserve, a separate Facilitator is used in place to replicate the flashloan functionality of the Aave Pool.

The FlashMinter Facilitator has a separate minting cap from the Aave Pool. Since all FlashMint transactions are returned in a single transaction, no GHO is ever minted against this Facilitator and the cap is applied to each transaction.

FlashMint is useful for a variety of applications such as liquidations, debt switches, and peg arbitrage. The GhoFlashMinter smart contract implements the following functions:

    function maxFlashLoan(address token) external view override returns (uint256)

    function getFee() external view override returns (uint256)

    function flashLoan(    IERC3156FlashBorrower receiver,    address token,    uint256 amount,    bytes calldata data) external override returns (bool)

See the developers [flash loan guide](https://aave.com/docs/developers/flash-loans) for more information on developing flash loan integrations.

### Stability Module

[](#facilitators-stability-module)

A Peg Stability Module (PSM) is a contract that enables the conversion of two tokens at a predetermined ratio. The GHO Stability Module (GSM) leverages the benefits of existing PSM models while innovating upon them in several ways to help further maintain GHO’s peg. The GSM is designed to facilitate conversions between GHO and governance-approved tokens, underpinned by a suite of features designed for flexible operations and risk management.

#### GSMRegistry

[](#facilitators-stability-module-gsmregistry)

The GSMRegistry is a smart contract that stores a list of all GSM instances. This contract is owned by the Aave Governance Short Executor.

#### GSM

[](#facilitators-stability-module-gsm)

Each token pairing in the stability module has a GSM or GSM4626 contract instance that acts as the GHO facilitator and entry-point for buy and sell functionality.

The GSM4626 contract is a special instance of the GSM that supports ERC-4626 tokenized vault shares as the exogenous token.

The parameters and periphery contracts that dictate module operations are detailed below:

#### Price Strategy

[](#facilitators-stability-module-price-strategy)

The GSM introduces a flexible Price Strategy framework, enabling the module to adapt its pricing mechanism based on market conditions or strategic objectives. This system supports both fixed and dynamic pricing strategies, allowing for adjustments in response to real-time market data or predetermined conditions. The initial implementation focuses on a fixed 1:1 pricing strategy for simplicity and stability, with provisions for future adaptation to dynamic strategies as dictated by DAO governance.

#### Fee Strategy

[](#facilitators-stability-module-fee-strategy)

Each GSM instance has a FeeStrategy contract that determines a percentage fee for buy and sell conversions that is allocated to the Aave DAO treasury.

#### Exposure Cap

[](#facilitators-stability-module-exposure-cap)

The exposure cap is a parameter determined by Aave DAO Governance that sets the maximum amount of an exogenous token the stability module can hold.

#### Conversion Freezes and Oracle Price Bounds

[](#facilitators-stability-module-conversion-freezes-and-oracle-price-bounds)

In case the price of the exogenous token deviates from a determined ratio, the freeze role can be utilized by the Aave DAO or assigned to an entity (autonomous agents or contracts) to respond and halt conversions.

An implementation of the freeze role is the OracleSwapFreezer contract. This contract utilizes Chainlink oracles and price bounds determined by Aave Governence to freeze/unfreeze based on oracle conditions.

#### Last Resort Liquidations

[](#facilitators-stability-module-last-resort-liquidations)

In case of a rapid increase in risk in an exogenous token, the GSM features Last Resort Liquidations to liquidate the exogenous token. This contract role allows in the worst-case scenarios for the DAO to pause GSM functionality and liquidate the underlying balance of exogenous tokens.

### Cross-Chain

[](#facilitators-cross-chain)

All GHO tokens are originated on Ethereum mainnet. GHO is made available to access on other networks using an infrastructure of cross-chain messaging.

The Chainlink CCIP protocol has been approved by Aave Governance as the messaging bridge to facilitate the transfer of GHO between networks.

GHO is transferred by between networks by initiating a lock (Ethereum mainnet) or burn (other networks) action on the source network, and a release (Ethereum mainnet) or mint (other networks) action occurs on the destination chain after the cross-chain message has been validated.

The GHOCCIPTokenPoolEthereum contract facilitates the locking and burning of GHO on Ethereum and other chains, enabling GHO's presence across multiple DeFi ecosystems.

**CCIP Subgraph**: Track GHO's cross-chain activity through subgraphs for Ethereum and Arbitrum:

*   [CCIP Ethereum Subgraph](https://thegraph.com/explorer/subgraphs/E11p8T4Ff1DHZbwSUC527hkUb5innVMdTuP6A2s1xtm1?view=Query&chain=arbitrum-one)
    
*   [CCIP Arbitrum Subgraph](https://thegraph.com/explorer/subgraphs/GPpZfiGoDChLsiWoMG5fxXdRNEYrsVDrKJ39moGcbz6i?view=Query&chain=arbitrum-one)
    

See the [Aave Labs interface bridging integration](https://github.com/aave/interface/tree/main/src/components/transactions/Bridge) as a reference for token bridging.</content>
</page>

<page>
  <title>Safety Module</title>
  <url>https://aave.com/docs/developers/safety-module</url>
  <content>[](#safety-module)

The Aave Safety Module serves as a safeguard for the Aave Protocol against potential shortfall events. By staking AAVE, GHO, or AAVE / wstETH Balancer Pool tokens, participants contribute to the security of the protocol and earn incentives in return. The staked tokens may be slashed in the event of a shortfall to cover any protocol deficits.

The Safety Module operates by allowing users to stake their ERC-20 tokens into StakeToken contracts, which are also ERC-20 tokens. These StakeToken contracts handle the distribution of rewards and manage the slashing mechanism. The implementation details of the StakeToken contracts are available on [GitHub](https://github.com/bgd-labs/aave-stk-gov-v3).

The [Umbrella](https://governance.aave.com/t/bgd-aave-safety-module-umbrella/18366) governance proposal outlines potential changes to the Safety Module, including automated slashing, replacing stkAAVE and stkABPT with aToken staking, and new incentives design, subject to community approval.

Staking
-------

[](#staking)

Users stake tokens by calling the stake function on the StakeToken contract with the amount they wish to stake. In exchange, they receive staked tokens adjusted by the current exchange rate, representing their share in the Safety Module.

    function stake(address to, uint256 amount) external;

Unstaking
---------

[](#unstaking)

Before withdrawing their staked tokens, users must initiate a cooldown period by invoking the cooldown() function. After the cooldown period, defined by \_cooldownSeconds, has elapsed, there is a limited window (UNSTAKE\_WINDOW) during which users can redeem their staked tokens by calling the redeem function. If this window is missed, the cooldown process must be restarted.

    function cooldown() external;function redeem(address to, uint256 amount) external;

Actions involving staked tokens can affect the cooldown period:

*   **Staking More Tokens**: Adding more tokens to your stake during an active cooldown doesn't impact the existing cooldown. The new tokens will require a separate cooldown period before they can be unstaked.
    
*   **Unstaking Tokens**: Once the cooldown period has passed, only the tokens that were in cooldown can be unstaked. Unstaking resets the cooldown for the withdrawn amount, and any remaining staked tokens will need a new cooldown period for future withdrawals.
    
*   **Claiming Rewards**: Collecting earned incentives doesn't affect the cooldown period. Users can claim rewards at any time without influencing their cooldown status.
    
*   **Transferring Staked Tokens**: Sending staked tokens to another address doesn't alter the sender's cooldown. The recipient must initiate their own cooldown period to unstake those tokens, as the cooldown is not transferred along with the tokens.
    

After the cooldown period concludes, users have a two-day window to unstake their tokens. Failing to do so within this timeframe means they must initiate the cooldown process again, waiting the full duration before being able to unstake.

Exchange Rate Mechanism
-----------------------

[](#exchange-rate-mechanism)

The exchange rate determines how staked tokens convert back to the underlying assets. Initially set to a 1:1 ratio (1e18), the exchange rate adjusts in response to slashing events or when additional funds are added to the module. This mechanism determines the value of staked tokens to reflect the total assets within the Safety Module after such events. The exchange rate is calculated using the formula:

    exchangeRate = (totalAssets * EXCHANGE_RATE_UNIT) / totalShares;

Rewards
-------

[](#rewards)

Participants earn rewards over time based on emission rates set by Aave Governance. The AaveDistributionManager contract manages the calculation and distribution of these incentives. Rewards are proportional to the amount staked and the duration of staking.

The formula for calculating accrued rewards is:

    Accrued Rewards = (User's Stake * (Asset Index - User Index))

*   **Asset Index**: A cumulative value representing the total rewards per unit staked, updated regularly based on the emission rate and total staked tokens.
    
*   **User Index**: The index value recorded during the user's last interaction with the staking contract.
    

Claiming Rewards
----------------

[](#claiming-rewards)

Users can claim their accumulated rewards at any time by calling the claimRewards function:

    function claimRewards(address to, uint256 amount) external;

Claimed rewards are transferred to the user's wallet. This action does not affect the staking status or the cooldown period. Users with the appropriate permissions can also claim rewards on behalf of others using claimRewardsOnBehalf. Additionally, there's an option to claim rewards and immediately restake them in one transaction using claimRewardsAndStake, allowing users to compound rewards.

Slashing
--------

[](#slashing)

Slashing is a mechanism designed to cover losses in the event of a protocol shortfall by utilizing a portion of the staked funds. Only addresses with the SLASH\_ADMIN\_ROLE (held by [Aave Governance](https://aave.com/docs/primitives/governance)) can initiate a slashing event by calling the slash function:

    function slash(address destination, uint256 amount) external onlySlashingAdmin returns (uint256);

The maximum slashing amount is determined per-asset by \_maxSlashablePercentage, a predefined limit set by the SLASH\_ADMIN\_ROLE.

After a slashing event, the exchange rate is updated to reflect the reduced total assets, proportionally affecting all stakers. The module then enters a post-slashing period during which:

*   New staking is temporarily disabled to prevent dilution of existing stakers' shares.
    
*   Stakers can redeem their tokens without waiting for a cooldown period, allowing them to exit the module promptly.
    
*   No further slashing events can occur until the current one is settled.
    

To conclude the post-slashing period and resume normal operations, the SLASH\_ADMIN\_ROLE must call:

    function settleSlashing() external onlySlashingAdmin;

Deployed Contracts
------------------

[](#deployed-contracts)</content>
</page>

<page>
  <title>Governance</title>
  <url>https://aave.com/docs/developers/governance</url>
  <content>[](#governance)

The Aave Protocol is governed by the AAVE token holder community through procedures, voting, and smart contract execution, collectively known as **Aave Governance**.

All instances of the Aave Protocol are governed by the AAVE, stkAAVE, and aAAVE token holders on **Ethereum mainnet**. [Aave Governance V3](https://github.com/bgd-labs/aave-governance-v3), developed by [BGD Labs](https://bgdlabs.com/), introduces the ability to vote on lower transaction fee networks such as Polygon POS and Avalanche C-Chain while token balances remain on Ethereum mainnet.

Architecture
------------

[](#architecture)

Aave Governance V3 is designed with a modular architecture to meet the comprehensive needs of an on-chain DAO like Aave. The system is divided into three main components, each corresponding to different stages in the proposal lifecycle:

*   **Core Network**: Acts as the settlement and security layer where voting power resides. It handles high-level validations on proposals and manages governance token balances. Ethereum Mainnet serves as the Core Network.
    
*   **Voting Networks**: Environments where voting occurs based on storage proofs. These networks are typically lower-cost environments like Polygon POS and Avalanche C-Chain, enabling users to vote without migrating funds from the Core Network.
    
*   **Execution Networks**: Networks where proposal payloads are registered and executed. They handle the execution of approved proposals across various networks, including all Voting Networks and the Core Network.
    

Communication between these components is facilitated by the [Aave Delivery Infrastructure](https://governance.aave.com/t/bgd-a-di-aave-delivery-infrastructure/13951) (a.DI), providing secure and efficient cross-chain interactions. Additionally, the [Aave Robot](https://governance.aave.com/t/bgd-aave-robot-v1/13091) automates permissionless actions in Aave Governance such as queueing and executing proposals.

Voting
------

[](#voting)

In Governance V3, each proposal specifies a voting network and all voting for the proposal occurs on this network. The Governance V3 activation enables Polygon POS, Avalanche C-Chain, and Ethereum Mainnet (backup) as initial voting networks.

Voters do not need to migrate funds to the voting network, all governance token balances and delegations are still stored on Ethereum mainnet, and are validated on the voting network using storage proofs.

Voting is performing by calling the submitVote() function on the VotingMachine of the corresponding proposal’s voting network.

An [aave-cli](https://github.com/bgd-labs/aave-cli/blob/main/README.md) has been developed to generate the necessary storage proof parameters, or voting can performed with the [GovernanceV3Helpers](https://github.com/bgd-labs/aave-helpers?tab=readme-ov-file#govv3helpers) Foundry script.

### Voting Power

[](#voting-voting-power)

AAVE, stkAAVE (AAVE staked in protocol safety module), and aAAVE (aToken representing AAVE supplied to Ethereum V3 market) token holders receive governance powers proportional to the sum of their balances on Ethereum mainnet.

There are two powers associated with each governance token:

*   The **proposal power** that gives access to creating a proposal.
    
*   The **voting power** which is used to vote for or against active proposals.
    

Governance powers can be either jointly or separately delegated to any Ethereum address.

### Voting Representatives

[](#voting-voting-representatives)

Smart contract wallets cannot sign messages for storage proof voting and may not exist on all networks, this creates a challenge to interact with the cross-chain voting contracts.

To accommodate cross-chain voting for smart contract wallets and allow greater flexibility for all governance participants, wallets have the ability to link a representative address on other chains.

To choose a representative, an address in Ethereum should call the updateRepresentativesPerChain() function on the GovernanceCore smart contract.

This representative address is able to vote on the specified network, using the delegators balances and received delegations on Ethereum Mainnet. An address can be the representative of multiple other addresses.

### Storage Proofs

[](#voting-storage-proofs)

Aave Governance V3 uses block hashes on the Core network (Ethereum Mainnet) as the source of information for voting balances, and storage proofs as the core mechanism for validation.

For any proposal, the system takes a “snapshot” (block hash of the block before activateVote method gets called) of voting token balances/delegations on the Core network, forwards it to an Aave Voting Network and sets it as the main source of balances/delegation to validate against whenever an address submits a vote there.

Ethereum block hashes contain the state tree of the network, which in turn contains all the data of all the smart contracts at that exact block. Amongst those contracts: AAVE, stkAAVE, and other voting assets are present, and within them, the balances and delegations of all Ethereum addresses.

Storage proofs are a mechanism allowing to cryptographically prove that a piece of data is contained in a tree. In this case, they allow proving that a specific address has voting balance/delegation on the state tree of an Ethereum block.

What happens in practice when an address votes is that the voter inputs the balance of the voting assets they hold at the proposal's Ethereum block, together with a storage proof over the Ethereum block hash for that proposal. The Voting Network then cryptographically verifies the storage proof against the Ethereum block data, along with all additional validations (e.g., no double-voting), and stores the results accordingly.

Proposal Lifecycle
------------------

[](#proposal-lifecycle)

1.  **Payload Registration**: Proposal payloads containing executable logic are deployed and registered on the PayloadsController of the target Execution Network. This process is permissionless.
    
2.  **Proposal Creation**: A proposer with sufficient proposal power creates the proposal on the Core Network (Ethereum Mainnet) by interacting with the Governance contract. The proposer specifies the payload IDs and target networks.
    
3.  **Proposal Activation**: After a cooldown period (coolDownBeforeVotingStart), the proposal is activated. This involves taking a snapshot of the Core Network's state and forwarding it to the specified Voting Network using a.DI.
    
4.  **Voting Setup**: On the Voting Network, the necessary data (Ethereum block hash, state tree, voting asset roots) is settled in the DataWarehouse contract. This step is permissionless and can be performed by any address.
    
5.  **Voting Period**: Voting occurs on the Voting Network. Voters submit their votes by calling submitVote() on the VotingMachine, providing their token balances at the snapshot block along with storage proofs.
    
6.  **Vote Closure**: After the voting duration (votingDuration) elapses, voting is closed. The VotingMachine contract sends the voting results (YES and NO counts) back to the Core Network via a.DI.
    
7.  **Result Validation**: The Governance contract on the Core Network validates the voting results against success metrics, such as minimum thresholds and vote differentials.
    
8.  **Proposal Queuing**: If the proposal meets the success criteria, it is forwarded to the PayloadsController on the Execution Network, where it is queued in a timelock mechanism.
    
9.  **Proposal Execution**: After the timelock expires, any address can execute the proposal by calling executePayload() on the PayloadsController, which forwards it to the appropriate Executor for execution.
    

Deployed Contracts
------------------

[](#deployed-contracts)

### Ethereum

[](#deployed-contracts-ethereum)

### Arbitrum

[](#deployed-contracts-arbitrum)

### Avalanche

[](#deployed-contracts-avalanche)

### BNB

[](#deployed-contracts-bnb)

### Base

[](#deployed-contracts-base)

### Binance

[](#deployed-contracts-binance)

### Gnosis

[](#deployed-contracts-gnosis)

### Metis

[](#deployed-contracts-metis)

### Optimism

[](#deployed-contracts-optimism)

### Polygon

[](#deployed-contracts-polygon)

### Scroll

[](#deployed-contracts-scroll)

### ZkSync

[](#deployed-contracts-zksync)</content>
</page>

<page>
  <title>Flash Loans</title>
  <url>https://aave.com/docs/developers/flash-loans</url>
  <content>[](#flash-loans)

Flash Loans are special transactions that allow the borrowing of an asset, as long as the borrowed amount (and a fee) is returned before the end of the transaction (also called One Block Borrows). These transactions do not require a user to supply collateral prior to engaging in the transaction. There is no real world analogy to Flash Loans, so it requires some basic understanding of how state is managed within blocks in blockchains.

Flash Loans are an advanced concept aimed at developers. You must have a good understanding of EVM, programming, and smart contracts to be able to use this feature.

Overview
--------

[](#overview)

Flash-loan allows users to access liquidity of the pool (only for reserves for which borrow is enabled) for one transaction as long as the amount taken plus fee is returned or (if allowed) debt position is opened by the end of the transaction.

Aave V3 offers two options for flash loans:

*   [flashLoan()](https://aave.com/docs/developers/smart-contracts/pool#flashloan): Allows borrower to access liquidity of _**multiple reserves**_ in single _flashLoan_ transaction. The borrower also has an option to open variable rate borrow position backed by supplied collateral or credit delegation in this case.  
    NOTE: _flash loan fee_ is waived for approved flashBorrowers (managed by [ACLManager](https://aave.com/docs/developers/smart-contracts/acl-manager))
    
*   [flashLoanSimple()](https://aave.com/docs/developers/smart-contracts/pool#flashloansimple): Allows borrower to access liquidity of _single reserve_ for the transaction. In this case flash loan fee is not waived nor can borrower open any debt position at the end of the transaction. This method is gas efficient for those trying take advantage of simple flash loan with single reserve asset.
    

### Execution Flow

[](#overview-execution-flow)

For developers, a helpful mental model to consider when developing your solution:

1.  Your contract calls the [Pool](https://aave.com/docs/developers/smart-contracts/pool) contract, requesting a Flash Loan of a certain amount(s) of reserve(s) using [flashLoanSimple()](https://aave.com/docs/developers/smart-contracts/pool#flashloansimple) or [flashLoan()](https://aave.com/docs/developers/smart-contracts/pool#flashloan).
    
2.  After some sanity checks, the [Pool](https://aave.com/docs/developers/smart-contracts/pool) transfers the requested amounts of the reserves to your contract, then calls executeOperation() on receiver contract .
    
3.  Your contract, now holding the flash loaned amount(s), executes any arbitrary operation in its code.
    
    *   If you are performing a **flashLoanSimple**, then when your code has finished, you approve Pool for flash loaned amount + fee.
        
    *   If you are performing **flashLoan,** then for all the reserves either depending on interestRateMode passed for the asset, either the Pool must be approved for flash loaned amount + fee or must or sufficient collateral or credit delegation should be available to open debt position.
        
    *   If the amount owed is not available (due to a lack of balance or approval or insufficient collateral for debt), then the transaction is reverted.
        
    
4.  All of the above happens in 1 transaction (hence in a single ethereum block).
    

### Applications of Flash Loans

[](#overview-applications-of-flash-loans)

Aave Flash Loans are already used with Aave V3 for liquidity switch feature. Other examples in the wild include:

*   Arbitrage between assets, without needing to have the principal amount to execute the arbitrage.
    
*   Liquidating borrow positions, without having to repay the debt of the positions and using discounted collateral claimed to payoff flashLoan amount + fee.
    

### Flash loan fee

[](#overview-flash-loan-fee)

The flash loan fee is initialized at deployment to 0.05% and can be updated via Governance Vote. Use [FLASHLOAN\_PREMIUM\_TOTAL](https://aave.com/docs/developers/smart-contracts/pool#flashloan_premium_total) to get current value.

Flashloan fee can be shared by the LPs (liquidity providers) and the protocol treasury. The [FLASHLOAN\_PREMIUM\_TOTAL](https://aave.com/docs/developers/smart-contracts/pool#flashloan_premium_total) represents the total fee paid by the borrowers of which:

*   Fee to LP: [FLASHLOAN\_PREMIUM\_TOTAL](https://aave.com/docs/developers/smart-contracts/pool#flashloan_premium_total) - [FLASHLOAN\_PREMIUM\_TO\_PROTOCOL](https://aave.com/docs/developers/smart-contracts/pool#flashloan_premium_to_protocol)
    
*   Fee to Protocol: [FLASHLOAN\_PREMIUM\_TO\_PROTOCOL](https://aave.com/docs/developers/smart-contracts/pool#flashloan_premium_to_protocol)
    

Step by step
------------

[](#step-by-step)

### 1\. Setting Up

[](#step-by-step-section-1-setting-up)

Your contract that receives the flash loaned amounts **must** conform to the [IFlashLoanSimpleReceiver](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/misc/flashloan/interfaces/IFlashLoanSimpleReceiver.sol) or [IFlashLoanReceiver](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/misc/flashloan/interfaces/IFlashLoanReceiver.sol) interface by implementing the relevant executeOperation() function.

Also note that since the owed amounts will be _pulled_ from your contract, your contract must give allowance to the [Pool](https://aave.com/docs/developers/smart-contracts/pool) to pull those funds to pay back the flash loan amount + premiums.

### 2\. Calling flashLoan() or flashLoanSimple()

[](#step-by-step-section-2-calling-flashloan-or-flashloansimple)

To call either of the two flash loan methods on the Pool, we need to pass in the relevant parameters. There are 3 ways you can do this.

1.  From an EOA ('normal' ethereum account)
    
    To use an EOA, send a transaction to the relevant [Pool](https://aave.com/docs/developers/smart-contracts/pool) calling the [flashLoan()](https://aave.com/docs/developers/smart-contracts/pool#flashloan) or [flashLoanSimple()](https://aave.com/docs/developers/smart-contracts/pool#flashloansimple) function. See the [Pool](https://aave.com/docs/developers/smart-contracts/pool) docs for parameter details, ensuring you use your contract address from [step 1](https://aave.com/docs/developers/flash-loans#1-setting-up) for the receiverAddress.
    
2.  From a different contract
    
    Similar to sending a transaction from an EOA as above, ensure the receiverAddress is your contract address from [step 1](https://aave.com/docs/developers/flash-loans#1-setting-up).
    
3.  From the _same_ contract
    
    If you want to use the same contract as in step 1, use address(this) for the receiverAddress parameter in the flash loan method.
    

### Completing the flash loan

[](#step-by-step-completing-the-flash-loan)

Once you have performed your logic with the flash loaned assets (in your executeOperation() function), you will need to pay back the flash loaned amounts if you used [flashLoanSimple()](https://aave.com/docs/developers/smart-contracts/pool#flashloansimple) or interestRateModes = 0 in [flashLoan()](https://aave.com/docs/developers/smart-contracts/pool#flashloan) for any of the assets in modes parameter.

*   #### Paying back a flash loaned asset
    
    [](#step-by-step-completing-the-flash-loan-paying-back-a-flash-loaned-asset)
    
    Ensure your contract has the relevant amount + premium to payback the borrowed asset. You can calculate this by taking the sum of the relevant entry in the amounts and premiums array passed into the executeOperation() function.
    
    You **do not** need to transfer the owed amount back to the [Pool](https://aave.com/docs/developers/smart-contracts/pool). The funds will be automatically _pulled_ at the conclusion of your operation.
    
*   #### Incurring a debt (i.e. not immediately paying back)
    
    [](#step-by-step-completing-the-flash-loan-incurring-a-debt-ie-not-immediately-paying-back)
    
    If you initially used a mode=1 or mode=2 for any of the assets in the modes parameter, then the address passed in for onBehalfOf will incur the debt **if** the onBehalfOf address has previously approved the msg.sender to incur debts on their behalf.
    
    This means that you can have some assets that are paid back immediately, while other assets incur a debt.</content>
</page>

<page>
  <title>Credit Delegation</title>
  <url>https://aave.com/docs/developers/credit-delegation</url>
  <content>[](#credit-delegation)

Credit delegation allows a supplier to contribute liquidity to the Aave protocol to earn interest, and delegate borrowing power (i.e. their credit) to other users. The enforcement of the borrow position and its terms are agreed upon between the supplier and borrowers, which can be either offchain via legal agreements or onchain via smart contracts.

This enables:

*   The supplier (aka delegator) to earn extra yield on top of the yield they already earn from the protocol.
    
*   The borrowers (aka delegatees) to access uncollateralized liquidity.
    

Borrow by _delegatee_ must be consistent with _delegator_ eMode category. For eg. if a delegator eMode category is STABLECOINS, then

*   Delegator can only borrow STABLECOINS eMode category asset.
    
*   In case _delegator_ approve credit to _delegatee_ for non STABLECOINScategory (for eg. weth), then borrow would revert.
    

The _delegatee_ cannot abuse credit approval to liquidate _delegator_ i.e. if the borrow puts _delegator's_ position in HF < HEALTH\_FACTOR\_LIQUIDATION\_THRESHOLD, then borrow will fail.

Approving the delegation
------------------------

[](#approving-the-delegation)

The approveDelegation or delegationWithSig function on the [VariableDebtToken](https://aave.com/docs/developers/smart-contracts/tokenization#variabledebttoken) contract must be called by the supplier (delegator), approving the borrower (delegatee) a certain amount.

This is done for each debt token that needs to be delegated.

The delegator does not need to already have supplied funds in the protocol to approveDelegation. However, **before** the delegatee executes borrow, there must be sufficient collateral supplied by delegator in the protocol.

Borrowing the credit
--------------------

[](#borrowing-the-credit)

The borrower (delegatee) calls the borrow function on the [Pool](https://aave.com/docs/developers/smart-contracts/pool), using the supplier's (delegator's) address in final parameter onBehalfOf.

The borrower's available credit is reduced by the borrowed amount.

Repaying the credit
-------------------

[](#repaying-the-credit)

Anyone can repay the borrow position _OnBehalf_ of the user, by calling one of the following [Pool](https://aave.com/docs/developers/smart-contracts/pool) functions - repay or repayWithPermit. The supplier (aka creditor) can also use the repayWithATokens function to repay a borrow position with their _aTokens_ of the underlying asset in the same pool.</content>
</page>

<page>
  <title>Legacy Versions</title>
  <url>https://aave.com/docs/developers/legacy-versions</url>
  <content>[](https://aave.com/docs)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>Aave V2</title>
  <url>https://aave.com/docs/developers/legacy-versions/v2</url>
  <content>[](#aave-v2)

Resources
---------

[](#resources)

*   [Contract Addresses](https://aave.com/docs/resources/addresses)
    
*   [Source Code](https://github.com/aave/protocol-v2)
    
*   [Subgraphs](https://github.com/aave/protocol-subgraphs)
    
*   [JavaScript SDK](https://github.com/aave/aave-utilities)
    
*   [Interface](https://app.aave.com/)
    
*   [Whitepaper](https://github.com/aave/protocol-v2/blob/master/aave-v2-whitepaper.pdf)
    

Architecture
------------

[](#architecture)

### Pool

[](#architecture-pool)

The main entry point into the Aave Protocol. Most interactions with Aave will happen via the Pool, including:

*   deposit()
    
*   borrow()
    
*   repay()
    
*   setUserUseReserveAsCollateral()
    
*   withdraw()
    
*   flashloan()
    
*   liquidationCall()
    

### PoolAddressesProvider

[](#architecture-pooladdressesprovider)

The main addresses register of the protocol, for particular markets. The latest contract addresses should be retrieved from this contract by making the appropriate calls.

### PoolAddressesProviderRegistry

[](#architecture-pooladdressesproviderregistry)

Contains a list of active PoolAddressesProvider addresses, for different markets.

### aTokens

[](#architecture-atokens)

The yield-generating, tokenized representation of supplies used throughout the Aave protocol. They implement most of the standard EIP-20/ERC20 token methods with slight modifications, as well as Aave-specific methods including:

*   scaledBalanceOf()
    
*   getScaledUserBalanceAndSupply()
    
*   scaledTotalSupply()
    

All aTokens also implement EIP-2612, which via the permit() function enables single transaction approve + actions.

### Variable Debt Tokens

[](#architecture-variable-debt-tokens)

The tokenized borrow positions used throughout the Aave protocol. Most of the standard EIP-20/ERC20 methods are disabled since debt tokens are non-transferrable.

### Supporting Contracts

[](#architecture-supporting-contracts)

The following contracts should generally not be interacted with directly, but are used throughout the Aave Protocol via contract calls.

#### PoolCollateralManager

[](#architecture-supporting-contracts-poolcollateralmanager)

Using delegatecall via the Pool contract, the PoolCollateralManager implements actions involving the management of collateral in the protocol, including:

*   liquidationCall()
    

This function should only be called via the main Pool contract.

#### Pool Configurator

[](#architecture-supporting-contracts-pool-configurator)

Provides configuration functions for the Pool contracts. It has a number of important functions, such as:

*   Activates / Deactivates reserves
    
*   Enables / Disables borrowing for a reserve
    
*   Enables / Disables using a reserve as collateral
    
*   Enables / Disables stable rate borrowing for a reserve
    
*   Freezes / Unfreezes reserves
    
*   Updates a reserve's Loan to Value
    
*   Updates a reserve's liquidation threshold
    
*   Updates a reserve's liquidation bonus
    
*   Updates a reserve's decimals
    
*   Updates a reserve's interest rate strategy address
    
*   Activates / Deactivates all functions of a Pool in emergencies
    

For all of the above functions, relevant events are emitted to the blockchain. Anyone can monitor these changes to know when values have been modified or added/removed.

#### Interest Rate Strategy

[](#architecture-supporting-contracts-interest-rate-strategy)

Holds the information needed to calculate and update the interest rates of specific reserves. Each contract stores the optimized base curves using the corresponding parameters of each currency. The parameters for the optimized base curves are:

*   baseVariableBorrowRate
    
*   variableRateSlope1
    
*   variableRateSlope2
    
*   stableRateSlope1
    
*   stableRateSlope2
    

The interest rates are calculated depending on the available liquidity and the total borrowed amount.</content>
</page>

<page>
  <title>Aave V1</title>
  <url>https://aave.com/docs/developers/legacy-versions/v1</url>
  <content>[](#aave-v1)

Resources
---------

[](#resources)

*   [Whitepaper](https://github.com/aave/aave-protocol/blob/master/docs/Aave_Protocol_Whitepaper_v1_0.pdf)
    
*   [Source Code](https://github.com/aave/aave-protocol)
    
*   [Contract Addresses](https://github.com/bgd-labs/aave-address-book/blob/main/src/AaveV1.sol)
    
*   [Interface](https://github.com/aave/aave-protocol)
    

Key differences
---------------

[](#key-differences)

The following are key architectural differences between Aave v1 and subsequent protocol versions:

*   **Tokenization**: In V1, positions were not tokenized, meaning users had to manually calculate their supply & borrow balances by querying individual contracts.
    
*   **PoolCore**: V1 used a separate contract, PoolCore, to hold protocol assets, which added complexity for users and developers. In V2, this was replaced, and assets are held directly by aTokens.
    
*   **ETH -> WETH**: In V1, the protocol used ETH directly, but Aave V2 switched to WETH for consistency.
    
*   **Interest Redirection**: V1 allowed users to redirect earned interest to another address, a feature removed in V2.
    
*   **Batch Flash Loans**: V1 introduced flash loans, but they were limited to single transactions. V2 expanded this to batch flash loans and added new modes for flash loans with deferred repayment.
    
*   **Withdraw aTokens**: In V1, users had to redeem or withdraw their aTokens through the aToken contract. V2 migrated this action to the Pool contract.
    

Architecture
------------

[](#architecture)

### Pool Core

[](#architecture-pool-core)

The PoolCore contract holds the state of every reserve and all assets supplied, as well as the basic logic (e.g. calculations using the stored data).

### PoolAddressesProvider

[](#architecture-pooladdressesprovider)

The PoolAddressesProvider is a global addresses register of the protocol. This contract is immutable and the address will never change.

### Pool Data Provider

[](#architecture-pool-data-provider)

The PoolDataProvider contract performs calculations and provides data for the Pool contract, specifically:

*   Calculates the ETH equivalent of a user's balance to assess the borrow limit of a user and the health factor of their positions.
    
*   Aggregates data from PoolCore to provide high level information to the Pool.
    
*   Calculates the Average Loan to Value and Average Liquidation Ratio.
    

### Pool

[](#architecture-pool)

The Pool contract uses both the PoolCore and PoolDataProvider to interact with the reserves. This is the main contract developers should interface with. See the Pool section of the documentation.

The Pool also manages the tokenization of users' supply position via aTokens.

### Pool Configurator

[](#architecture-pool-configurator)

The PoolConfigurator contract provides configuration functions for the Pool and PoolCore contracts. It also has a number of important functions:

*   Activates / Deactivates reserves,
    
*   Enables / Disables borrowing for a reserve,
    
*   Enables / Disables using a reserve as collateral,
    
*   Enables / Disables stable rate borrowing for a reserve,
    
*   Freezes / Unfreezes reserves,
    
*   Updates a reserve's Loan to Value,
    
*   Updates a reserve's liquidation threshold,
    
*   Updates a reserve's liquidation bonus,
    
*   Updates a reserve's decimals,
    
*   Updates a reserve's interest rate strategy address.
    

For all of the above functions, relevant events are emitted to the blockchain. Anyone can monitor these changes to know when values have been modified or added/removed.

The contract is owned by the PoolManager, as defined in the PoolAddressProvider.

### Interest Rate Strategy

[](#architecture-interest-rate-strategy)

The InterestRateStrategy contract holds the information needed to calculate and update the interest rates of specific reserves.

Each contract stores the optimised base curves using the corresponding parameters of each currency. This means that there is a mathematical function which determines the interest rate of each asset pool, with the interest rate changing based on the amount of borrowed funds and the total liquidity (i.e. utilisation) of the asset pool.

The parameters for the optimised base curves are:

*   baseVariableBorrowRate
    
*   variableRateSlope1
    
*   variableRateSlope2
    
*   stableRateSlope1
    
*   stableRateSlope2
    

The interest rates are calculated depending on the available liquidity and the total borrowed amount.

Every reserve has a corresponding InterestRateStrategy contract.</content>
</page>

<page>
  <title>Testing & Debugging</title>
  <url>https://aave.com/docs/developers/testing-and-debugging</url>
  <content>[](#testing-debugging)

This guide provides comprehensive instructions on how to test and debug Aave protocol integrations.

Testing
-------

[](#testing)

There are two primary methods for testing the Aave protocol: using a **testnet** or creating **fork networks**.

### Testnet

[](#testing-testnet)

The Aave protocol is available for testing on the Sepolia testnet. You can access the Sepolia V3 testnet market by visiting [app.aave.com](https://app.aave.com/) and enabling testnet mode in the top right corner.

To get started:

1.  Visit the test market on [app.aave.com](https://app.aave.com/).
    
2.  Use the **Faucet** tab to acquire test tokens available in the market.
    
3.  Supply these tokens to the protocol.
    
4.  Perform operations such as borrowing, repaying, and withdrawing to test different functionalities.
    

### Fork Networks

[](#testing-fork-networks)

A fork network replicates the state of a blockchain, allowing you to interact with it in a sandbox environment. This is especially useful for testing scenarios that depend on contracts and states existing on the mainnet.

#### Creating a Fork Network

[](#testing-fork-networks-creating-a-fork-network)

Several tools can help you create a fork network:

*   **[Tenderly](https://docs.tenderly.co/simulations-and-forks/forks)**: Debugging toolkit with fork networks, simulations, and online dashboard.
    
*   **[Foundry](https://book.getfoundry.sh/forge/fork-testing)**: Smart contract development framework.
    
*   **[Hardhat](https://hardhat.org/hardhat-network/docs/guides/forking-other-networks)**: Smart contract development framework.
    

To acquire tokens on a fork network, you can impersonate an address that holds the desired tokens (holders can be found using block explorers) and transfer them to your address.

#### Connecting the Fork Network to the UI

[](#testing-fork-networks-connecting-the-fork-network-to-the-ui)

The [app.aave.com](https://app.aave.com/) interface can be configured to connect to a fork network. By setting specific variables via the browser console, you can enable this functionality. Refer to [this guide](https://github.com/aave/interface/blob/main/CONTRIBUTING.md#running-against-a-chain-fork) for detailed instructions.

Debugging
---------

[](#debugging)

When interacting with the Aave protocol, you may encounter smart contract errors. This section helps you understand how to interpret error codes, use debugging tools, and resolve common issues.

### Error Codes

[](#debugging-error-codes)

The Aave protocol uses specific error codes to indicate why a transaction failed. Understanding these codes is essential for debugging. The error codes for each Aave protocol version are defined in their respective Errors.sol files:

*   **Aave V3 Error Codes**: [Errors.sol](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/libraries/helpers/Errors.sol)
    
*   **Aave V2 Error Codes**: [Errors.sol](https://github.com/aave/protocol-v2/blob/master/contracts/protocol/libraries/helpers/Errors.sol)
    

### Debugging Tools

[](#debugging-debugging-tools)

To effectively debug transactions, you can use tools like **Tenderly**, **Hardhat**, and **Foundry**. These tools allow you to simulate transactions, inspect state changes, and step through execution to identify issues.

#### Tenderly

[](#debugging-debugging-tools-tenderly)

Tenderly allows you to simulate transactions and debug them step-by-step. By inputting the transaction details (to, from, data, and value), you can simulate the call and identify the cause of any revert, including error codes and stack traces.

#### Hardhat

[](#debugging-debugging-tools-hardhat)

Hardhat provides a local Ethereum environment for testing and debugging. It offers features like console logs in Solidity, detailed stack traces, and the ability to fork mainnet state for testing.

#### Foundry

[](#debugging-debugging-tools-foundry)

Foundry is a fast, portable, and modular toolkit for Ethereum application development. It includes tools like Forge for testing and debugging smart contracts, allowing you to simulate and debug transactions effectively.

#### Understanding "Gas Estimation Failed"

[](#debugging-debugging-tools-understanding-gas-estimation-failed)

The "Gas estimation failed" error is a generic message indicating that the transaction would fail if executed. To diagnose this issue:

1.  Use the transaction's to, from, data, and value fields.
    
2.  Simulate the transaction using one of the debugging tools mentioned above.
    
3.  Identify the specific error code or exception causing the failure.
    
4.  Examine the stack trace to pinpoint the issue.
    

### Common Errors

[](#debugging-common-errors)

#### Aave V3 Pool

[](#debugging-common-errors-aave-v3-pool)

When interacting with the Aave V3 Pool, you may encounter issues related to token approvals, insufficient collateral, or reaching protocol limits.

##### ERC-20 Token Approval for Supply and Repay

Before supplying or repaying tokens, ensure that you have granted the Aave Pool contract an allowance to transfer tokens. This is performed by calling the approve function on the ERC-20 token contract to authorize the Pool as the spender.

##### Insufficient Collateral

If you're unable to borrow assets, it may be due to insufficient collateral or not meeting the required Loan-to-Value (LTV) ratios. Ensure that you have supplied enough collateral and that it satisfies the protocol's requirements.

##### Borrow Cap Reached

Sometimes, you may not be able to borrow a specific asset because the borrow cap has been reached. In this case, you may need to wait for borrowers to repay or supply more liquidity to the pool.

For more detailed explanations of potential revert cases, refer to this [DeFi Integration Guide](https://github.com/Walodja1987/DeFi-Integration-Guide/blob/main/AaveV3.1.md).

##### Loan To Value = 0%

When an Aave [reserve](https://aave.com/docs/primitives/reserve) has a Loan To Value (LTV) parameter configured to 0%, commonly referred to as **LTV0**, it impacts reserve interactions in several ways:

*   **Borrowing power**: Any existing collateral of this asset will no longer contribute to borrowing power.
    
*   **Collateral status**: The asset can no longer be enabled as collateral.
    
*   **Transfers**: If received via transfer, the asset will not be automatically enabled as collateral.
    
*   **Withdrawals**: Assets with LTV0 must be disabled as collateral (using Pool.setUserUseReserveAsCollateral or by fully withdrawing the supplied balance) before other assets can be withdrawn.
    

#### WrappedTokenGateway

[](#debugging-common-errors-wrappedtokengateway)

When interacting with Ether (ETH) in the Aave protocol, the WrappedTokenGateway is used to wrap ETH into WETH and vice versa. Common issues may include not sending ETH with the transaction when required or using incorrect functions for depositing or withdrawing ETH.

For detailed usage and potential revert causes, refer to the [WrappedTokenGateway documentation](https://aave.com/docs/developers/smart-contracts/wrapped-token-gateway).</content>
</page>

<page>
  <title>Changelog</title>
  <url>https://aave.com/docs/resources/changelog</url>
  <content>[](#changelog)

Aave v3.2
---------

[](#aave-v32)

**October 8, 2024**

Introduces "Liquid eModes," allowing assets to be listed in multiple eModes, alongside the removal of legacy stable rate logic.

Aave v3 ZKsync Era Market
-------------------------

[](#aave-v3-zksync-era-market)

**September 20, 2024**

Aave v3 market deploys on ZKsync Era.

Aave v3 EtherFi Market
----------------------

[](#aave-v3-etherfi-market)

**September 9, 2024**

Aave v3 market deploys on Ethereum, optimized for EtherFi collateral assets.

Aave v3 Ethereum Lido Market (Prime Market)
-------------------------------------------

[](#aave-v3-ethereum-lido-market-prime-market)

**July 29, 2024**

Aave v3 market deploys on Ethereum optimized for blue-chip collaterals and high-leverage, correlated assets.

Aave v3.1
---------

[](#aave-v31)

**July 27, 2024**

Introduces security and operational improvements to protocol smart contracts.

GHO Cross-Chain
---------------

[](#gho-cross-chain)

**July 2, 2024**

Introduces a GHO facilitator that enables cross-chain bridging to Arbitrum powered by Chainlink CCIP.

Aave v3 Scroll Market
---------------------

[](#aave-v3-scroll-market)

**February 9, 2024**

Aave v3 market deploys on Scroll zkEVM Layer 2.

GHO Stability Module
--------------------

[](#gho-stability-module)

**January 29, 2024**

Introduces a GHO facilitator that supports the conversion of GHO with governance-approved assets at pre-determined ratios to maintain peg stability.

Aave v3 BNB Chain Market
------------------------

[](#aave-v3-bnb-chain-market)

**January 23, 2024**

Aave v3 market deploys on BNB Chain.

Aave Governance v3
------------------

[](#aave-governance-v3)

**December 25, 2023**

Enhances Aave protocol governance, enabling voting on low-cost networks and improving efficiency of cross-chain proposals.

Aave v3 Gnosis Market
---------------------

[](#aave-v3-gnosis-market)

**November 6, 2023**

Aave v3 market deploys on Gnosis Chain.

Aave v3 Base Market
-------------------

[](#aave-v3-base-market)

**August 16, 2023**

Aave v3 deploys on Base, Coinbase’s Layer 2 network built on the OP Stack.

GHO Stablecoin
--------------

[](#gho-stablecoin)

**July 16, 2023**

Launches GHO, Aave’s native decentralized stablecoin.

Aave v3.0.2
-----------

[](#aave-v302)

**May 6, 2023**

Updates the Aave V3 codebase, addressing security and usability improvements.

Aave v3 Metis Market
--------------------

[](#aave-v3-metis-market)

**March 17, 2023**

Aave v3 deploys on the Metis Layer 2 network.

Aave v3 Ethereum Core Market
----------------------------

[](#aave-v3-ethereum-core-market)

**January 27, 2023**

Aave v3 deploys on Ethereum, bringing the latest protocol innovations to mainnet. The Core market serves as the most liquid and risk-adjusted environment for a diverse range of assets.

Aave v3
-------

[](#aave-v3)

**March 16, 2022**

A new iteration of the Aave Protocol, introducing new features such as efficiency mode and enhanced risk measures with isolation mode, supply caps, and borrow caps.

Aave v2 Avalanche Market
------------------------

[](#aave-v2-avalanche-market)

**October 4, 2021**

Aave v2 deploys on the Avalanche C-Chain network.

Aave v2 Polygon Market
----------------------

[](#aave-v2-polygon-market)

**April 14, 2021**

Aave v2 deploys on Polygon (formerly Matic), the first protocol deployment outside of Ethereum mainnet.

Aave Governance v2
------------------

[](#aave-governance-v2)

**December 16, 2020**

Enhances on-chain protocol governance, enabling the Aave community to propose, vote, and trustlessly execute protocol changes.

Aave v2
-------

[](#aave-v2)

**December 3, 2020**

Aave v2 greatly enhances protocol efficiency with reduced gas costs and new features such as collateral switch and batch flash loans.

Aave Governance v1
------------------

[](#aave-governance-v1)

**October 29, 2020**

Introduces the first version of Aave’s governance mechanism, enabling the community to propose and vote on protocol updates.

Aave v1
-------

[](#aave-v1)

**January 8, 2020**

The first iteration of the Aave Protocol launches on Ethereum mainnet, introducing decentralized liquidity pools, allowing users to supply and borrow various assets via smart contracts.</content>
</page>

<page>
  <title>Code Licensing</title>
  <url>https://aave.com/docs/resources/code-licensing</url>
  <content>[](#code-licensing)

The Aave Protocol operates on decentralized blockchain networks, with smart contracts that are self-executing and publicly auditable. These smart contracts and peripheral interfaces are licensed to define and regulate the use of the underlying code. The code exists across multiple GitHub repositories, and below are examples of some key licenses that apply to different Aave components:

*   **Aave v3.2 Smart Contracts**: Business Source License 1.1 permits non-commercial use and modification, restricting competitive use for four years, with a transition to the MIT License on March 6, 2027​. ([GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/LICENSE))
    
*   **Governance v3**: Business Source License 1.1 permits non-commercial use and modification, restricting competitive use for four years, with a transition to the MIT License on July 27, 2027.​ ([GitHub](https://github.com/bgd-labs/aave-governance-v3/blob/main/LICENSE))
    
*   **Safety Module**: Business Source License 1.1 permits non-commercial use and modification, with competitive restrictions, transitioning to the MIT License on January 8, 2028.​ ([GitHub](https://github.com/bgd-labs/stake-token/blob/main/LICENSE))
    
*   **GHO Stablecoin**: MIT License grants free and unrestricted rights to use, copy, modify, and distribute the software, provided the original copyright notice and license are included. The software is provided "as is," with no warranties or liabilities for any issues arising from its use. ([GitHub](https://github.com/aave/gho-core/blob/main/LICENSE))
    
*   **Aave v2 Smart Contracts**: GNU Affero General Public License ([GitHub](https://github.com/aave/protocol-v2/blob/master/LICENSE.md))
    
*   **Aave v1 Smart Contracts**: GNU Affero General Public License ([GitHub](https://github.com/aave/aave-protocol/blob/master/LICENSE.md))
    
*   **Aave Labs Interface**: All Rights Reserved. ([GitHub](https://github.com/aave/interface/blob/main/LICENSE.md))</content>
</page>

<page>
  <title>Web3</title>
  <url>https://aave.com/docs/resources/web3</url>
  <content>[](#web3)

Web3 is the next evolution of the internet where people have control and ownership over their data, the relationships they form online, and their user profile. Together, these make up "social capital": Everyone has it, and it's valuable. In contrast, today when we go on the internet, we visit sites owned by large companies, who own our social capital. These "web2" companies like Amazon, Facebook and Google store user data on privately-held servers and sell it to advertisers in exchange for providing free services. This has led to a good experience for users (free, easy-to-use networks and applications), but it has also caused privacy issues, data manipulation, and limited monetisation options. Web3 addresses these issues by using blockchain technology. This technology is based on user ownership. When people own their data, they can monetise however they want, take their digital information with them (profile, content, data) when they switch networks, and it has the benefit of putting people and apps/networks on an equal footing. Web3 enables a more open and balanced internet, where people have a stake and voice in the future of the internet.

To understand the significant difference between the internet we know today (web2) and web3, take a step back.

When the internet first came about, it was hard to access because there were no easy-to-use applications. Web1 was built on open, public protocols or applications such as TCP, IP, SMTP, and HTTP that builders could develop on top of, plugging into these open protocols to create whatever applications or platforms they wanted. Nobody needed permission to use these foundational protocols or standards to build user-friendly applications like email browsers and marketplaces. These standards are the basic building blocks of the internet. They govern how computers interact with each other and the flow of information. Today, in many senses, we are locked into platforms that own our data.

Blockchain
----------

[](#blockchain)

A blockchain is a decentralised, distributed ledger system designed to record and verify transactions across a network of computers. This compels that no single entity or company controls the entire network, promoting a system of collective agreement and transparency. Unlike traditional databases that rely on central authorities (private servers owned by companies who set all the rules and make all the decisions), blockchains operate on a peer-to-peer network where every participant, known as nodes, has access to the entire ledger (the information is spread across multiple nodes or computers and each has an entire copy of the information). This decentralisation enhances both security and transparency, as each transaction is visible to all participants and cannot be altered without consensus (all nodes agreeing) from the network.

The core of blockchain technology lies in its unique distributed or decentralised structure. Transactions are grouped into units called "blocks." Each block contains a list of transactions that have been validated (consensus) by the network. Once a block is filled with transactions, it is added to the existing chain of blocks in a sequential manner that is time stamped. This process creates a continuous, unalterable chain of blocks, hence the name "blockchain." Each block contains a reference to the previous block, forming a chronological sequence. This structure makes it extremely difficult to alter any information in a block without changing all subsequent blocks, which would require the consensus of the majority of the network.

Smart Contracts
---------------

[](#smart-contracts)

Smart contracts are self-executing programs that operate deterministically. When an address interacts with a smart contract, the contract executes the agreed-upon actions, such as transferring assets or updating internal accounting. This automation eliminates the need for intermediaries, making transactions more efficient and reducing the potential for human error or manipulation. By relying on code rather than third parties, smart contracts enable trustless and transparent operations, where all parties involved have confidence in the outcome.

Smart contracts are integral to many blockchain applications, as they are executed by blockchain networks like Ethereum, which functions as a global computer network. These networks process and validate the conditions set within each smart contract, updating the state of the contract with every new block added to the chain. This decentralised execution validates that smart contracts run precisely as programmed, without the risk of interference or manipulation. The combination of immutability and public auditability (transparency) in smart contracts provides a high level of trust and security, making them a foundational element in the development of decentralised applications such as identity, finance, and more.

DeFi
----

[](#defi)

Decentralised Finance, or DeFi, leverages blockchains and smart contracts to create an open, transparent, and decentralised financial ecosystem. At its core, DeFi aims to improve upon traditional financial systems without the reliance on centralised institutions such as banks, brokers, and financial intermediaries. DeFi offers a novel approach to financial applications, marked by increased accessibility, transparency, and control for users.

DeFi operates on blockchain networks, with Ethereum being the first and most prominent platform. Most of these DeFi applications are now also deployed on Layer 2 blockchains, such as Arbitrum, Optimism, and ZKSync. Unlike traditional financial systems that rely on intermediaries to process and verify transactions, DeFi uses decentralised networks to perform these functions. By removing intermediaries, DeFi aims to lower costs, reduce barriers to entry, and enhance the efficiency of financial transactions.

Stablecoins
-----------

[](#stablecoins)

Stablecoins are digital assets that aim to keep their value constant relative to a reference asset, most commonly fiat currencies like the U.S. dollar, euro, or yen. Unlike Bitcoin or Ethereum, whose values can fluctuate significantly, stablecoins are designed to be predictable and stable, making them useful for everyday transactions, remittances, and as a safe haven during market turbulence.

Stablecoins bridge the gap between traditional finance and the crypto world. They allow users to transfer value globally without major price fluctuations. Here are a few key uses:

*   Remittances: Sending money across borders can be costly and slow. Stablecoins enable faster and cheaper transactions.
    
*   DeFi (Decentralised Finance): Stablecoins are crucial in the DeFi ecosystem, where they are used for supplying, borrowing, and earning interest.
    
*   Hedging: Traders and investors use stablecoins to move out of volatile assets without converting back to fiat.
    
*   Payments: Merchants can accept stablecoins for goods and services without price volatility.
    

Stablecoins achieve stability through various mechanisms:

*   Fiat-collateralised Stablecoins: These are backed by reserves of fiat currency held in a bank account. For every stablecoin issued, an equivalent amount of fiat currency is held in reserve. Examples include Tether (USDT) and USD Coin (USDC).
    
*   Decentralised Stablecoins: These operate without a central authority and are typically issued, redeemed, and governed by smart contracts on a blockchain. Smart contracts can manage the collateral requirements and issuance based on predefined rules in a trustless and transparent process. Aave’s GHO is one example of this kind of stablecoin.
    
*   Algorithmic Stablecoins: These rely on smart contracts and algorithms to maintain their peg. Instead of being backed by reserves, these stablecoins use mechanisms like minting and burning to control the supply and stabilise the price.</content>
</page>

<page>
  <title>Glossary</title>
  <url>https://aave.com/docs/resources/glossary</url>
  <content>aTokensInterest-bearing tokens received by users when they supply assets to Aave. aTokens represent the user’s share of the liquidity pool and accrue interest in real-time.APYAnnual Percentage Yield, which is the yield/interest after a year, including compounding interest. This differs from APR, which does not account for compounding effects.Borrow CapA limit set by Aave Governance on the maximum amount of an asset that can be borrowed from the protocol. This helps manage exposure and risk associated with each asset.CollateralAn asset supplied to Aave to secure a borrowing position. The collateral must exceed the value of the borrowed amount to ensure the protocol's solvency.Cooldown PeriodA mandatory waiting period that stakers must observe before they can unstake their tokens from the Safety Module.Credit DelegationA feature where users can delegate their borrowing power to another user who can then take out loans using the collateral of the delegator. This is facilitated through the Aave Protocol's smart contracts.Debt CeilingThe maximum amount of debt that can be issued against an isolated asset. Used to limit the risk exposure to a single collateral type.E-ModeEfficiency Mode allows borrowers to extract higher borrowing power when using correlated assets (e.g., stablecoins).Flash LoanA type of uncollateralized loan offered by Aave, which must be borrowed and repaid within one transaction block.GHOA decentralized, overcollateralized stablecoin that is fully backed, transparent, and native to the Aave Protocol. It is governed and managed by the Aave DAO.Governance PowerRefers to the ability to create proposals or vote in Aave’s governance system, based on AAVE, stkAAVE, or aAAVE token holdings.Health FactorA ratio that determines the health of a user's loan position. It compares the value of the user's collateral to their borrowed assets. A health factor below 1 triggers liquidation.Isolation ModeA feature in Aave V3 that limits borrowers to borrowing only certain stablecoins when using assets marked as isolated. It helps mitigate risk by restricting the total debt exposure to a single asset.LiquidationThe process that occurs when a borrower’s health factor drops below 1, resulting in the sale of collateral to repay part of the debt and bring the position back to a safer level.Liquidation BonusThe bonus provided to liquidators as an incentive to purchase undercollateralized assets in a liquidation event. It is expressed in percentage points.Liquidation ThresholdThe point at which a loan becomes eligible for liquidation due to insufficient collateral relative to borrowed funds. The threshold is defined per asset and determines the collateral value required to maintain a position.Liquidity IndexTracks the cumulative interest earned by a reserve over time, used to calculate accurate interest payments.Loan To Value (LTV)The maximum percentage of a collateral asset's value that can be borrowed. For example, an LTV of 75% means that for every 1 ETH of collateral, 0.75 ETH can be borrowed.Network RiskRisks associated with the blockchain networks on which Aave operates, such as congestion, security vulnerabilities, or network failures.OracleA service used by Aave to fetch external data, such as the prices of assets, which is critical for determining the value of collateral and debt.PortalA cross-chain liquidity feature in Aave V3 allowing liquidity to flow between Aave markets on different blockchains. This is made possible through governance-approved bridges.Ray unitsA unit of measurement with 27 decimals, used by Aave for internal calculations to ensure precision, particularly for rates and exchange values.Reserve FactorA percentage of interest accrued by borrowers that is allocated to the Aave Treasury to help safeguard the protocol.Risk AdminAn entity or automated system responsible for adjusting risk parameters in Aave without going through a governance vote. This allows Aave to respond quickly to unforeseen risks.Safety ModuleA staking mechanism where AAVE tokens are staked to act as insurance in case of a shortfall event. Stakers earn rewards but are also exposed to slashing risk.Siloed BorrowingA feature in Aave V3 that restricts certain assets to being borrowed alone, mitigating the risk of price manipulation or illiquid assets affecting the protocol's solvency.Supply CapA limit set on the total amount of a particular asset that can be supplied to the Aave protocol.Utilization RateA metric that determines the proportion of borrowed assets to the total available assets in a reserve. A higher utilization rate indicates higher borrowing demand.Voting PowerThe amount of influence a user has in governance decisions, determined by the amount of AAVE, stkAAVE, or aAAVE they hold.</content>
</page>

<page>
  <title>Dashboards</title>
  <url>https://aave.com/docs/resources/dashboards</url>
  <content>[](https://aave.com/docs)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>Parameters Dashboard</title>
  <url>https://aave.com/docs/resources/parameters</url>
  <content>[](https://aave.com/docs)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>Addresses Dashboard</title>
  <url>https://aave.com/docs/resources/addresses</url>
  <content>[](https://aave.com/docs)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>Privacy Policy</title>
  <url>https://aave.com/privacy-policy</url>
  <content>**The Aave Protocol operates in a decentralized and permissionless manner. Although we may collect and process information about users of Aave.com or the Interface in accordance with this Privacy Policy, we do not have information about all protocol users beyond what is already publicly available and recorded on the blockchain.**

This Privacy Policy (the "Privacy Policy") explains how the Aave Labs ("we," "our," or "us") collects, uses, and shares information in connection with our Services as well as your rights and choices regarding such information. These terms apply to Aave.com and the Interface and any other online location that links to this Privacy Policy (collectively, the "Services").

By using the Services, you also agree to our collection, use, and sharing of your information as described in this Privacy Policy. If you do not agree with the Terms of Use, you should not use or access the Interface or the Services.

### 1\. Information Collection

**A. Information You Provide.**

We may collect the following information about you when you use the Services:

*   **Correspondence and Content:** Within any messages you send to us (such as feedback and questions to information support), we may collect your name and contact information, as well as any other content included in the message.

You may choose to voluntarily provide other information to us that we have not solicited from you, and, in such instances, you are solely responsible for such information.

**B. Information Collected Automatically.**

We collect the following information:

*   **Wallet Address:** We may collect the wallet address you use to connect to the Interface to block wallets that are associated with certain legally prohibited conduct from Interface. Separately, we may collect your wallet address as part of "Usage Information" (as described below) to improve the Interface and user experience of the Services.
    
*   **Device Information:** We may collect information about the device you use to access the Interface, such as the device type, operating system, browser type, and screen height and width. This information helps us optimize the Interface for different devices and troubleshoot any technical issues.
    
*   **Usage Information:** We may collect information about how you use the Interface and Services, including your wallet address, the time you access the Interface, pages you visit, the features and assets you interact with, the links you click, and the search queries you make. By analyzing this data, we gain a deeper understanding of user behavior, which in turn allows us to make continuous improvements to the Interface and enhance the overall user experience.
    

For further information on how we use tracking technologies for analytics and your rights and choices regarding them, please see the "Cookies Policy" and "Analytics" sections below.

### 2\. Use of Information

We may collect and use information for business purposes in accordance with the practices described in this Privacy Policy. Our business purposes for collecting and using information include:

*   **Operating and managing the Services (including through authorized service providers):** To make the Services available to you and perform services requested by you, such as responding to your comments, questions, and requests, and providing information support; sending you technical notices, updates, security alerts, information regarding changes to our policies, and support, administrative messages; detecting, preventing, and addressing fraud, breach of Terms, and threats, or harm; and compliance with legal and regulatory requirements.
    
*   **Improving the Services:** To continually improve the Services and fulfill any other legitimate business purpose, as permitted under applicable laws.
    
*   **Merger or Acquisition:** In connection with, or during negotiations of, any proposed or actual merger, purchase, sale, or any other type of acquisition, financing, reorganization, or business combination of all or any portion of our assets, or transfer of all or a portion of our business to another business.
    
*   **Security and Compliance with Laws:** As we believe necessary or appropriate to operate and maintain the security or integrity of the Interface, including to prevent or stop an attack on our computer systems or networks, investigate possible wrongdoing in connection with the Interface, enforce our Terms, and comply with applicable laws, lawful requests, and legal process, such as responding to subpoenas or requests from government authorities.
    
*   **Facilitating Requests:** To comply with your requests or directions.
    
*   **Consent:** Purposes for which we have obtained your consent, as required by applicable laws.
    

Notwithstanding the above, we may use information that does not identify you (including information that has been aggregated or de-identified) for any purpose except as prohibited by applicable law. For information on your rights and choices with respect to how we use information about you, please see the "Analytics" section below.

### 3\. Sharing and Disclosure of Information

We may share or disclose information that we collect in accordance with the practices described in this Privacy Policy and for the purposes set out in the "Use of Information" section above.

The categories of parties with whom we may share information include:

*   **Affiliates:** We share information with our affiliates and related entities, including where they act as our service providers or for their own internal purposes.
    
*   **Professional Advisors:** We share information with our professional advisors for purposes of audits and compliance with our legal obligations.
    
*   **Service Providers:** We share information with third-party service providers for business purposes, including fraud detection and prevention, security threat detection, data analytics, information technology and storage, and blockchain transaction monitoring. Any information shared with such service providers is subject to the terms of this Privacy Policy. All service providers that we engage with are restricted to only utilizing the information on our behalf and in accordance with our instructions.
    

Notwithstanding the above, we may share information that does not identify you (including information that has been aggregated or de-identified) except as prohibited by applicable law.

### 4\. Third-Party Services

We may also integrate technologies operated or controlled by other parties into parts of the Services. For example, the Services may include links that hyperlink to websites, platforms, and other services not operated or controlled by us.

Please note that when you interact with other parties, including when you leave the Interface, those parties may independently collect information about you and solicit information from you. The information collected and stored by those parties remains subject to their own policies and practices, including what information they share with us, your rights and choices on their services and devices, and whether they store information in the U.S. or elsewhere. We encourage you to familiarize yourself with and consult their privacy policies and terms of use.

For example, by using a third-party wallet to engage in transactions on public blockchains, your interactions with any third-party wallet provider are governed by the applicable terms of service and privacy policy of that wallet provider.

### 5\. Cookies Policy

We understand that your privacy is important to you and are committed to being transparent about the technologies we use. In the spirit of transparency, this Cookies Policy provides detailed information about how and when we use cookies on our Services.

**A. Do we use cookies?**

We do not use cookies. If we were, we would use cookies and other technologies to understand how you use our Interface so we can improve its design and functionality (to ensure everyone who uses the Interface has the best possible experience).

**What is a cookie?**

A cookie is a small text file that is placed on your hard drive by a web page server. Cookies contain information that can later be read by a web server in the domain that issued the cookie to you. Some of the cookies will only be used if you use certain features or select certain preferences, and some cookies will always be used. You can find out more about each cookie by viewing our current cookie list below. We update this list periodically, so there may be additional cookies that are not yet listed.

**B. Why would we use cookies?**

We use cookies and other similar identifiers only to compile aggregate data about Interface traffic and site interaction to offer better user experiences and tools in the future.

**C. What types of cookies do we use?**

*   **Strictly Necessary Cookies:** These cookies are essential for the Interface to function properly and enable basic features such as page navigation and access to secure areas of the site. They do not collect personal information.
    
*   **Analytical/Performance Cookies:** These cookies allow us to analyze how visitors use the Interface, which helps us improve its functionality and performance.
    
*   **Functional Cookies:** These cookies enable enhanced functionality and personalization of the website. They may remember your preferences, such as the wallet you previously used to connect.
    

**D. How to disable cookies?**

Users can generally activate or later deactivate the use of cookies through a functionality built into your web browser. If you want to learn more about cookies, or how to control, disable, or delete them, please visit [http://www.aboutcookies.org](http://www.aboutcookies.org/) for detailed guidance.

### 6\. Analytics

We utilize the Mixpanel (on the Aave Interface) and Fathom Analytics (on Aave.com) as the analytics platforms to track user interactions, preferences, and behavior during browsing sessions for users who have opted in for analytics. This data helps us improve our services and analyze trends in our user base. We respect your right to control the data collected during your browsing session. If you prefer not to participate in our tracking techniques and data collection, you can opt-out through the "Manage Analytics" section on this page or adjust your browser settings or use browser extensions designed for this purpose.

### 7\. Data Security

We implement and maintain reasonable administrative, physical, and technical security safeguards to help protect information about you from loss, theft, misuse, unauthorized access, disclosure, alteration, and destruction. Nevertheless, transmission via the Internet is not completely secure and we cannot guarantee the security of information about you.

### 8\. Data Retention

Please note that we retain information we collect as long as it is necessary to fulfill the purpose for which it was collected, as outlined in this Privacy Policy, and to the extent permitted by applicable legal requirements. Where you request the deletion of your information, we may continue to retain and use your information as permitted or required under applicable laws, for legal, tax, or regulatory reasons, or legitimate and lawful business purposes.

### 9\. International Transfers

Please be aware that information collected through the Services may be transferred to, processed, stored, and used in the European Economic Area, the United Kingdom, and other jurisdictions. Data protection laws in the EU and other jurisdictions may be different from those of your country of residence. Your use of the Services or provision of any information therefore constitutes your consent to the transfer to and from, processing, usage, sharing, and storage of information about you in the EU and other jurisdictions as set out in this Privacy Policy.

### 10\. Children

The Services are intended for general audiences and are not directed at children. To use the Services, you must legally be able to enter into the Agreement. We do not knowingly collect personal information (as defined by the U.S. Children's Privacy Protection Act, or "COPPA") from children. If you are a parent or guardian and believe we have collected personal information in violation of COPPA, please contact us at [\[email protected\]](https://aave.com/cdn-cgi/l/email-protection#1e697b7d7f6c7b5e7f7f687b307d7173) and we will remove the personal information in accordance with COPPA.

### 11\. Additional Disclosures for California Residents

These additional disclosures apply only to California residents. The California Consumer Privacy Act of 2018 ("CCPA") provides additional rights to know, delete, and opt-out, and requires businesses collecting or disclosing personal information to provide notices and the means to exercise consumer rights.

**A. Notice of Collection**

For further details on the information we may collect, including the sources from which we receive information, review the "Information Collection" section above. We may collect and use these categories of personal information for the business purposes described in the "Use of Information" section above, including to manage the Services.

We do not "sell" personal information as defined under the CCPA. Please review the "Sharing and Disclosure of Information" section above for further details about the categories of parties with whom we share information.

**B. Right to Know and Delete**

You have the right to know certain details about our data practices within the past twelve (12) months. In particular, you may request the following from us:

*   The categories of personal information we have collected about you;
*   The categories of sources from which the personal information was collected;
*   The categories of personal information about you we disclosed for a business purpose;
*   The categories of third parties to whom the personal information was disclosed for a business purpose;
*   The business or commercial purpose for collecting or selling the personal information; and
*   The specific pieces of personal information we have collected about you.

In addition, you have the right to delete the personal information we have collected from you.

To exercise any of these rights, please submit a request by emailing us at [\[email protected\]](https://aave.com/cdn-cgi/l/email-protection#f98e9c9a988b9cb998988f9cd79a9694). In the request, please specify which right you are seeking to exercise and the scope of the request. We will confirm receipt of your request within ten (10) days. We may require specific information from you to help us verify your identity and process your request. If we are unable to verify your identity, we may deny your requests to know or delete.

**C. Authorized Agent**

You may designate an authorized agent to submit requests on your behalf; however, we may require written proof of the agent's permission to act on your behalf and verify your identity directly.

**D. Right of Non-Discrimination**

You have a right of non-discrimination for the exercise of any of your privacy rights guaranteed by law, such as the right to access, delete, or opt-out of the sale of your personal information.

**E. Shine the Light**

Customers who are residents of California may request (i) a list of the categories of personal information disclosed by us to third parties during the immediately preceding calendar year for those third parties' own direct marketing purposes; and (ii) a list of the categories of third parties to whom we disclosed such information. To exercise a request, please write to us at the email or postal address set out in the "Contact Us" section above and specify that you are making a "California Shine the Light Request." We may require additional information from you to allow us to verify your identity and are only required to respond to requests once per calendar year.

### 12\. Additional Disclosures for Data Subjects in the European Economic Area and the United Kingdom

**A. Roles**

The General Data Protection Regulations in the European Economic Area and General Data Protection Regulations in the United Kingdom ("GDPR") distinguish between organizations that process personal data for their own purposes (known as "controllers") and organizations that process personal data on behalf of other organizations (known as "processors"). We act as a controller with respect to personal data collected as you interact with the Services.

**B. Lawful Basis for Processing**

The GDPR requires a "lawful basis" for processing personal data. Our lawful bases include where:

*   **Consent:** You have given consent to the processing of your personal data for one or more specific purposes, either to us or to our service providers or partners.
*   **Contractual Necessity:** Processing your personal data is necessary for the performance of a contract between you and us.
*   **Legal Obligation:** Processing your personal data is necessary for compliance with a legal obligation.
*   **Legitimate Interests:** Processing your personal data is necessary for the purposes of the legitimate interests pursued by us or a third party, provided that your interests and fundamental rights and freedoms do not override those interests.

Where applicable, we will transfer your personal data to third parties subject to appropriate or suitable safeguards, such as standard contractual clauses.

| Purpose | Legal Basis |
| --- | --- |
| Operating and managing the Services | Necessary for the performance of our agreement |
| To communicate with you | Necessary for the performance of our agreement |
| Improving the Services | Legitimate interests, Consent |
| To provide our Services | Legitimate interests, Consent |
| Merger or Acquisition | Legitimate interests, legal obligation (when communicating with EEA, U.K., and Swiss regulatory bodies) |
| Security and compliance with laws | Legal obligation, legitimate interests, necessary for the performance of our agreement |
| Other purposes for which we have obtained consent | Consent |

**C. Your Data Subject Rights**

If you are a user in the European Economic Area or the United Kingdom, you maintain certain rights under the GDPR. These rights include the right to:

*   Request access and obtain a copy of your personal data;
*   Request rectification or erasure of your personal data;
*   Object to or restrict the processing of your personal data;
*   Request portability of your personal data.

Additionally, if we have collected and processed your personal data with your consent, you have the right to withdraw your consent at any time.

Notwithstanding the foregoing, we cannot edit or delete information that is stored on a particular blockchain. This information may include transaction data (i.e., purchases, sales, and transfers) related to your blockchain wallet address and any items held by your wallet address.

To exercise any of these rights, please contact us via our email or postal address listed in the "Contact Us" section above and specify which right you are seeking to exercise. We will respond to your request within thirty (30) days. We may require specific information from you to help us confirm your identity and process your request. Please note that we retain information as necessary to fulfill the purpose for which it was collected and may continue to retain and use information even after a data subject request in accordance with our legitimate interests, including as necessary to comply with our legal obligations, resolve disputes, prevent fraud, and enforce our agreements.

If you have any issues with our compliance, please contact us as set out in the "Contact Us" section above. You also reserve the right to lodge a complaint with the data protection regulator in your jurisdiction.

### 13\. Changes to this Privacy Policy

We reserve the right to revise and reissue this Privacy Policy at any time. Any changes will be effective immediately upon our posting of the revised Privacy Policy. For the avoidance of doubt, your continued use of the Services indicates your consent to the revised Privacy Policy then posted.

### 14\. Contact Us

If you have any questions or comments about this Privacy Policy, our data practices, or our compliance with applicable law, please contact us by email: [\[email protected\]](https://aave.com/cdn-cgi/l/email-protection#c7b0a2a4a6b5a287a6a6b1a2e9a4a8aa).</content>
</page>

<page>
  <title>Access Controls Dashboard</title>
  <url>https://aave.com/docs/resources/access-controls</url>
  <content>[](https://aave.com/docs)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>Terms of Service</title>
  <url>https://aave.com/terms-of-service</url>
  <content>### 1\. Welcome to Aave.com and the Interface!

These Terms of Use ("Terms") govern your access to and use of both the Aave.com website (referred to as "Aave.com") and App.aave.com interface (referred to as the "Interface") collectively referred to as the "Services." The Services are brought to you by the Aave Labs ("we," "us," or "our").

**Aave.com** provides information and resources about the fundamentals of the decentralized non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). The Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.

**The Interface,** which is hosted on IPFS, is an independent interface providing one of the available applications through which users, via their self-custodial wallets, interact with the Aave Protocol.

**ARBITRATION NOTICE:** THESE TERMS CONTAIN AN ARBITRATION CLAUSE BELOW. EXCEPT FOR CERTAIN TYPES OF DISPUTES MENTIONED IN THAT ARBITRATION CLAUSE, YOU AND WE AGREE THAT ANY DISPUTES RELATING TO THE SERVICES (AS DEFINED BELOW) WILL BE RESOLVED BY MANDATORY BINDING ARBITRATION, AND YOU WAIVE ANY RIGHT TO A TRIAL BY JURY OR TO PARTICIPATE IN A CLASS-ACTION LAWSUIT OR CLASS-WIDE ARBITRATION.

**You are entering into a binding Agreement.**

BY ACCESSING OR USING OUR SERVICES, WHICH INCLUDE OUR VARIOUS WEBSITES, INCLUDING, WITHOUT LIMITATION, AAVE.COM AND APP.AAVE.COM (AND ANY RESPECTIVE SUBDOMAINS); APPLICATIONS, AND OTHER SERVICES THAT LINK TO THESE TERMS, AS WELL AS ANY INFORMATION, TEXT, LINKS, GRAPHICS, PHOTOS, AUDIO, VIDEO, OR OTHER MATERIALS STORED, RETRIEVED OR APPEARING THEREON, WHETHER ACCESSED THROUGH THE SITE OR OTHERWISE (COLLECTIVELY, THE "SERVICES"), YOU ARE ENTERING INTO A BINDING AGREEMENT WITH US THAT INCLUDES THESE TERMS, PRIVACY POLICY (FOUND HERE), AND OTHER POLICIES REFERENCED HEREIN (COLLECTIVELY, THE "AGREEMENT").

To the extent that there is a conflict between these Terms and any applicable additional terms, these Terms will control unless expressly stated otherwise. If you don't agree with these Terms, you may not use the Services and should not visit the Site or otherwise engage with the Services.

### Use of the Services

To use the Services, you must legally be able to enter into the Agreement. By using the Services, you represent and warrant that you meet the eligibility requirement. If you do not meet the requirement, you must not access or use the Site or the Services.

**We may update the Services and the Terms.**

We may change or update the Services, the Agreement, and any part of the Terms at any time, for any reason, at our sole discretion. Once any part of the Agreement is updated and in effect, you will be bound by the Terms if you continue to use the Services. We may, at any time, and without liability to you, modify or discontinue all or part of the Services (including access to the Services via any third-party links).

### 2\. Services

**Aave.com is an informational resource about the Protocol; however, it is not the exclusive or sole source.**

All information provided in connection with your access and use of the Services is intended for informational purposes only. While we strive to provide accurate and reliable information, we cannot guarantee the accuracy, completeness, or timeliness of the information provided. It is possible that the information may be outdated or subject to errors or omissions. The codebases of all the versions of the Aave Protocol are maintained on each full network node of the relevant blockchain. You should not take, or refrain from taking, any action based on any information contained on Aave.com, including, without limitation, the docs.aave.com ("Developer Docs") or any other information that we make available at any time, including blog posts, data, articles, links to third-party content, Discord content, news feeds, tutorials, tweets, and videos. You further acknowledge and agree that we will not be responsible or liable, directly or indirectly, for any damage or loss caused or alleged to be caused by or in connection with the use of or reliance on any such content, goods, or services available on or through any such site or resource.

**Users retain full control over their cryptoassets.**

It is important to understand that neither we nor any affiliated entity is a party to any transaction on the blockchain networks underlying the Aave Protocol; we do not have possession, custody or control over any cryptoassets, or any user's funds. You understand that when you interact with Aave Protocol, you retain control over your cryptoassets at all times.

**Users use third-party self-custodial wallets to interact with the Aave Protocol; we have no control or guarantee over the wallets.**

To interact with the Aave Protocol using the Interface, you will need to connect and engage with it through your self-custodial wallet. It's essential to understand that your self-custodial wallet is provided by a third-party entity and is generally governed by separate terms and conditions set by the respective third-party service provider. These terms and conditions may involve additional fees, disclaimers, or risk warnings regarding the accuracy and reliance on the provided information. Reviewing and comprehending the terms and conditions associated with your chosen self-custodial wallet provider to ensure compliance and to be aware of any applicable charges or risks is your sole responsibility.

**We are not intermediaries to the Aave Protocol transactions.**

Due to the non-custodial and decentralized nature of the technology, we are not intermediaries, agents, advisors, or custodians, and we do not have a fiduciary relationship or obligation to you regarding any other decisions or activities that you affect when using our Services.

**We have no information about all Protocol transactions beyond what is publicly available via the blockchain.**

You acknowledge that we do not have information regarding all Aave Protocol transactions beyond what is available or obtainable publicly via the blockchain. However, we may collect information regarding the users of the Services in accordance with our Privacy Policy.

**There may be associated blockchain fees.**

Transactions using blockchains may require the payment of gas fees, which are essentially network transaction fees paid on every transaction that occurs on the selected blockchain network. Please note that gas fees are non-refundable. We do not provide any services to users or deliver, hold, and/or receive payment for cryptoassets. We do not receive any fees for any transactions or the Services.

**You understand that the Interface is hosted on a decentralized infrastructure for storing and accessing data and content, IPFS.**

The Interface is hosted on the InterPlanetary File System ("IPFS"), a decentralized and distributed network protocol allowing for the storage and retrieval of files in a peer-to-peer manner, utilizing a distributed network of computers rather than relying on a central server. This means that the Interface's files are not stored in a single location but are instead spread across multiple nodes within the IPFS network.

### 3\. Assumption of Risk

**You assume the risks of engaging in novel and experimental technology.**

Technologies such as smart contracts on various blockchains, cryptographic tokens generated by the smart contracts, and other nascent software, applications, and systems that interact with blockchain-based networks are experimental, speculative, inherently risky, and subject to change. Among other risks, bugs, malfunctions, cyberattacks, or changes to the applicable blockchain (e.g., forks) could disrupt these technologies and even result in a total loss of cryptoassets, their market value, or digital funds. We assume no liability or responsibility for any such risks. If you are not comfortable assuming these risks, you should not access or engage in transactions using blockchain-based technology.

**We are not liable for any third-party services or links.**

We are not responsible for the content or services of any third-party, including, without limitation, any network or apps like Discord or MetaMask, and we make no representations regarding the content or accuracy of any third-party services or materials. The use and access of any third-party products or services, including through the Services, are at your own risk. Please note that we do not have control over third-party services. Consequently, we cannot guarantee, endorse, or recommend such content or services to users of the Interface, nor can we endorse their use for any specific purpose.

**You agree to the automated collection and disbursement of proceeds by smart contracts.**

You acknowledge and agree that all transactions accessed through the blockchain-based networks will be automatically processed using one or more smart contracts. By engaging in transactions using the Services, you acknowledge and consent to the automatic processing of all transactions in connection with using the Services. You further acknowledge and agree that the applicable smart contract will dictate how the funds of a transaction and ownership of cryptoassets are distributed.

**You acknowledge the risks of using the Services.**

You bear sole responsibility for evaluating the Services before using them, and all transactions on the blockchain are irreversible, final, and without refunds. The Services may be disabled, disrupted, or adversely impacted as a result of sophisticated cyber-attacks, surges in activity, computer viruses, and/or other operational or technical challenges, among other things. We disclaim any ongoing obligation to notify you of all the potential risks of using and accessing our Services. You agree to accept these risks and agree that you will not seek to hold any Aave Labs Indemnified Party responsible for any consequent losses.

**You are solely responsible for the security of your self-custodial wallet.**

You understand and agree that you are solely responsible for maintaining the security of

your self-custodial wallet. You alone are responsible for securing your private keys. We do not have access to your private keys. Any unauthorized access to your self-custodial wallet by third parties could result in the loss or theft of any cryptoasset or funds held in your account and any associated accounts. You understand and agree that we have no involvement in, and you will not hold us responsible for managing and maintaining the security of your self-custodial wallet. The private key associated with the self-custodial wallet address from which you transfer cryptoassets or the private key associated is the only private key that can control the cryptoassets you transfer into the smart contracts.

**We reserve the right to restrict your access from engaging with the Services.**

You agree that we have the right to restrict your access to the Services via any technically available methods if we suspect, in our sole discretion, that (a) you are using the Services for money laundering or any illegal activity; (b) you have engaged in fraudulent activity; (c) you have acquired cryptoassets using inappropriate methods, including the use of stolen funds to purchase such assets; (d) you are the target of any sanctions administered or enforced by the U.S. Department of the Treasury’s Office of Foreign Assets Control (“OFAC”), the United Nations Security Council, the European Union, Her Majesty’s Treasury, or any other legal or regulatory authority in any applicable jurisdiction; (e) either you, as an individual or an entity, or your wallet address is listed on the Specially Designated Nationals and Blocked Persons List (“SDN List”), Consolidated Sanctions List (“Non-SDN Lists), or any other sanctions lists administered by OFAC; (f) you are located, organized, or resident in a country or territory that is, or whose government is, the subject of sanctions, including but not limited to Côte d’Ivoire, Cuba, Belarus, Iran, Iraq, Liberia, North Korea, Sudan, and Syria; or (g) you have otherwise acted in violation of these Terms. If we have a reasonable suspicion that you are utilizing the Services for illegal purposes, we reserve the right to take whatever action we deem appropriate.

**We do not guarantee the quality or accessibility of the Services.**

As a condition to accessing or using the Services, you acknowledge, understand, and agree that from time to time, the Services may be inaccessible or inoperable for any reason, including, but not limited to equipment malfunctions, periodic maintenance procedures or repairs, causes beyond our control or that we could not reasonably foresee, disruptions and temporary or permanent unavailability of underlying blockchain infrastructure or unavailability of third-party service providers or external partners for any reason.

You acknowledge and agree that you will access and use the Services at your own risk. You should not engage in blockchain-based transactions unless it is suitable given your circumstances and financial resources. By using the Services, you represent that you have been, are, and will be solely responsible for conducting your own due diligence into the risks of a transaction and the underlying smart contracts and cryptoassets.

### 4\. Taxes

**You are responsible for your taxes and duties.**

Users bear sole responsibility for paying any and all taxes, duties, and assessments now or hereafter claimed or imposed by any governmental authority associated with their use of the Services and/or payable as a result of using and/or exploiting any cryptoassets and interacting with smart contracts. Blockchain-based transactions are novel, and their tax treatment is uncertain.

### 5\. Ownership

**We grant you a license to use our Services.**

Contingent upon your ongoing compliance with the Agreement, we grant you a personal, worldwide, revocable, non-exclusive, and non-assignable license to use the software provided to you as part of our Services. The only purpose of this license is to allow you to use and enjoy the Services solely as permitted by these Terms.

**We own all rights in the Services.**

We own any and all right, title, and interest in and to the Services, including, without limitation, any and all copyrights in and to any content, code, data, or other materials that you may access or use on or through the Services. Except as expressly set forth herein, your use of or access to the Services does not grant you any ownership or other rights therein.

**We may use and share your feedback.**

Any comments, bug reports, ideas, or other feedback that you may provide about our Services, including suggestions about how we might improve our Services, are entirely voluntary. You agree that we are free to use or not use any feedback that we receive from you as we see fit, including copying and sharing such feedback with third parties, without any obligation to you.

### 6\. Prohibited Content

You may only use the Services if you comply with this Agreement (including, without limitation, these Terms), applicable third-party policies, and all applicable laws, rules, regulations, and related guidance. The following conduct is prohibited:

*   Using the Services for, or to promote or facilitate, illegal activity (including, without limitation, money laundering, financing terrorism, tax evasion, buying or selling illegal drugs, contraband, counterfeit goods, or illegal weapons).
*   Exploiting the Services for any unauthorized commercial purpose.
*   Uploading or transmitting viruses, worms, Trojan horses, time bombs, cancel bots, spiders, malware, or any other type of malicious code that will or may be used in any way that will affect the functionality or operation of the Services.
*   Attempting to or actually copying or making unauthorized use of all or any portion of the Services, including by attempting to reverse compile, reformatting or framing, disassemble, reverse engineer any part of the Services.
*   Harvesting or otherwise collecting information from the Services for any unauthorized purpose.
*   Using the Services under false or fraudulent pretenses or otherwise being deceitful.
*   Interfering with other users’ access to or use of the Services.
*   Interfering with or circumventing the security features of the Services or any third party’s systems, networks, or resources used in the provision of Services.
*   Engaging in any attack, hack, denial-of-service attack, interference, or exploit of any smart contract in connection with the use of the Service (and operations performed by a user that are technically permitted by a smart contract may nevertheless be a violation of our Agreement, including these Terms, and the law).
*   Engaging in any anticompetitive behavior or other misconduct.

**Violating our rules may result in our intervention.**

You agree and acknowledge that if you use the Services to engage in conduct prohibited by applicable law, we permanently reserve the right to completely or partially restrict or revoke your access to the Services, either completely or for a period of time, at our sole discretion. We reserve the right to amend, rectify, edit, or otherwise alter transaction data to remediate or mitigate any damage caused either to us or to any other person as a result of a user’s violation of this Agreement or applicable law.

**We reserve the right to investigate violations.**

We reserve the right to investigate and prosecute any suspected breaches of this Agreement, including the Terms. We may disclose any information as necessary to satisfy any law, regulation, legal process, or governmental request.

### 7\. Disclaimers and Limitations of Liability

**We make no representations or warranties.**

THE SERVICES ARE PROVIDED ON AN “AS IS” AND “AS AVAILABLE” BASIS. WE AND OUR PARENTS, SUBSIDIARIES, AFFILIATES, RELATED COMPANIES, OFFICERS, DIRECTORS, EMPLOYEES, AGENTS, REPRESENTATIVES, PARTNERS, AND LICENSORS (COLLECTIVELY, THE “AAVE LABS INDEMNIFIED PARTIES”) MAKE NO GUARANTEES OF ANY KIND IN CONNECTION WITH THE SERVICES. TO THE MAXIMUM EXTENT PERMITTED UNDER APPLICABLE LAW, THE AAVE LABS INDEMNIFIED PARTIES DISCLAIM ALL WARRANTIES AND CONDITIONS, WHETHER EXPRESS OR IMPLIED, OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT AND DISCLAIM ALL RESPONSIBILITY AND LIABILITY FOR:

*   THE SERVICES BEING ACCURATE, COMPLETE, CURRENT, RELIABLE, UNINTERRUPTED, TIMELY, SECURE, OR ERROR-FREE. INFORMATION (INCLUDING, WITHOUT LIMITATION, THE VALUE OR OUTCOME OF ANY TRANSACTION) AVAILABLE THROUGH THE SERVICE IS PROVIDED FOR GENERAL INFORMATION ONLY AND SHOULD NOT BE RELIED UPON OR USED AS THE SOLE BASIS FOR MAKING DECISIONS. ANY RELIANCE ON THE SERVICES IS AT YOUR OWN RISK.
*   INJURY OR DAMAGE RESULTING FROM THE SERVICES. FOR EXAMPLE, YOU EXPRESSLY ACKNOWLEDGE, UNDERSTAND, AND AGREE THAT THE SERVICES MAY CONTAIN AUDIO-VISUAL EFFECTS, STROBE LIGHTS, OR OTHER MATERIALS THAT MAY AFFECT YOUR PHYSICAL SENSES AND/OR PHYSICAL CONDITION. FURTHER, YOU EXPRESSLY ACKNOWLEDGE THAT THE AAVE COMPANIES INDEMNIFIED PARTIES ARE NOT RESPONSIBLE FOR LOSS OR DAMAGE CAUSED BY ANOTHER USER’S CONDUCT, UNAUTHORIZED ACTORS, OR ANY UNAUTHORIZED ACCESS TO OR USE OF THE SERVICES.
*   VIRUSES, WORMS, TROJAN HORSES, TIME BOMBS, CANCEL BOTS, SPIDERS, MALWARE, OR OTHER TYPE OF MALICIOUS CODE THAT MAY BE USED IN ANY WAY TO AFFECT THE FUNCTIONALITY OR OPERATION OF THE SERVICES.

**Limitation of Liability.**

TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL ANY AAVE LABS INDEMNIFIED PARTY BE LIABLE TO YOU FOR ANY LOSS, DAMAGE, OR INJURY OF ANY KIND INCLUDING ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY, CONSEQUENTIAL, OR PUNITIVE LOSSES OR DAMAGES, OR DAMAGES FOR SYSTEM FAILURE OR MALFUNCTION OR LOSS OF PROFITS, DATA, USE, BUSINESS OR GOOD-WILL OR OTHER INTANGIBLE LOSSES, ARISING OUT OF

OR IN CONNECTION WITH:

*   THE SERVICES OR YOUR INABILITY TO USE OR ACCESS THE SERVICES.
*   MISUSE OF THE SERVICES (INCLUDING WITHOUT LIMITATION, UNAUTHORIZED ACCESS OF THE SERVICES).
*   ANY USER CONDUCT ON THE SERVICES.
*   TERMINATION, SUSPENSION OR RESTRICTION OF ACCESS TO ANY THE SERVICES.

IN ADDITION TO THE FOREGOING, NO AAVE LABS INDEMNIFIED PARTY SHALL BE LIABLE FOR ANY DAMAGES CAUSED IN WHOLE OR IN PART BY:

*   USER ERROR, SUCH AS FORGOTTEN PASSWORDS OR INCORRECTLY CONSTRUCTED SMART CONTRACTS OR OTHER TRANSACTIONS.
*   SERVER FAILURE OR DATA LOSS.
*   THE MALFUNCTION, UNEXPECTED FUNCTION OR UNINTENDED FUNCTION OF THE BLOCKCHAIN, ANY COMPUTER OR CRYPTOASSET NETWORK (INCLUDING ANY WALLET PROVIDER), INCLUDING WITHOUT LIMITATION LOSSES ASSOCIATED WITH NETWORK FORKS, REPLAY ATTACKS, DOUBLE-SPEND ATTACKS, SYBIL ATTACKS, 51% ATTACKS, GOVERNANCE DISPUTES, MINING DIFFICULTY, CHANGES IN CRYPTOGRAPHY OR CONSENSUS RULES, HACKING, OR CYBERSECURITY BREACHES.
*   ANY CHANGE IN VALUE OF ANY CRYPTOASSET.
*   ANY CHANGE IN LAW, REGULATION, OR POLICY.
*   EVENTS OF FORCE MAJEURE.
*   ANY THIRD PARTY.

THIS LIMITATION OF LIABILITY IS INTENDED TO APPLY WITHOUT REGARD TO WHETHER OTHER PROVISIONS OF THESE TERMS HAVE BEEN BREACHED OR HAVE PROVEN INEFFECTIVE. THE LIMITATIONS SET FORTH IN THIS SECTION SHALL APPLY REGARDLESS OF THE FORM OF ACTION, WHETHER THE ASSERTED LIABILITY OR DAMAGES ARE BASED ON CONTRACT, INDEMNIFICATION, TORT, STRICT LIABILITY, STATUTE, OR ANY OTHER LEGAL OR EQUITABLE THEORY, AND WHETHER OR NOT THE AAVE COMPANIES INDEMNIFIED PARTIES HAVE BEEN INFORMED OF THE POSSIBILITY OF ANY SUCH DAMAGE.

IN NO EVENT WILL THE AAVE LABS INDEMNIFIED PARTIES’ CUMULATIVE LIABILITY TO YOU OR ANY OTHER USER, FROM ALL CAUSES OF ACTION AND ALL THEORIES OF LIABILITY EXCEED ONE THOUSAND U.S. DOLLARS (U.S. $1,000.00).

UNDER NO CIRCUMSTANCES SHALL ANY AAVE LABS INDEMNIFIED PARTY BE REQUIRED TO DELIVER TO YOU ANY VIRTUAL CURRENCY AS DAMAGES, MAKE SPECIFIC PERFORMANCE, OR ANY OTHER REMEDY. IF YOU WOULD BASE YOUR CALCULATIONS OF DAMAGES IN ANY WAY ON THE VALUE OF VIRTUAL CURRENCY, YOU AND WE AGREE THAT THE CALCULATION SHALL BE BASED ON THE LOWEST VALUE OF THE VIRTUAL CURRENCY DURING THE PERIOD BETWEEN THE ACCRUAL OF THE CLAIM AND THE AWARD OF DAMAGES.

Some jurisdictions do not allow the exclusion or limitation of certain warranties and liabilities provided in this section; accordingly, some of the above limitations and disclaimers may not apply to you. To the extent applicable law does not permit Aave Companies Indemnified Parties to disclaim certain warranties or limit certain liabilities, the extent of Aave Labs Indemnified Parties’ liability and the scope of any such warranties will be as permitted under applicable law.

### 8\. Indemnification

You agree to indemnify, defend, and hold harmless the Aave Labs Indemnified Parties from any claim or demand, including reasonable attorneys’ fees, made by any third party due to or arising out of:

*   Your breach or alleged breach of the Agreement (including, without limitation, these Terms).
*   Anything you contribute to the Services.
*   Your misuse of the Services, or any smart contract and/or script related thereto.
*   Your violation of any laws, rules, regulations, codes, statutes, ordinances, or orders of any governmental or quasi-governmental authorities.
*   Your violation of the rights of any third party, including any intellectual property right, publicity, confidentiality, property, or privacy right.
*   Your use of a third-party product, service, and/or website.
*   Any misrepresentation made by you.

We reserve the right to assume, at your expense, the exclusive defense and control of any matter subject to indemnification by you. You agree to cooperate with our defense of any claim. You will not in any event settle any claim without our prior written consent.

We reserve the right to assume, at your expense, the exclusive defense and control of any matter subject to indemnification by you. You agree to cooperate with our defense of any claim. You will not in any event settle any claim without our prior written consent.

### 9\. Arbitration Agreement and Waiver of Rights, Including Class Actions

PLEASE READ THIS SECTION CAREFULLY: IT MAY SIGNIFICANTLY AFFECT YOUR LEGAL RIGHTS, INCLUDING YOUR RIGHT TO FILE A LAWSUIT IN COURT AND TO HAVE A JURY HEAR YOUR CLAIMS. IT CONTAINS PROCEDURES FOR MANDATORY BINDING ARBITRATION AND A CLASS ACTION WAIVER.

**Agreement to Attempt to Resolve Disputes Through Good Faith Negotiations**

Prior to commencing any legal proceeding against us of any kind, including an arbitration as set forth below, you and we agree that we will attempt to resolve any dispute, claim, or controversy between us arising out of or relating to the agreement or the Services (each, a “Dispute” and, collectively, “Disputes”) by engaging in good faith negotiations. Such good faith negotiations require, at a minimum, that the aggrieved party provide a written notice to the other party specifying the nature and details of the Dispute. The party receiving such notice shall have thirty (30) days to respond to the notice. Within sixty (60) days after the aggrieved party sent the initial notice, the parties shall meet and confer in good faith by videoconference, or by telephone, to try to resolve the Dispute. If the parties are unable to resolve the Dispute within ninety (90) days after the aggrieved party sent the initial notice, the parties may agree to mediate their Dispute, or either party may submit the Dispute to arbitration as set forth below.

**Agreement to Arbitrate**

You and we agree that any Dispute that cannot be resolved through the procedures set forth above will be resolved through binding arbitration in accordance with the International Arbitration Rules of the International Centre for Dispute Resolution. The place of arbitration shall be the Cayman Islands. The language of the arbitration shall be English. The arbitrator(s) shall have experience adjudicating matters involving Internet technology, software applications, financial transactions and, ideally, blockchain technology. The arbitrator’s award of damages must be consistent with the terms of the “Limitation of Liability” subsection of these Terms as to the types and amounts of damages for which a party may be held liable. The prevailing party will be entitled to an award of their reasonable attorney’s fees and costs. Except as may be required by law, neither a party nor its representatives may disclose the existence, content, or results of any arbitration hereunder without the prior written consent of (all/both) parties.

UNLESS YOU TIMELY PROVIDE US WITH AN ARBITRATION OPT-OUT NOTICE (AS DEFINED BELOW IN THE SUBSECTION TITLED “YOUR CHOICES”), YOU ACKNOWLEDGE AND AGREE THAT YOU AND WE ARE EACH WAIVING THE RIGHT TO A TRIAL BY JURY OR TO PARTICIPATE AS A PLAINTIFF OR CLASS MEMBER IN ANY PURPORTED CLASS ACTION OR REPRESENTATIVE PROCEEDING. FURTHER, UNLESS BOTH YOU AND WE OTHERWISE AGREE IN WRITING, THE ARBITRATOR MAY NOT CONSOLIDATE MORE THAN ONE PERSON’S CLAIMS AND MAY NOT OTHERWISE PRESIDE OVER ANY FORM OF ANY CLASS OR REPRESENTATIVE PROCEEDING.

**Changes**

By rejecting any changes to these Terms, you agree that you will arbitrate any Dispute between you and us in accordance with the provisions of this section as of the date you first accepted these Terms (or accepted any subsequent changes to these Terms).

### 10\. Waiver of Injunctive or Other Equitable Relief

TO THE MAXIMUM EXTENT PERMITTED BY LAW, YOU AGREE THAT YOU WILL NOT BE PERMITTED TO OBTAIN AN INJUNCTION OR OTHER EQUITABLE RELIEF OF ANY KIND, SUCH AS ANY COURT OR OTHER ACTION THAT MAY INTERFERE WITH OR PREVENT THE DEVELOPMENT OR EXPLOITATION OF THE SERVICES, OR ANY OTHER WEBSITE, APPLICATION, CONTENT, SUBMISSION, PRODUCT, SERVICE, OR INTELLECTUAL PROPERTY OWNED, LICENSED, USED OR CONTROLLED BY ANY AAVE LABS INDEMNIFIED PARTY.

### 11\. Termination; Cancellation

This Agreement is effective unless and until terminated by either you or us. You may terminate your Agreement with us at any time by ceasing all access to the Services. If, in our sole judgment, you fail, or we suspect that you have failed, to comply with any term or provision of the Agreement (including without limitation any provision of these Terms), we reserve the right to terminate our Agreement with you and deny you access to the Services. We further reserve the right to restrict your access to the Services or to stop providing you with all or a part of the Services at any time and for no reason, including, without limitation, if we reasonably believe: (a) your use of the Services exposes us to risk or liability; (b) you are using the Services for unlawful purposes; or (c) it is not commercially viable to continue providing you with our Services. All of these are in addition to any other rights and remedies that may be available to us, whether in equity or at law, all of which we expressly reserve.

WE RESERVE THE RIGHT TO MODIFY THE SERVICES AT ANY TIME, BUT WE HAVE NO OBLIGATION TO UPDATE THE SERVICES. YOU AGREE THAT IT IS YOUR RESPONSIBILITY TO MONITOR CHANGES TO THE SERVICES THAT MAY AFFECT YOU. YOU AG

REE THAT WE MAY REMOVE THE SERVICES AND/OR ANY CONTENT THEREON FOR INDEFINITE PERIODS OF TIME OR CANCEL THE SERVICES AT ANY TIME, WITHOUT NOTICE TO YOU.

### 12\. Severability

If any provision of the Agreement (including, without limitation, these Terms) is determined to be unlawful, void, or unenforceable, such provision shall nonetheless be enforceable to the fullest extent permitted by applicable law, and the unenforceable portion shall be deemed to be severed from the Agreement. Such determination shall not affect the validity and enforceability of any other remaining provisions.

### 13\. Assignment

The Agreement (including, without limitation, these Terms) may be assigned without your prior consent to any Aave Labs Indemnified Party, or to its successors in the interest of any business associated with the Services provided by us. You may not assign or transfer any rights or obligations under the Agreement without our prior written consent.

### 14\. Entire Agreement

The Agreement (including, without limitation, these Terms, and the Privacy Policy) and any policies or operating rules posted by us on the Services constitute the entire agreement and understanding between you and us and govern your use of the Services, superseding any prior or contemporaneous agreements, communications, and proposals, whether oral or written, between you and us (including, but not limited to, any prior versions of these Terms). Any failure by us to exercise or enforce any right or provision of the Agreement (including, without limitation, these Terms) shall not constitute a waiver of such right or provision.

### 15\. Governing Law

These Terms and any separate agreements whereby we provide you Services shall be governed by and construed in accordance with the laws of the Cayman Islands.

### 16\. Contact Us

You may contact us with questions about your use of the Services at [\[email protected\]](https://aave.com/cdn-cgi/l/email-protection#ef988a8c8e9d8aaf8e8e998ac18c8082).</content>
</page>

<page>
  <title>Safety Module</title>
  <url>https://aave.com/help/safety-module</url>
  <content>[](https://aave.com/)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>Aave 101</title>
  <url>https://aave.com/help/aave-101</url>
  <content>[](https://aave.com/)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>Supplying</title>
  <url>https://aave.com/help/supplying</url>
  <content>[](https://aave.com/)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>Borrowing</title>
  <url>https://aave.com/help/borrowing</url>
  <content>[](https://aave.com/)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>Governance</title>
  <url>https://aave.com/help/governance</url>
  <content>[](https://aave.com/)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>GHO Stablecoin</title>
  <url>https://aave.com/help/gho-stablecoin</url>
  <content>[](https://aave.com/)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>| Aave Protocol Documentation</title>
  <url>https://aave.com/docs/developers/liquidations</url>
  <content>Liquidations
------------

[](#liquidations)

The health of the Aave Protocol is dependent on the 'health' of the collateralised positions within the protocol, also known as the 'health factor'. When the 'health factor' of an account's total loans is below 1, anyone can make a liquidationCall() to the [Pool](https://aave.com/docs/developers/smart-contracts/pool) or [L2Pool](https://aave.com/docs/developers/smart-contracts/pool) (in case of L2 rollup networks) contract, pay back part of the debt owed and receive discounted collateral in return (also known as the liquidation bonus).

This incentivises third parties to participate in the health of the overall protocol, by acting in their own interest (to receive the discounted collateral) and as a result, preserve that borrows are sufficiently collateralized.

There are multiple ways to participate in liquidations:

1.  By calling the liquidationCall() directly in the [Pool](https://aave.com/docs/developers/smart-contract/pool) or [L2Pool](https://aave.com/docs/developers/smart-contracts/l2-pool) contract.
    
2.  By creating your own automated bot or system to liquidate loans.
    

For liquidation calls to be profitable, you must take into account the gas cost involved in liquidating the loan. If a high gas price is used, then the liquidation may be unprofitable for you. See the [Calculating profitability](https://aave.com/docs/developers/liquidations#calculating-profitability-vs-gas-cost) section for more details.

V3 allows 100% of debt (i.e. MAX\_LIQUIDATION\_CLOSE\_FACTOR) to be liquidated in single liquidationCall() if HF < CLOSE\_FACTOR\_HF\_THRESHOLD

Prerequisites
-------------

[](#prerequisites)

When making a liquidationCall(), you must:

*   Know the account (i.e. the ethreum address: user) whose health factor is below 1.
    
*   Know the valid debt amount and asset (i.e. debtToCover & debtAsset)
    
    *   If the HF is above CLOSE\_FACTOR\_HF\_THRESHOLD, then only a maximum of 50% (i.e. DEFAULT\_LIQUIDATION\_CLOSE\_FACTOR) of the debt can be liquidated per valid liquidationCall()
        
    *   If the HF is below CLOSE\_FACTOR\_HF\_THRESHOLD, then 100% (i.e. MAX\_LIQUIDATION\_CLOSE\_FACTOR) of the debt can be liquidated in single valid liquidationCall()
        
    *   You can set the debtToCover to uint(-1) and the protocol will proceed with the highest possible liquidation allowed by the close factor.
        
    *   You must already have sufficient balance of the debt asset, which will be used by the liquidationCall to pay back the debt. You can use flashLoan for liquidations 😉
        
    
*   Know the collateral asset collateralAsset you closing, i.e. the asset that the user has backing their outstanding loan that you will receive as a bonus.
    
*   Whether you want to receive _aTokens_ or the underlying asset after a successful liquidationCall() .
    

Getting accounts to liquidate
-----------------------------

[](#getting-accounts-to-liquidate)

"User Account" in the Aave Protocol refer to a single ethereum address that has interacted with the protocol. This can be an externally owned account or contract.

Only user accounts that have HF < 1 can be liquidated. There are multiple ways you can get the health factor:

### On Chain

[](#getting-accounts-to-liquidate-on-chain)

1.  To gather user account data from on-chain data, one way would be to monitor emitted events from the protocol and keep an up to date index of user data locally.
    
    1.  Events are emitted each time a user interacts with the protocol (supply, borrow, repay, withdraw etc.)
        
    
2.  When you have the user's address, you can simply call [getUserAccountData()](https://aave.com/docs/developers/smart-contracts/pool), to read the user's current healthFactor. If the HF < 1, then the account can be liquidated.
    

### GraphQL

[](#getting-accounts-to-liquidate-graphql)

1.  Similarly to the sections above you will need to gather user account data and keep an index of the user data locally.
    
2.  SInce GraphQL does not provide real time calculated user data such as healthFactor, you will need to compute this locally. The easiest way is to use the [Aave Utilities](https://github.com/aave/aave-utilities#formatusersummary) sdk, which has methods to compute user summary data.
    

Executing the liquidation call
------------------------------

[](#executing-the-liquidation-call)

Once you have the account(s) to liquidate, you will need to calculate the amount of collateral that can be liquidated:

1.  Use [getUserReservesData()](https://aave.com/docs/developers/smart-contracts/view-contracts)
    
2.  Max debt that be cleared by single liquidation call is given by the DEFAULT\_LIQUIDATION\_CLOSE\_FACTOR(when CLOSE\_FACTOR\_HF\_THRESHOLD < HF < 1) or MAX\_LIQUIDATION\_CLOSE\_FACTOR (when HF < CLOSE\_FACTOR\_HF\_THRESHOLD)
    
    1.  debtToCover = (userVariableDebt) \* LiquidationCloseFactor
        
    2.  You can pass uint(-1), i.e. MAX\_UINT, as the debtToCover to liquidate the maximum amount allowed.
        
    
3.  Max amount of collateral that can be liquidated to cover debt is given by the current _liquidationBonus_ for the reserves that have usageAsCollateralEnabled as true.
    
    1.  maxAmountOfCollateralToLiquidate = (debtAssetPrice \* debtToCover \* liquidationBonus)/ collateralPrice
        
    

Calculating profitability vs gas cost
-------------------------------------

[](#calculating-profitability-vs-gas-cost)

One way to calculate the profitability is the following:

1.  Store and retrieve each collateral's relevant details such as address, decimals used and liquidation bonus.
    
2.  Get the user's collateral balance (aTokenBalance).
    
3.  Get the asset's price according to the Aave's oracle contract using [getAssetPrice()](https://aave.com/docs/developers/smart-contracts/oracles).
    
4.  The maximum collateral bonus received on liquidation is given by the maxAmountOfCollateralToLiquidate \* (1 - liquidationBonus) \* collateralAssetPriceEth
    
5.  The maximum cost of your transaction will be you gas price multiplied by the amount of gas used. You should be able to get a good estimation of the gas amount used by calling estimateGas via your web3 provider.
    
6.  Your approximate profit will be the value of the collateral bonus (4) minus the cost of your transaction (5).
    

Appendix
--------

[](#appendix)

### How is health factor calculated?

[](#appendix-how-is-health-factor-calculated)

The health factor is calculated from the user's total collateral, i.e. all reserves for which usageAsCollateral is enabled, balance (in ETH) multiplied by the liquidation threshold percentage for all the user's outstanding assets, divided by the user's total borrow balance across all reserves (in ETH).

This can be calculated both off-chain and on-chain, see [Aave Utilities](https://github.com/aave/aave-utilities/blob/cdf8a8bf87c8848a2f0865c58defbd04e0871171/packages/math-utils/src/pool-math.ts#L169) and [GenericLogic Library](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/libraries/logic/GenericLogic.sol#L4) respectively for reference.

### How is liquidation bonus determined?

[](#appendix-how-is-liquidation-bonus-determined)

Liquidation bonuses for all the assets are evaluated and determined based on each asset's liquidity risk and updated via Aave Governance process.</content>
</page>

<page>
  <title>Web3</title>
  <url>https://aave.com/help/web3</url>
  <content>[](https://aave.com/)

Aave.com provides information and resources about the fundamentals of the decentralised non-custodial liquidity protocol called the Aave Protocol, comprised of open-source self-executing smart contracts that are deployed on various permissionless public blockchains, such as Ethereum (the "Aave Protocol" or the "Protocol"). Aave Labs does not control or operate any version of the Aave Protocol on any blockchain network.</content>
</page>

<page>
  <title>Email Protection | Cloudflare</title>
  <url>https://aave.com/cdn-cgi/l/email-protection#1e697b7d7f6c7b5e7f7f687b307d7173</url>
  <content>Please enable cookies.

You are unable to access this email address aave.com
----------------------------------------------------

The website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. **You must enable Javascript in your browser in order to decode the e-mail address**.

If you have a website and are interested in protecting it in a similar way, you can [sign up for Cloudflare](https://www.cloudflare.com/sign-up?utm_source=email_protection).

*   [How does Cloudflare protect email addresses on website from spammers?](https://support.cloudflare.com/hc/en-us/articles/200170016-What-is-Email-Address-Obfuscation-)
*   [Can I sign up for Cloudflare?](https://support.cloudflare.com/hc/en-us/categories/200275218-Getting-Started)

Cloudflare Ray ID: **904a2a46bf57287e** • Your IP: 72.252.120.68 • Performance & security by [Cloudflare](https://www.cloudflare.com/5xx-error-landing)</content>
</page>

<page>
  <title>Stake</title>
  <url>https://aave.com/help/safety-module/stake</url>
  <content>Introduction
------------

Staking in the Aave Safety Module allows AAVE, GHO, and ABPT holders on the Ethereum network to contribute to the protocol's security while earning Safety Incentives. By staking, participants add an additional layer of protection, with the acknowledgement that their assets may be slashed in the event of a shortfall to cover any protocol deficits. Underlying tokens that can supplied to safety module are listed below:

*   [AAVE](https://etherscan.io/address/0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9)
*   [ABPT](https://etherscan.io/address/0x3de27efa2f1aa663ae5d458857e731c129069f29) ([Underlying Balancer Token Pool](https://app.balancer.fi/#/ethereum/pool/0x3de27efa2f1aa663ae5d458857e731c129069f29000200000000000000000588))
*   [GHO](https://etherscan.io/address/0x40d16fc0246ad3160ccc09b8d0d3a2cd28ae6c2f)

Tokens can be supplied through protocol smart contracts or through a frontend such as [Aave Labs interface](https://app.aave.com/), by performing the following steps:

Step 1: Connect Wallet
----------------------

To begin, press ‘Connect Wallet’ and select the Ethereum wallet provider corresponding to the wallet holding tokens intended to supply to safety module.

Step 2: Select Safety Module Pool
---------------------------------

Once connected, navigate to the 'Stake' tab where you’ll find a list of available safety module pools.

Step 3: Approve Token Transfer
------------------------------

In order to transfer tokens on an Ethereum-based network, the staked token smart contract must be granted an allowance to transfer tokens from the connected wallet address. After selecting a pool to supply, a modal will appear which will prompt a transaction in the connected wallet.

Step 4: Perform Stake Transaction
---------------------------------

After approval, enter the amount you wish to stake and confirm which will prompt a transaction in the connect wallet. Your tokens are then added to the Aave Safety Module, where they will start earning safety incentives, which can be monitored from the 'Stake' tab.

Understanding Slashing Risks
----------------------------

When staking in the Aave Safety Module, it’s important to be aware of the potential slashing risks. Slashing refers to the reduction of staked assets in the event of a shortfall event within the Aave Protocol. This mechanism is in place to protect the protocol by using a portion of staked assets to cover any deficits that may arise. While staking offers rewards through Safety Incentives, there is a risk that a portion of your staked assets could be slashed to contribute to the stability of the Aave ecosystem.

The extent of slashing varies depending on the type of token staked:

stkAAVE and stkABPT: Maximum slashing risk is up to 30% of the staked assets. stkGHO: Maximum slashing risk is up to 99% of the staked assets.

These risks are an essential consideration for anyone looking to participate in the Aave Safety Module, as they reflect the potential loss of assets in exchange for helping to secure the protocol. The process of identifying and exeucting a slashing event is subject to an onchain Aave Governance proposal.</content>
</page>

<page>
  <title>Unstake</title>
  <url>https://aave.com/help/safety-module/unstake</url>
  <content>Introduction
------------

Unstaking from the Aave Safety Module allows holder of staked tokens (stkAAVE, stkGHO, and stkABPT) on the Ethereum network to withdraw the underlying tokens. The process involves a mandatory cooldown period, which must be completed before tokens can be unstaked. Participants earn Safety Incentives during their staking period, which can be claimed at any time—either while staking or after unstaking.

The unstaking process can be performed through protocol smart contracts or through a frontend such as [Aave Labs interface](https://app.aave.com/), by performing the following steps:

Step 1: Connect Wallet
----------------------

To begin, press ‘Connect Wallet’ and select the Ethereum wallet provider corresponding to the wallet holding the staked tokens intended to be unstaked from the Safety Module.

Step 2: Navigate to Staking Page
--------------------------------

Once connected, navigate to the 'Stake' tab where you can find the balances of staked tokens and buttons to performing the unstaking process.

Step 3: Activate the Cooldown Period
------------------------------------

To unstake your tokens, you must first activate the cooldown period. This requires a transaction in the connected wallet. The cooldown period lasts 20 days, during which you cannot unstake your tokens.

Step 4: Unstake After the Cooldown Period
-----------------------------------------

After the cooldown period completes, you have a 2-day window to unstake your tokens. If you do not unstake within this window, you will need to activate the cooldown period again and wait another 20 days.

This unstake transaction moves underyling tokens from the Safety Module and will be available in the connected wallet once the transaction is confirmed.

Claiming Incentives
-------------------

Safety Incentives can be claimed at any time—either while your staking position is active or after you've unstaked your tokens. Incentives can be claimed from the 'Stake' tab, which displays pending rewards and will be sent to your connected wallet upon claiming.

Actions Affecting Cooldown Period
---------------------------------

The cooldown period is influenced by various actions involving staked tokens. The following outlines how these actions affect the cooldown period:

*   Staking Additional Tokens: Staking additional tokens during an active cooldown does not affect the ongoing cooldown period. The newly staked tokens will not be eligible for unstaking until a new cooldown period is initiated and completed for those tokens.
    
*   Unstaking Tokens: After the cooldown period has elapsed, only the amount of tokens that were staked and in cooldown can be unstaked. Unstaking resets the cooldown period to zero for the unstaked amount, requiring a new cooldown to be activated for any remaining staked tokens.
    
*   Claiming Safety Incentives: Claiming safety incentives does not affect the cooldown period. The cooldown period continues unaffected regardless of safety incentive claims.
    
*   Transferring Staked Tokens: The sender's cooldown remains unaffected by the transfer. For the recipient, the cooldown status is independent and must be initiated or continued based on their own cooldown status. Transferred tokens will not automatically inherit the cooldown period of the sender.</content>
</page>

<page>
  <title>Introduction To Aave</title>
  <url>https://aave.com/help/aave-101/introduction-to-aave</url>
  <content>The Aave Protocol is a collection of smart contracts that facilitates overcollateralised borrowing of digital assets. The protocol is deployed on Ethereum, Polygon, Avalanche, BNB Chain, Fantom, and Harmony networks, as well as Layer 2 chains including Base, Arbitrum, Optimism, Gnosis, Base, Scroll, Metis, and ZKsync Era.

Aave allows users to supply and borrow cryptocurrencies without the need of a central authority or intermediary. The protocol is comprised of publicly accessible, self-executing smart contracts that are deployed on various permissionless public blockchains. Users interact with the Aave Protocol by submitting transactions to the blockchain using self-custodial wallets.

Supply
------

By supplying tokens to Aave, users can earn interest on their assets while contributing to the protocol’s liquidity. These supplied assets are “pooled” and can also be utilised as collateral for borrowing while continuing to earn interest.

Suppliers, also known as liquidity providers, supply their cryptocurrency into Aave's liquidity pools.

Here's how it works:

*   A user selects a supported cryptocurrency (e.g., ETH, USDC) and supplies it into the Aave Protocol.
*   Upon supplying, the address receives a corresponding amount of **_aTokens_** (e.g., aETH, aUSDC) in return. These tokens represent the addresses share in the pool and start accruing interest automatically.

The interest earned by liquidity providers is not fixed and varies depending on the **_utilisation rate_** of the asset in the pool. The utilisation rate is the percentage of the total pool that is currently borrowed.

*   **High Utilisation Rate**: if a large portion of the pool is being borrowed, the interest rate increases. This incentivizes supplies, borrow repayments, and disincentivizes further borrowing.
*   **Low Utilisation Rate**: if most of the pool is idle, the interest rate decreases, reflecting the lower demand for borrowing that asset.

Interest is accrued continuously and is added to the suppliers aTokens automatically. In other words, over time the balance of aTokens increases, allowing the supplier to redeem the enhanced value of their supply position.

Suppliers can withdraw their tokens at any time alongside the accrued interest as long as there is available (unborrowed) liquidity in the token pool. This is done by burning the aTokens, which triggers the return of the corresponding amount of the underlying asset from the pool.

Borrow
------

Supplied tokens can be utilised as collateral to borrow against. The collateral must be greater in value than the borrowed amount, a concept known as overcollateralisation. If the assets supplied as collateral drop under the minimum collateralisation threshold, the position could face liquidation.

### Collateralisation

To borrow assets from Aave, a user must first supply collateral. This collateral can be any cryptocurrency supported within the protocol. The value of the collateral must always exceed the value of the amount borrowed. Overcollateralisation is a safeguard to protect the protocol against market volatility. For example, if a user wants to borrow $100 worth of GHO, they might be required to supply $150 worth of ETH as the collateral, depending on specific Loan-to-Value (LTV) collateral requirements.

### Loan-to-Value (LTV) Ratio

Each type of collateral has a specific **LTV ratio**. The LTV ratio determines how much a user can borrow against their collateral. For example, if the LTV ratio for ETH is 75%, a user can borrow up to 75% of the value of their ETH supply position. If the collateral value drops, the LTV ratio increases and when this ration reaches a threshold, the borrower risks liquidation.

### Borrowing Process

After supplying collateral, the user can borrow assets up to the allowed amount based on the LTV ratio.

The borrower is transferred the underlying tokens that can be used freely. The borrow position accrues interest and supplied collateral tokens cannot be transferred or withdrawn until the borrow position is repaid.

### Repayment

Borrowers can repay their borrow position at any time. Repayment includes the principal amount borrowed plus the accrued interest.

Once the borrow position is fully repaid, the collateral is unlocked and can be transferred or withdrawn by the supplier.

Liquidations
------------

When an open borrow position falls below the minimum collateralisation parameters, any user can participate as a liquidator. The liquidator repays the borrow position and receives a portion of the collateral larger than the amount repaid. This creates a competitive and incentivized landscape that maintains the protocol’s overcollateralisation.

Participating in Aave Governance
--------------------------------

The Aave Protocol's governance is driven by the AAVE token holder community, who participate in governance in a structured manner by submitting proposals, open discussion, voting, and smart contract execution. Through the governance process, token holders shape the future of the protocol, making a variety of decisions such as protocol upgrades, enhancements, and more.

Participating in the Aave Safety Module
---------------------------------------

Participants in the Aave Safety Module earn incentives for supplying tokens that backstop the protocol in the event of a shortfall. This mechanism helps protect the protocol from unforeseen risks and market volatility, and helps maintain the stability of the ecosystem.</content>
</page>

<page>
  <title>Safety Incentives</title>
  <url>https://aave.com/help/safety-module/safety-incentives</url>
  <content>Introduction
------------

Safety Incentives are rewards distributed to participants who stake their assets in the Aave Safety Module. These incentives serve as compensation for the risk taken by stakers, whose assets may be slashed to cover protocol deficits in the event of a shortfall. Safety Incentives are primarily distributed in the form of AAVE tokens, and the amount allocated to stakers is determined by Aave Governance through votes on emission parameters.

The emission parameters, which dictate the rate of Safety Incentives, are voted on by the Aave community. These parameters are allocated from the Ecosystem Reserve (AAVE Tokens) and/or the Protocol Treasury. Governance votes allow AAVE token holders to influence how much of the reserve or treasury is allocated to these incentives and how they are distributed over time. This decentralised decision-making process promotes that the incentives align with the overall health and security of the Aave ecosystem.

Safety Incentives accumulate over time and can be claimed at any point while tokens are staked or after unstaking from the safety module.

Claiming Safety Incentives can be performed through protocol smart contracts or through a frontend such as [Aave Labs interface](https://app.aave.com/), by performing the following steps:

Step 1: Connect Wallet
----------------------

To start, press ‘Connect Wallet’ and choose the Ethereum wallet provider associated with your staked tokens.

Step 2: Navigate to the 'Stake' Tab
-----------------------------------

Once connected, go to the 'Stake' tab within the Aave interface, where you can monitor your staked assets and the accumulated Safety Incentives.

Step 3: Claim Rewards
---------------------

Within the 'Stake' tab, you will see the option to claim your accumulated rewards. Click on the 'Claim' button, which will prompt a transaction in your connected wallet. Confirm the transaction to claim Safety Incentives.</content>
</page>

<page>
  <title>Accessing Aave</title>
  <url>https://aave.com/help/aave-101/accessing-aave</url>
  <content>* * *

Introduction
------------

Aave is an open protocol, and users can interact with Aave through a variety of user-friendly interfaces, or directly with its smart contracts. This openness also enables the creation of third-party services or applications that integrate with the protocol.

Interfaces
----------

There are multiple interfaces available to access the Aave Protocol. Below are just a few examples:

*   The Aave Interface located at [app.aave.com](https://app.aave.com/) – an interface hosted on IPFS, maintained by Aave Labs
*   [DeFi Saver](https://app.defisaver.com/aave): all the protocol functionalities, combined withleverage and auto liquidation (repayment with collateral)
*   Flash Loans, supply and withdrawal from the [Furucombo](https://furucombo.app/) interface
*   Supply and withdraw from the [Argent wallet](https://www.argent.xyz/)
*   Manage positions via smart accounts with the [Brahma Console](https://console.brahma.fi/)
*   Asset management on [Fireblocks](https://www.fireblocks.com/)
*   All actions are available directly through the protocol’s smart contracts, which can be accessed through block explorers or code, by following the guidelines available in the [docs](https://aave.com/docs)

Deployments
-----------

All official deployments of the Aave Protocol are approved through community governance. The protocol is currently deployed on the following blockchain networks:

Mainnet

*   Ethereum Core (V3, V2, V1)
*   Ethereum Prime (V3)
*   Ethereum EtherFi (V3)
*   Polygon (V3, V2)
*   Avalanche C-Chain (V3, V2)
*   Arbitrum (V3)
*   Optimism (V3)
*   Base (V3)
*   BNB Chain (V3)
*   Scroll (V3)
*   Metis (V3)
*   Gnosis (V3)
*   ZKsync Era (V3)
*   Fantom (V3)
*   Harmony (V3)

The Ethereum **Core** market serves as the most liquid and risk-adjusted environment for a diverse range of assets, while the Ethereum **Prime** market is dedicated to blue-chip collaterals and high-leverage, correlated assets.

### Testnet

*   Ethereum Sepolia (V3)
*   Arbitrum Sepolia (V3)
*   Base Sepolia (V3)
*   Scroll Sepolia (V3)
*   Optimism Sepolia (V3)
*   Avalanche Fuji (V3)
*   Fantom Testnet (V3)

Notice
------

Beware of scams: Aave never advertises on any social media platform or search engine and does not have any downloadable mobile application available. Aave Protocol will never ask for your wallet seed phrase. Should you encounter any of these suspicious instances, do not interact with them.

* * *</content>
</page>

<page>
  <title>Supply Tokens</title>
  <url>https://aave.com/help/supplying/supply-tokens</url>
  <content>Introduction
------------

Supplying tokens to the Aave Protocol allows you to earn interest on your digital assets and utilize supplied tokens as collateral. When tokens are supplied, they are transferred to the Aave liquidity pool, a system of smart contracts that facilitates overcollateralized borrowing of tokens. Supplied tokens automatically accumulate interest by updating in balance at the current market supply rate. This interest accrual happens dynamically as the balance of your supplied tokens increases linearly over time, reflecting the current rate allocated to suppliers.

Interest rates for supplied tokens are determined by the borrow utilization rate, which measures the proportion of assets currently borrowed against the total supplied in the pool, and by governance parameters that can be adjusted through community decisions. These parameters, including collateralization requirements and interest rates for suppliers and borrowers, are influenced by on-chain inputs such as token balances, oracle prices, and the borrow utilization ratio. As liquidity is supplied, borrowed, repaid, or withdrawn from the pool, the interest rates are updated accordingly.

Tokens can be supplied through protocol smart contracts or through a frontend such as the Aave Labs interface, by performing the following steps:

Step 1: Connect Wallet
----------------------

To begin, press ‘Connect Wallet’ and select the Ethereum wallet provider corresponding to the wallet holding tokens intended to supply.

Step 2: Select Token To Supply
------------------------------

Once connected, navigate to the ‘Dashboard’ where you’ll find the ‘Assets To Supply’ table, which lists current token balances and asset parameters. More details on supply and borrow parameters can be found by selecting the individual token icon, which will navigate to the reserve details page.

Step 3: Approve Token Transfer
------------------------------

In order to transfer tokens on an Ethereum-based network, the Aave Pool smart contract must be granted an allowance to transfer tokens from the connected wallet address. Approvals can be performed through transaction (which will incur a network fee) or signature (which does not incur a network fee). After selecting a token to supply, a modal will appear which will prompt a transaction or message signature request in the connected wallet.

Step 4: Perform Supply Transaction
----------------------------------

After approval, enter the amount you wish to supply and confirm, which will prompt a transaction in the connected wallet. Your supplied tokens are then added to the Aave liquidity pool, where they are made available for borrowers. The supplied tokens will start earning interest immediately, which can be monitored from the ‘Dashboard’ tab.</content>
</page>

<page>
  <title>Withdraw Tokens</title>
  <url>https://aave.com/help/supplying/withdraw-tokens</url>
  <content>Introduction
------------

Withdrawing tokens from the Aave Protocol transfers underlying supplied assets along with any accrued interest, provided there is sufficient liquidity in the pool. This means suppliers can withdraw up to the amount available in the pool that is not currently borrowed. The process varies slightly depending on the type of token and the withdrawal method, and can be performed through protocl smart contracts or a frontend such as the [Aave Labs interface](https://app.aave.com/).

Step 1: Connect Wallet
----------------------

To begin, press ‘Connect Wallet’ and select the Ethereum wallet provider corresponding to the wallet where the tokens are supplied.

Step 2: Navigate to 'Your Supplies'
-----------------------------------

Once connected, navigate to the ‘Dashboard’ and locate the ‘Your Supplies’ section. This table displays all tokens you have supplied to the Aave Protocol.

Step 3: Select Token to Withdraw
--------------------------------

Choose the token you wish to withdraw from the list. Verify that there is enough available liquidity in the pool to support your withdrawal. If the token is not being used as collateral for an active borrow position, you can proceed to withdraw the desired amount.

Step 4: Confirm Withdrawal
--------------------------

Enter the amount you want to withdraw and confirm the transaction in your wallet. If you are withdrawing the same underlying token that you supplied (e.g., WETH to WETH), no additional approval transaction is needed. However, if you’re withdrawing to a network base token, such as ETH, the Aave Protocol stores these as wrapped tokens (e.g., WETH). In this case, the withdrawal process involves the WrappedTokenGateway contract, where the WETH is unwrapped and withdrawn in a single transaction.

Step 5: Handling Collateralised Tokens
--------------------------------------

If your supplied tokens are used as collateral, you may need to repay part of your borrow position or supply additional collateral to maintain a healthy balance before you can withdraw. Regularly monitoring your health factor will help you manage this effectively.

Step 6: Withdrawing and Switching Tokens
----------------------------------------

The Aave Labs interface also offers a feature to withdraw and switch to a different token in one action. This requires token approval for both the withdrawal and the switch. Ensure you review the necessary approvals in your wallet before proceeding.</content>
</page>

<page>
  <title>Toggle Collateral Status</title>
  <url>https://aave.com/help/supplying/toggle-collateral-status</url>
  <content>Introduction
------------

Supplying tokens to the Aave Protocol allows you to use these assets as collateral to borrow other assets. Managing the collateral status of your supplied tokens is crucial for maintaining borrowing power and avoiding liquidation. The health factor is a key indicator: a value above 1 means your collateral is sufficient, while a value below 1 signals that your position is at risk of liquidation.

You can manage the collateral status of your supplied tokens through protocol smart contracts or through a frontend such as Aave Labs interface by performing the following steps:

Step 1: Connect Wallet
----------------------

To begin, press ‘Connect Wallet’ and select the Ethereum wallet provider corresponding to the wallet holding the supplied tokens.

Step 2: Navigate to 'Your Supplies'
-----------------------------------

Once connected, navigate to the ‘Dashboard’ where you’ll find the 'Your Supplies' section. This table lists the tokens you have supplied and their current collateral status.

To manage the collateral status, locate the token you wish to adjust and toggle the collateral switch. This action will update the status, allowing the token to be used (or not used) as collateral. Confirm the transaction in your wallet to apply the change.

Step 4: Monitor Your Health Factor
----------------------------------

Regularly monitor your health factor from the ‘Dashboard’, especially if you have active borrow positions. If the value of your collateral drops or the amount of borrowed assets increases, consider supplying more tokens or repaying part of your borrow position to improve your health factor.

Parameters such as Loan-to-Value (LTV) and Liquidation Threshold (LT), set by Aave Governance, influence your borrowing power and risk. LTV defines the maximum ratio at which a new borrow position can be opened, while LT indicates the ratio of collateral at which a borrow position may be liquidated. These parameters are established through community proposals and voting to maintain protocol stability.

Regularly check your health factor and keep an eye on governance proposals to adjust your collateral as needed and avoid liquidation.</content>
</page>

<page>
  <title>Isolation Mode</title>
  <url>https://aave.com/help/supplying/isolation-mode</url>
  <content>Introduction
------------

Isolation Mode in Aave V3 is a feature designed to safely introduce new or volatile assets into the protocol by limiting how they can be used as collateral. When an asset is designated as an "Isolated Collateral Asset," it can only be used to borrow specific stablecoins that have been approved by Aave Governance. This setup helps to contain the risk associated with these assets. In the Aave Labs interface, assets that can only be supplied in Isolation Mode are clearly marked with an isolated icon and description, making it easy for users to identify them.

Supplying an Isolated Asset
---------------------------

When you supply an Isolated Asset, it may be used as collateral under certain conditions. If it's the first asset you’re supplying or if you don’t have any other assets enabled as collateral, you can use the Isolated Asset to borrow approved stablecoins. However, if you already have other assets enabled as collateral, the Isolated Asset can still be supplied, but it won’t be eligible as collateral. This means you can earn interest on it, but you can’t use it to borrow unless it’s your only collateralised asset.

Borrowing in Isolation Mode
---------------------------

When using an Isolated Asset as collateral, you are limited to borrowing only the stablecoins that are approved for Isolation Mode. This restriction helps manage the risk associated with these assets. Additionally, while in Isolation Mode, you cannot enable any other assets as collateral, including other Isolated Collateral Assets. This enforces that the borrowing risks remain contained within the guidelines set by Aave Governance.

Exiting Isolation Mode
----------------------

If you decide to exit Isolation Mode, the process requires that you first repay any outstanding debt associated with the Isolated Asset. Once the debt is cleared, you can disable the Isolated Asset as collateral, allowing you to revert to the standard borrowing options available in the protocol.</content>
</page>

<page>
  <title>Borrow Tokens</title>
  <url>https://aave.com/help/borrowing/borrow-tokens</url>
  <content>Introduction
------------

Borrowing tokens from the Aave Protocol enables participants to access liquidity against supplied collateral tokens. This process requires maintaining sufficient collateral and understanding the associated risks, such as liquidation. Borrowers must maintain that their collateral remains adequate to cover the borrowed amount, as falling below the required collateralization level could lead to liquidation. The interest rates for borrowed tokens are dynamically determined by the protocol based on factors like the borrow utilization rate and governance parameters, which can change through community decisions.

Borrowing can be performed through protocol smart contracts or through a frontend such as the [Aave Labs interface](https://app.aave.com/) by performing the following steps:

Step 1: Connect Wallet
----------------------

To begin, press ‘Connect Wallet’ and select the Ethereum wallet provider corresponding to the wallet holding the collateralized tokens.

Step 2: Select Token to Borrow
------------------------------

Once connected, navigate to the ‘Dashboard’ and locate the ‘Assets to Borrow’ table. This table lists the available tokens for borrowing, along with key parameters such as available amount, interest rates, and your health factor. The interest rates displayed here are influenced by the borrow utilization rate, which measures the proportion of assets currently borrowed against the total supplied in the pool. As liquidity is borrowed or repaid, these rates are dynamically adjusted to reflect current market conditions.

Select the token you wish to borrow.

Step 3: Review Borrow Parameters
--------------------------------

Before proceeding, review the borrow parameters including the Loan-to-Value (LTV) ratio, Liquidation Threshold (LT) ratio, and your current health factor. These parameters are crucial for maintaining sufficient collateral and avoiding liquidation.

If you are borrowing a network base asset (e.g., ETH), you will first need to approve the WrappedTokenGateway contract. This approval enables the contract to perform a credit delegation, which performs a borrow and unwraps to the base asset in a single transaction.

Step 4: Confirm Borrow Transaction
----------------------------------

Enter the amount you wish to borrow and confirm the transaction in your wallet. Upon confirmation, the borrowed tokens will be transferred to your wallet. It's important to note that interest on the borrowed tokens begins to accrue immediately and is dynamically adjusted based on the borrow utilization rate.

Step 5: Monitor Health Factor
-----------------------------

Regularly monitor your health factor from the ‘Dashboard’ to verify that your collateral remains sufficient. If your health factor drops, consider supplying more collateral or repaying part of your borrow position to avoid liquidation. The health factor is a critical indicator of the safety of your borrow position, and maintaining it above the liquidation threshold is essential to prevent your collateral from being liquidated.</content>
</page>

<page>
  <title>Repay Tokens</title>
  <url>https://aave.com/help/borrowing/repay-tokens</url>
  <content>Introduction
------------

Repaying tokens on the Aave Protocol is essential for closing your borrow position and freeing up collateral.

Repayments can be made fully or partially through protocol smart contracts or through a frontend such as [Aave Labs interface](https://app.aave.com/) by performing the following steps:

Step 1: Connect Wallet
----------------------

To begin, press ‘Connect Wallet’ and select the Ethereum wallet provider corresponding to the wallet holding the tokens intended for repayment.

Step 2: Select Borrowed Token to Repay
--------------------------------------

Once connected, navigate to the ‘Dashboard’ and locate the ‘Your Borrowings’ section. This table lists the tokens you have borrowed. Choose the token you wish to repay.

Step 3: Approve Token Transfer (if necessary)
---------------------------------------------

If repaying with a non-base token, you may need to approve the Aave Pool smart contract to transfer tokens from your wallet. This approval is necessary for any repayment action that involves ERC-20 tokens. Approvals can be performed through a transaction (incurs a network fee) or a signature (does not incur a network fee).

Step 4: Confirm Repayment Transaction
-------------------------------------

Enter the repayment amount and confirm the transaction in your wallet. If repaying a base asset, the repayment process involves the WrappedTokenGateway contract, which unwraps the token and repays the borrowed amount in a single transaction.

Step 5: Monitor Collateral Health Factor
----------------------------------------

After the repayment is confirmed, your debt will decrease, and your health factor will improve. Fully repaying your borrow position will release your collateral, making it available for withdrawal or other uses. Regularly monitor your health factor and manage your borrow positions to reduce the risk of liquidation.</content>
</page>

<page>
  <title>Health Factor & Liquidations</title>
  <url>https://aave.com/help/borrowing/liquidations</url>
  <content>The health factor is a critical metric within the Aave Protocol that measures the safety of a borrow position. It is calculated as:

**Health Factor = (Total Collateral Value \* Weighted Average Liquidation Threshold) / Total Borrow Value**

This metric indicates the stability of a borrow position, with a health factor below 1 signaling the risk of liquidation. The liquidation threshold, set by Aave Governance for each collateral asset, determines the maximum percentage of value that can be borrowed against it. For example, if you supply $10,000 in ETH with an 80% liquidation threshold and borrow $6,000 in GHO, your health factor would be 1.333.

Managing Health Factor
----------------------

Maintaining a health factor above 1 is crucial to avoid liquidation. Regular monitoring of this metric is essential, as it fluctuates with the value of both collateral and borrowed assets. To improve your health factor, you can either supply more collateral or repay part of your borrow position. The health factor is sensitive to market changes—if your collateral's value increases, so does your health factor; conversely, if it decreases, your health factor drops, heightening the risk of liquidation.

There is no universally "safe" health factor, as this depends on the volatility and correlation of your assets. Generally, lower health factors may be acceptable for correlated assets, such as stablecoins or assets closely tied to ETH.

**Tools for Managing Health Factor** (Use at your own risk):

*   Simulate health factor changes: [DeFi Simulator](https://defisim.xyz/)
*   Auto-repay borrow position: [DeFi Saver](https://app.defisaver.com/aave)

Liquidation Process
-------------------

A liquidation in the Aave Protocol occurs when a borrower's health factor falls below 1, indicating that their collateral no longer sufficiently covers the borrowed amount. This situation can happen when the value of the collateral decreases or the borrowed amount increases, pushing the position past the liquidation threshold.

During a liquidation, up to 50% of the borrower's debt is repaid by the liquidator, with an equivalent value, plus a liquidation fee, taken from the borrower's collateral. Liquidations are permissionless, meaning any network participant can initiate the process when a borrow position is eligible for liquidation.

Liquidations within Aave are highly competitive, requiring a deep understanding of the protocol and technical proficiency. Liquidators must actively monitor borrow positions, quickly react to changes in oracle prices, collateral balances, and protocol parameters, and submit transactions with high priority in the attempt to be first to execute the liquidation.

Due to the competitive nature, successful liquidations often necessitate custom-coded bots or scripts that automate monitoring and execution. Developers interested in building liquidation bots or learning more about the process can find guidance and resources in the Aave Developer Documentation.</content>
</page>

<page>
  <title>Efficiency Mode (E-mode)</title>
  <url>https://aave.com/help/borrowing/e-mode</url>
  <content>Introduction
------------

High Efficiency Mode (E-mode) in Aave Protocol V3 allows users to maximize their borrowing power by selecting optimized asset categories. With the recent addition of liquid E-modes, assets may belong to multiple E-mode categories, providing greater flexibility in choosing the most efficient borrowing strategy based on category-specific parameters and asset availability.

Each E-mode category specific its own Loan-to-Value (LTV), Liquidation Threshold (LT), Liquidation Bonus, and borrowing permissions for each asset in the category. When an E-mode is activated, borrowing is restricted to assets within the chosen category. Therefore, it’s essential to review the available assets, collateral, and borrowing parameters within the category before enabling E-mode.

Enabling or disabling E-mode can be done directly on the Aave Protocol smart contracts or via interfaces like the [Aave Labs interface](https://app.aave.com/).

Step 1: Connect Wallet
----------------------

Press ‘Connect Wallet’ to select your preferred wallet provider and confirm it holds the collateral assets you plan to use.

Step 2: Navigate to E-mode Options
----------------------------------

After connecting, go to the ‘Dashboard’ and locate the E-mode option near your account summary row. The availability of E-mode options depends on the assets in your wallet and their category eligibility.

Step 3: Select E-mode Category
------------------------------

Click the ‘E-mode’ button to open the selection modal. You can then enable, switch, or disable an E-mode category that aligns with your collateral strategy. Take note of the collateral and borrowing availability and parameters to determine which E-mode aligns with the intended borrowing strategy. Confirm the transaction in your wallet to apply or disable the selected E-mode, which will affect the asset availability and parameters for borrowing.

Step 4: Supply / Borrow
-----------------------

Once E-mode is active, the steps for supplying and borrowing follow standard protocol procedures. However, remember that your collateral parameters and borrowing options are now tailored to the active E-mode category, dictating available assets and adjusted risk parameters.</content>
</page>

<page>
  <title>Aave Community</title>
  <url>https://aave.com/help/governance/aave-community</url>
  <content>Introduction
------------

The Aave Community is a decentralised collective of token holders and contributors who collaboratively shape the protocol's future through a structured governance process. This community-driven approach empowers participants to propose, discuss, and vote on key changes, promoting that the protocol's evolution reflects the collective interests of its members.

Governance Roles
----------------

### Delegates

Delegates are community members who have received voting power from other members of the community or through self-delegation. They actively participate in governance by voting on proposals on behalf of those who have entrusted them with their voting power. Some delegates are compensated under the Orbit program.

### Delegators

Delegators are community members who hold AAVE, stkAAVE, or aAAVE tokens but choose to delegate their voting power to another person. The person to whom they delegate their voting power is considered a delegate. This system allows delegators to have their interests represented in governance decisions without having to participate directly in every vote.

### Contributors

Contributors are community members who participate in and dedicate their time to the Aave DAO. They contribute by joining working groups, fulfilling bounties, building on top of the Aave Protocol, or working for the DAO via grants.

### Service Providers

Service providers are specialized entities or groups that offer essential services to maintain and enhance the Aave Protocol. The current service providers are:

*   Chaos Labs: Risk service provider
*   Llamarisk: Risk service provider
*   Karpatkey: Finance service provider
*   Certora: Security service provider
*   Tokenlogic: Finance service provider
*   BGD Labs: Development service provider
*   ACI: Growth and business development service provider

Guardians
---------

The Aave Guardians are crucial for maintaining the protocol’s security and integrity. They are divided into two groups: Protocol Guardians, who handle emergency responses and can pause markets, and Governance Guardians, who can veto malicious governance proposals. The Guardians operate under a 5/9 multi-sig arrangement.

For more information on the Guardians’ permissions, refer to [this](https://github.com/bgd-labs/aave-permissions-book) detailed view of permissions in Aave systems. For a general overview of their role, see the Medium post about Aave V2 Governance [here](https://medium.com/aave/aave-protocol-governance-v2-has-been-activated-af4a4b228885).

### Protocol Emergency Guardian

This Guardian holds the EMERGENCY\_ADMIN role in Aave V3, as well as similar roles in V2 and other related systems. The primary function of the Protocol Emergency Guardian is to act swiftly in emergency situations to protect the protocol. It is composed of highly active entities within the Aave DAO, such as service providers and delegates. The multi-sig configuration for this Guardian is a 5-of-9 setup. The current Protocol Guardians are shown in the table below and were updated in [this](https://governance.aave.com/t/arfc-renewal-of-aave-guardian-2024/17523/19) ARFC Addendum.

| Protocol Emergency Guardian | Address |
| --- | --- |
| Chaos Labs | 0x5d49dBcdd300aECc2C311cFB56593E71c445d60d |
| LlamaRisk | 0xbA037E4746ff58c55dc8F27a328C428F258DDACb |
| Karpatkey | 0x818C277dBE886b934e60aa047250A73529E26A99 |
| Certora | 0x4f96743057482a2E10253AFDacDA3fd9CF2C1DC9 |
| TokenLogic | 0xb647055A9915bF9c8021a684E175A353525b9890 |
| BGD Labs | 0xf71fc92e2949ccF6A5Fd369a0b402ba80Bc61E02 |
| ACI | 0x57ab7ee15cE5ECacB1aB84EE42D5A9d0d8112922 |
| Ezr3al | 0xC5bE5c0134857B4b96F45AA6f6B77DB96Ac1487e |
| Stable Lab | 0xd4af2E86a27F8F77B0556E081F97B215C9cA8f2E |

### Governance Emergency Guardian

This Guardian is responsible for cancelling governance proposals if they are detected as malicious or contain errors, typically identified during the on-chain verification stage by Certora. Unlike the Protocol Emergency Guardian, speed is less critical for this role since governance proposals unfold over a period of five days, allowing adequate time for issues to be identified and addressed. The multi-sig configuration for this Guardian is also a 5-of-9 setup. The current Governance Guardians are shown in the table below and were updated in [this](https://governance.aave.com/t/arfc-renewal-of-aave-guardian-2024/17523/19) ARFC Addendum.

| Governance Emergency Guardian | Address |
| --- | --- |
| Seb (Zapper) | 0xa1c9ceed5ff78f700dc4930514621843b5fac272 |
| Mounir (Paraswap) | 0xfd639f49Da6cadc98f01B60900C8BE30C38c4B27 |
| Gavi Galloway (Standard Crypto) | 0xbd4DCfA978c6D0d342cE36809AfFFa49d4B7f1F7 |
| Nenad (Defi Saver) | 0xDA5Ae43e179987a66B9831F92223567e1F38BE7D |
| Fernando (Balancer) | 0x4C30E33758216aD0d676419c21CB8D014C68099f |
| Roger (Chainlink community) | 0xA3103D0ED00d24795Faa2d641ACf6A320EeD7396 |
| Mariano Conti (DeFi OG) | 0x936CD9654271083cCF93A975919Da0aB3Bc99EF3 |
| Marin (Lido) | 0x0D2394C027602Dc4c3832Ffd849b5df45DBac0E9 |
| Certora | 0x4f96743057482a2E10253AFDacDA3fd9CF2C1DC9 |

Stewards
--------

Stewards were introduced to allow the DAO to respond quickly to market changes in order to remain competitive and address risks. They are delegated responsibility over specific parameters within certain boundaries of magnitude and frequency of change. The benefit of this is that minor changes do not need to go through a full governance cycle, increasing speed and reducing governance burden on delegates and tokenholders. At time of writing there are stewards for managing: GHO, lending parameters, and treasury operations.

### GHO Stewards

The GHO Stewards are a group of Contributors and Service Providers who manage critical parameters for the GHO stablecoin to promote its stability. This group has the authority to adjust the:

*   GHO Borrow Cap
*   Borrow Rate
*   various GSM parameters like Exposure Cap, Bucket Capacity, Price Strategy, Fee Strategy, and Price Range (Freeze, Unfreeze)

The ranges for parameters which the GHO Stewards may adjust are shown in the below table and were proposed in the following ARFCs [\[ARFC\] GHO Stewards](https://governance.aave.com/t/arfc-gho-stewards/16466), [\[ARFC\] GHO Stewards + Borrow Rate Update](https://governance.aave.com/t/arfc-gho-stewards-borrow-rate-update/16956).

| Description | Value |
| --- | --- |
| GHO Aave Bucket Capacity | 100% Increase |
| GSM Exposure Cap | 100% Increase |
| GSM Bucket Capacity | 100% Increase |
| GSM Fee Strategy | \+ 0.5% |
| GSM Price Range | (Freeze, Unfreeze) |
| GHO Borrow Cap | 100M |
| Max GHO Borrow Rate Adjustment | 5% |
| Max GHO Borrow Rate | 25% |
| Frequency of Change | 2 days |

The creation of GHO Stewards aims to streamline governance, allowing quick adjustments to maintain the GHO peg, especially during market fluctuations. The GHO Stewards operate under a 3-of-4 multi-sig configuration and GHO Stewards at time of writing are:

*   Karpatkey
*   Tokenlogic
*   ACI
*   Chaos Labs

### Risk Stewards

Risk Stewards are responsible for managing critical risk parameters within the Aave Protocol. They are able to make adjustments to supply and borrow caps, reducing the need for frequent community votes. This setup is designed to enable rapid responses to emerging risks while minimising governance overhead.

The parameters that Risk Stewards can change are:

*   Supply and Borrow Caps: Increasing caps with constraints on frequency and maximum percentage increase to maintain protocol stability.
*   Collateral Risk Configurations: Adjusting parameters such as Loan-to-Value (LTV), liquidation thresholds, and liquidation bonuses.
*   Interest Rate Strategies: Fine-tuning base rates, slopes, and optimal points to align with market conditions.

The parameters that the Risk Stewards can control are shown in the table below and were discussed in the following proposal: [BGD. Risk Steward Phase 1: CapsPlusRiskSteward](https://governance.aave.com/t/bgd-risk-steward-phase-1-capsplusrisksteward/12602).

| Description | Value |
| --- | --- |
| Frequency of change | 5 days |
| Maximum supply cap increase | 50% |
| Maximum borrow cap increase | 50% |

Risk Stewards operate under strict on-chain validations and are managed by a 1-of-1 multisig. Risk Stewards at the time of writing are:

*   Chaos Labs

### Finance Stewards

Please note the Finance Stewards system in not yet live and is for information purposes only at this point, it is planned that this will go live in the near future.

Finance Stewards are responsible for executing pre-approved and budgeted financial operations on behalf of the Aave DAO. They manage the Aave DAO’s funds through a smart contract that acts as an admin of the collector, streamlining the management of treasury assets and reducing the need for frequent on-chain votes.

The Finance Stewards have the authority to:

*   Migrate assets from v2 and deposit into v3
*   Use the Aave Swapper to exchange treasury assets
*   Withdraw and deposit into V3
*   Transfer and stream tokens to pre-approved addresses within set budgets such as ACI [Frontier](https://governance.aave.com/t/arfc-introducing-frontier-staking-as-a-service-for-the-aave-dao/16225) Program and ACI [Merit](https://governance.aave.com/t/arfc-merit-a-new-aave-alignment-user-reward-system/16646) Program

Proposed Finance Stewards at the time of writing are:

*   Karpatkey
*   Tokenlogic</content>
</page>

<page>
  <title>Proposals</title>
  <url>https://aave.com/help/governance/proposals</url>
  <content>Introduction
------------

Aave Governance allows the community to make decisions on the protocol's future through a structured proposal lifecycle. Proposals can introduce new features, modify parameters, or make other changes to the Aave Protocol. Below is an outline of the proposal lifecycle, from initial idea to execution.

Governance Forum
----------------

The first step in the proposal process is to introduce your idea to the community. The Aave Governance Forum and Discord are the primary platforms for discussing proposals. Here, community members can provide feedback, technical support, and gauge the initial sentiment towards their idea. Engaging with the community early on helps refine the proposal and gather the necessary support before moving to the next stages.

Snapshot Voting
---------------

### TEMP CHECK

Once your proposal has been discussed in the forum, the next step is to gauge community sentiment through a TEMP CHECK vote on the Aave Snapshot Space. TEMP CHECKs serve as informal polls to measure the community’s interest in the proposal. These votes are non-binding and do not require high technical detail or the involvement of DAO service providers. They are a valuable tool for determining whether there is enough interest to proceed with the proposal.

### ARFC (Aave Request for Final Comments)

If the TEMP CHECK indicates sufficient interest, the proposal can move to the ARFC stage. The ARFC is a more detailed version of the proposal, where relevant service providers are formally invited to provide feedback. This stage includes a thorough specification section that outlines how the proposal will impact Aave Protocol smart contracts. The ARFC serves as a precursor to the formal Aave Improvement Proposal (AIP) and allows for final refinements before moving on-chain.

Creating the On-Chain Payload
-----------------------------

### AIP (Aave Improvement Proposal)

After passing the Snapshot phase, a proposal that requires on-chain execution moves to the AIP phase. The AIP is the formal proposal payload submitted on-chain and consists of two parts: the proposal metadata (stored as an IPFS hash) and the contract payload. These components are submitted to the Aave Governance contracts on the Ethereum Mainnet, where they will be voted on by the community. Detailed information on creating an AIP can be found in the Aave Developer Documentation.

Voting and Execution Timeline
-----------------------------

### Voting

When the AIP is submitted, the voting process begins. The proposal will initially be in a PENDING status, and will move to ACTIVE once the voting delay period has elapsed. Voting tokens and delegations are held on Ethereum Mainnet, and the voting occurs through governance contracts on the specified network.

The snapshot for voting balances is taken at the block before the proposal becomes ACTIVE. For a proposal to SUCCEED, it must meet two criteria:

*   The voting power in favor of the proposal must reach the quorum set by the minimum quorum parameter for the proposal executor.
*   The difference between for-votes and against-votes must exceed the vote differential threshold set by the vote differential parameter for the proposal executor.

If these conditions are not met, the proposal will be marked as FAILED.

### Execution

A SUCCEEDED proposal can be executed on Ethereum Mainnet. The execution process involves relaying the vote information through Aave's governance cross-chain infrastructure. If the proposal includes a cross-chain payload, it will be queued on the timelock executor contract on the relevant network.

The timelock delay for execution depends on the proposal's executor. A short executor proposal, typically involving protocol updates, has a 1-day timelock delay. A long executor proposal, which involves changes to core governance permissions, has a 7-day timelock delay. Cross-chain proposals use Aave Delivery Infrastructure (a.DI) to verify messages from designated bridges and execute the payloads.

Proposal Frameworks
-------------------

The Aave DAO has established frameworks for common proposal types, which streamline the proposal process. These frameworks are adopted and amended through community Snapshot votes.

### Caps Update Framework

Proposals that only involve changing a cap or freezing a reserve can qualify for the direct-to-AIP process under the caps update framework. To qualify:

*   The proposal must be provided by a risk service provider or have feedback from at least one risk service provider team.
*   The change must involve a new cap implementation, a decrease in the cap, or a change not exceeding a 100% increase in the current cap.

### Asset Onboarding Framework

For proposals that involve onboarding new tokens, the asset onboarding framework provides a standardized template and lifecycle. This framework promotes that new tokens are added to the Aave Protocol in a consistent and secure manner.

[Asset Onboarding Framework](https://governance.aave.com/t/arfc-update-the-asset-onboarding-framework/15629)

### New Chain Deployment Framework

The New Chain Deployment Framework is a standardized process for deploying the Aave Protocol on new blockchains. This framework aims to create a transparent approach for evaluating and deploying new Aave v3 instances.

[New Chain Deployment Framework Link](https://governance.aave.com/t/arfc-new-chain-deployment-framework/15694)

### Emission Manager Framework

To allow quick addition of new emissions admins to Aave pool reserves, the process of adding new emissions admins follows a direct-to-AIP framework. This framework also allows pre-authorized inclusion of an emission admin as part of either an ad-hoc steward or current risk steward role to facilitate a more efficient and streamlined onboarding process.

[Emission Manager Framework Link](https://governance.aave.com/t/arfc-emission-manager-framework-update/16884)</content>
</page>

<page>
  <title>Voting</title>
  <url>https://aave.com/help/governance/voting</url>
  <content>* * *

Introduction
------------

Voting in Aave Governance is a critical process that empowers AAVE, stkAAVE, and aAAVE token holders to shape the protocol’s future. By participating in voting, community members can directly impact decisions on new features, parameter changes, and other key aspects of the protocol. The process typically begins with off-chain voting via Snapshot to gauge community sentiment, followed by on-chain voting for proposals that require formal approval and execution. Voting helps Aave remain a decentralised and community-driven platform, with each token holder's input contributing to the protocol's evolution.

Off-chain Voting (Snapshot)
---------------------------

Off-chain voting in Aave, conducted via [Snapshot](https://snapshot.org/#/aave.eth), is primarily used for gauging community sentiment during the early stages of proposal development, such as Temp Checks and Aave Requests for Comments (ARFCs). These votes are non-binding and serve as informal polls to assess whether there is enough support for a proposal to move forward. The voting period for both Temp Checks and ARFCs lasts three days. Off-chain voting allows token holders to express their views without incurring transaction fees, making it a convenient way to measure the community’s interest and refine proposals before they proceed to the on-chain stage.

On-chain Voting (Governance Interfaces)
---------------------------------------

On-chain voting is required for Aave Improvement Proposals (AIPs) that propose changes to the protocol and is conducted through various governance interfaces such as  [Aave Labs](https://app.aave.com/governance), [BGD Labs](https://vote.onaave.com/), and [Tally](https://www.tally.xyz/gov/aave) This process involves a more formal and secure approach, where proposals undergo a thorough review to check for safety and correctness. Once a proposal is approved for on-chain voting, it goes through a one-day delay before becoming active, followed by a voting period. During this time, token holders can cast their votes directly on-chain, with their voting power proportional to the amount of AAVE, stkAAVE, or aAAVE they hold or have been delegated on _Ethereum mainnet_. The proposal must meet quorum and majority requirements to succeed, after which it is queued with a timelock before execution.

Voting Timelines
----------------

The following timelines are relevant to the voting process:

*   **Off-chain Voting (Snapshot):** The voting period for Temp Checks and ARFCs lasts three days.
*   **On-chain Voting:** After a proposal is submitted onchain, there is a one-day delay before it becomes active. The voting period and execution timelock depend on the type of proposal. Most proposals are targeted for the “Short Executor” which has a three-day voting period and one-day timelock for execution. Proposals that modify governance processes are targeted for the “Long Executor,” which has a 10-day voting period and a seven-day timelock for execution.

Voting Representatives
----------------------

In Aave Governance, voting representatives facilitate cross-chain voting, especially for users with smart contract wallets or those participating across multiple blockchain networks. A voting representative links your governance decisions to the voting process when your wallet can't participate directly due to technical constraints, like the inability to sign messages for storage proof voting or interact with cross-chain contracts.

You can select a voting representative through interfaces like Aave Labs interface. This representative can cast votes on your behalf using your delegated voting power, managing voting for multiple users and enhancing flexibility and accessibility for all governance participants.

* * *</content>
</page>

<page>
  <title>GHO Stablecoin</title>
  <url>https://aave.com/help/gho-stablecoin/gho</url>
  <content>What is GHO?
------------

The GHO stablecoin (pronounced “go”) is a decentralised, overcollateralised asset native to the Aave Protocol, designed to maintain a stable value pegged to the U.S. Dollar. Overcollateralised means that the collateral supplied is greater than the value of the stablecoins issued. This provides a buffer in case the value of the collateral decreases, helping to maintain the peg of the stablecoin. Currently, GHO can be borrowed against any collateral assets available in the Aave V3 Ethereum market.

How is GHO different from other stablecoins?
--------------------------------------------

Unlike other stablecoins, GHO is created directly within the Aave ecosystem, allowing users to mint GHO by supplying collateral to the protocol. This structure safeguards that GHO is fully backed by more than the value of the collateral, promoting stability and resilience in volatile market conditions. The decentralised nature of GHO is a significant feature, as it is governed by the Aave community through Aave Governance, which controls key aspects like interest rates and collateral requirements.

What makes GHO particularly unique is it's native integration with the Aave Protocol. As a native stablecoin, GHO leverages Aave’s existing infrastructure, including its overcollateralization model and decentralised governance. Interest paid by GHO minters go directly to the Aave DAO treasury, supporting the protocol’s sustainability and governance. This model differentiates GHO from centralized stablecoins, as it is designed to be transparent, secure, and community-driven, with all decisions being made through Aave's decentralised governance processes.</content>
</page>

<page>
  <title>Interest Rate Mechanics</title>
  <url>https://aave.com/help/gho-stablecoin/interest-rate-mechanics</url>
  <content>How is the interest rate determined?
------------------------------------

The GHO stablecoin introduces a unique interest and discount model designed to incentivize borrowing and maintain its stability. When borrowing GHO, users accrue interest over time, similar to other stablecoins on the Aave Protocol. The interest rate for GHO is determined by the Aave DAO through governance proposals and can vary based on market conditions and demand for the stablecoin. This interest rate is decided such that the borrowing costs remain fair and competitive while supporting the overall health of the protocol.

What is the discount rate?
--------------------------

In addition to the standard interest rate, GHO also features a discount model that provides incentives for specific user groups or activities. These discounts apply to the borrowing interest rate, making it cheaper for certain borrowers.

Current discounts include lower rates for those who supply higher-quality collateral, are active participants in the Aave ecosystem, or apply specifically only to varies facilitator arrangements.

To benefit from these discounts, borrowers need to meet the criteria set forth by the Aave DAO. The discount model is implemented to encourage healthy borrowing behavior and to reward users who contribute positively to the ecosystem. By understanding and utilizing the interest and discount model, borrowers can optimize their costs when using GHO, making it an attractive option for stablecoin needs within the Aave Protocol. This approach promotes that GHO remains a robust and user-friendly stablecoin, providing value to a broad range of DeFi participants.</content>
</page>

<page>
  <title>Facilitators</title>
  <url>https://aave.com/help/gho-stablecoin/facilitators</url>
  <content>What are GHO facilitators?
--------------------------

Facilitators are entities or protocols authorized by the Aave DAO to mint and manage GHO stablecoins. They play a critical role in maintaining the stability and supply of GHO. Each facilitator operates under specific parameters and conditions set by Aave Governance to maintain that GHO remains stable and trustworthy. Facilitators are chosen based on their ability to manage the minting process responsibly and maintain the collateral backing the issued GHO. These facilitators can create and burn GHO tokens up to a certain limit, allowing depositors to borrow GHO against their collateral in Aave V3's Ethereum mainnet pool. Each facilitator has their own strategy for using GHO tokens, which are backed by excess collateral.

There are currently 4 facilitators for GHO:

*   Aave V3 Facilitator: The Aave V3 Ethereum market is an approved facilitator that enables GHO to be borrowed using collateral supplied to this market
*   CCIP Cross-Chain Facilitator: Enables GHO to be bridged to governance-approved networks by locking/unlocking tokens on Ethereum mainnet and minting/burning tokens on destination networks
*   GHO Stability Module: Enables GHO mint / burn at predetermined ratios
*   Flashmint Facilitator: Mirrors the flashloan functionality of all other Aave reserves

Each Facilitator must be approved by [Aave Governance](https://governance.aave.com/). Aave Governance will be able to determine and assign a Facilitator a specific bucket capacity, the amount of GHO that the Facilitator is able to mint.

Where do users interact with GHO facilitators?
----------------------------------------------

GHO Facilitators can be interacted with directly from [protocol smart contracts](https://aave.com/docs/developers/smart-contracts) or using a frontend interface.

Borrowing and Bridging GHO can be accessed from the [Aave Labs interace](https://app.aave.com/) from the "Dashboard" ad "Bridge GHO" (in top right navigation bar) respectively.

The GHO Stability Module can be accessed from exchanges that have directly integrated it's functionality such as [CoW Swap](https://swap.cow.fi/).</content>
</page>

<page>
  <title>Stability Module</title>
  <url>https://aave.com/help/gho-stablecoin/stability-module</url>
  <content>What is the GHO Stability Module?
---------------------------------

The GHO Stability Module (GSM) allows swaps between GHO and other governance-accepted stablecoins, offering a variety of functionalities where security and risk management are paramount.

Is GHO always fixed 1:1 with the US Dollar?
-------------------------------------------

The GHO Stability Module is based on an existing contract called a Peg Stability Module (PSM) which enables the conversion of two tokens at a predetermined ratio. The GHO Stability Module (GSM) leverages the benefits of existing PSM models while innovating upon them in several ways to help further maintain GHO’s peg. The GSM is designed to facilitate conversions between GHO and governance-approved tokens, underpinned by a suite of features designed for flexible operations and risk management.

The GSM introduces a flexible Price Strategy framework, enabling the module to adapt its pricing mechanism based on market conditions or strategic objectives. This system supports both fixed and dynamic pricing strategies, allowing for adjustments in response to real-time market data or predetermined conditions. The initial implementation focuses on a fixed 1:1 pricing strategy for simplicity and stability, with provisions for future adaptation to dynamic strategies as dictated by DAO governance.</content>
</page>

<page>
  <title>Bridging GHO</title>
  <url>https://aave.com/help/gho-stablecoin/bridging-gho</url>
  <content>Why would I bridge GHO?
-----------------------

GHO was initially only available on Ethereum Mainnet, but has always been designed to be a multi-chain stabelcoin. It is now [available on Arbitrum](https://avara.xyz/blog/gho-stablecoin-now-live-on-arbitrum), and will be added to other networks as decided by Aave Governance. The expanded availability of GHO beyond Ethereum mainnet aims to increase accessibility, lower transaction costs, enhance the user experience, and improve liquidity.

How does GHO bridge between chains?
-----------------------------------

For secure cross-chain transfers between Ethereum and L2s like Arbitrum, GHO uses a lock-and-mint model enabled by Chainlink [CCIP](https://docs.chain.link/ccip), where tokens are locked on Ethereum while an equivalent amount is minted on the other network, keeping the total supply constant. As additional chains are supported, transfers between non-Ethereum chains will use a burn-and-mint model enabled by Chainlink’s CCIP for maximum capital efficiency and fungibility, while still being backed by reserves on Ethereum. This achieves security and flexibility for GHO's future expansion across multiple blockchains. Backed by Chainlink's battle-tested infrastructure, CCIP is widely adopted across DeFi and capital markets and supports existing Aave deployments, helping to achieve smooth and secure cross-chain expansion for GHO.

Bridging GHO can be performed through protocol smart contracts or through a frontend such as [Aave Labs interface](https://app.aave.com/) by performing the following steps:

Step 1: Connect Wallet
----------------------

To begin, press ‘Connect Wallet’ and select the Ethereum wallet provider corresponding to the wallet holding GHO tokens.

Step 2: Open Bridge mMdal
-------------------------

Once the bridge modal by selecting 'Bridge GHO' in top navigation bar .

Step 2: Enter Transfer Details
------------------------------

Enter the amount of GHO you wish to transfer, the source / destination network, and a recipient address (if different than connected wallet).

The interface will display key parameters, including fees and estimated transfer times.

Step 3: Confirm the Transaction
-------------------------------

Review the transfer details, then confirm the transaction in your connected wallet.

The interoperability protocol will burn/lock tokens on source network and mint/unlock on the destination network to the designated recipent address.</content>
</page>

<page>
  <title>Stablecoins</title>
  <url>https://aave.com/help/web3/stablecoins</url>
  <content>* * *

Introduction
------------

Stablecoins are digital assets that aim to keep their value constant relative to a reference asset, most commonly fiat currencies like the U.S. dollar, euro, or yen. Unlike Bitcoin or Ethereum, whose values can fluctuate significantly, stablecoins are designed to be predictable and stable, making them useful for everyday transactions, remittances, and as a safe haven during market turbulence.

Stablecoins bridge the gap between traditional finance and the crypto world. They allow users to transfer value globally without the fear of price fluctuations. Here are a few key uses:

*   **Remittances**: Sending money across borders can be costly and slow. Stablecoins enable faster and cheaper transactions.
*   **DeFi (Decentralised Finance)**: Stablecoins are crucial in the DeFi ecosystem, where they are used for supplying, borrowing, and earning interest.
*   **Hedging**: Traders and investors use stablecoins to move out of volatile assets without converting back to fiat.
*   **Payments**: Merchants can accept stablecoins for goods and services without worrying about price volatility.

How Do Stablecoins Work?
------------------------

Stablecoins achieve stability through various mechanisms:

1.  **Fiat-collateralised Stablecoins**: These are backed by reserves of fiat currency held in a bank account. For every stablecoin issued, an equivalent amount of fiat currency is held in reserve. Examples include **Tether (USDT)** and **USD Coin (USDC)**.
2.  **Decentralised Stablecoins**: These operate without a central authority and are typically issued, redeemed, and governed by smart contracts on a blockchain. Smart contracts can manage the collateral requirements and issuance based on predefined rules in a trustless and transparent process. **Aave’s GHO** is one example of this kind of stablecoin.
3.  **Algorithmic Stablecoins**: These rely on smart contracts and algorithms to maintain their peg. Instead of being backed by reserves, these stablecoins use mechanisms like minting and burning to control the supply and stabilize the price.

* * *</content>
</page>

<page>
  <title>Blockchain</title>
  <url>https://aave.com/help/web3/blockchain</url>
  <content>* * *

Introduction
------------

A blockchain is a decentralised, distributed ledger system designed to record and verify transactions across a network of computers. This compels that no single entity or company controls the entire network, promoting a system of collective agreement and transparency. Unlike traditional databases that rely on central authorities (private servers owned by companies who set all the rules and make all the decisions), blockchains operate on a peer-to-peer network where every participant, known as nodes, has access to the entire ledger (the information is spread across multiple nodes or computers and each has an entire copy of the information). This decentralisation enhances both security and transparency, as each transaction is visible to all participants and cannot be altered without consensus (all nodes agreeing) from the network.

The core of blockchain technology lies in its unique distributed or decentralised structure. Transactions are grouped into units called "blocks." Each block contains a list of transactions that have been validated (consensus) by the network. Once a block is filled with transactions, it is added to the existing chain of blocks in a sequential manner that is time stamped. This process creates a continuous, unalterable chain of blocks, hence the name "blockchain." Each block contains a reference to the previous block, forming a chronological sequence. This structure makes it extremely difficult to alter any information in a block without changing all subsequent blocks, which would require the consensus of the majority of the network.

Decentralised consensus
-----------------------

What sets blockchain apart from traditional databases is its decentralised nature and the consensus mechanisms used to validate transactions. In a traditional system, a central authority, such as a bank or government agency, maintains and verifies transactions. In contrast, a blockchain uses various consensus algorithms, like Proof of Work (PoW) or Proof of Stake (PoS), to achieve agreement among nodes. This is how transactions are verified and proved valid. These algorithms validate that all participants agree on the state of the ledger, making it nearly impossible for a single participant to manipulate or fraudulently alter the data.

Blockchains are best known as the underlying technology behind cryptocurrencies such as Bitcoin and Ethereum and they are the base technology of web3. Bitcoin, the first and most well-known cryptocurrency, was created to provide a decentralised digital currency that operates without the need for intermediaries like banks. Its blockchain serves as a public ledger where every transaction is recorded and verified by network participants (nodes), safeguarding the integrity and security of the currency. Similarly, Ethereum introduced the concept of 'smart contracts'—self-executing digital agreements that run on blockchain technology, enabling trustless execution of transactions.

How the Ethereum blockchain works
---------------------------------

Ethereum, launched in 2015, is a blockchain that extends beyond simple transactions by enabling the creation of decentralised applications (dApps) and smart contracts. Here’s an overview of how Ethereum’s blockchain operates:

1.  **Smart Contracts:** Smart contracts are self-executing contracts with the terms of the agreement written directly into code. They run on the Ethereum Virtual Machine (EVM), a decentralised computing environment that executes the code (terms and conditions) of smart contracts. When a network participant interacts with a smart contract, the contract executes the agreed-upon actions, such as transferring funds or updating records. Smart contracts enable trustless transactions that don't need to be verified by intermediaries.
2.  **Ethereum Virtual Machine (EVM):** The EVM is a critical component of Ethereum. It provides a runtime environment for executing smart contracts and dApps. The EVM is decentralised, meaning that the execution of code occurs across all nodes in the Ethereum network. Distributed execution validates that smart contracts are executed consistently and transparently.
3.  **Ethereum Accounts:** Ethereum supports two types of accounts—externally owned accounts (EOAs) and contract accounts. EOAs are controlled by private keys and can send and receive Ether (ETH), the native cryptocurrency of Ethereum. Contract accounts, on the other hand, are controlled by the code of smart contracts and can interact with EOAs and other contracts.
4.  **Transactions and Gas:** Transactions on the Ethereum network involve sending Ether or interacting with smart contracts. Each transaction requires a certain amount of computational work, measured in "gas." Gas is a unit of measure for computational effort, and users must pay for gas to execute transactions and smart contracts. Gas costs exist so that the network remains efficient and prevents spam or abuse.
5.  **Consensus Mechanism - Proof of Stake (PoS):** Ethereum initially used Proof of Work (PoW) as its consensus mechanism, but it has transitioned to Proof of Stake (PoS) with the Ethereum 2.0 upgrade. PoS is a more energy-efficient consensus algorithm where validators are chosen to create new blocks based on the amount of cryptocurrency they hold and are willing to "stake" as collateral. Validators are rewarded for participating in the network and safeguarding its security, while also being penalized for dishonest behavior.
6.  **Interoperability and Tokens:** Ethereum’s blockchain also enables the creation of various tokens through standards such as ERC-20 and ERC-721. ERC-20 tokens are fungible tokens used for creating cryptocurrencies and other digital assets. ERC-721 tokens are non-fungible tokens (NFTs) that represent unique digital items or assets. These tokens expand Ethereum’s functionality and facilitate the development of diverse applications and ecosystems.

* * *</content>
</page>

<page>
  <title>Web3</title>
  <url>https://aave.com/help/web3/web3</url>
  <content>Introduction
------------

Web3 is the next evolution of the internet where people have control and ownership over their data, the relationships they form online, and their user profile. Together, these make up "social capital:" Everyone has it, and it's valuable. In contrast, today when we get on the internet, we go to sites owned by large companies, who own our social capital. These "web2" companies like Amazon, Facebook and Google store user data on privately-held servers and sell it to advertisers in exchange for providing free services. This has lead to a good experience for users (free, easy-to-use networks and applications) but has also caused privacy issues, data manipulation, and limited monetisation options. Web3 addresses these issues by using blockchain technology. This technology is based on user ownership. When people own their data, they can monetise however they want, take their digital information with them (profile, content, data) when they switch networks, and it has the benefit of putting people and apps/networks, on an equal footing. Web3 enables a more open and balanced internet, where people have ownership, control, and a stake and a voice in the future of the internet.

To understand the significant difference between the internet we know today (web2) and web3, take a step back.

When the internet first came about, it was hard to access because there were no easy-to-use applications. Web1 was built on open, public protocols or applications such as TCP, IP, SMTP, and HTTP that builders could develop on top of, plugging into these protocols to create whatever applications or platforms they wanted. Nobody needed permission to use these foundational protocols or standards to build user-friendly applications like email browsers and marketplaces. These standards are the basic building blocks of the internet. They govern how computers interact with each other and the flow of information. Today, in many senses, we are locked into platforms that own our data.

Web3 is digital ownership
-------------------------

The core idea of web3 is to give users ownership of their social capital and spur new innovation. Based on blockchain technology, web3 allows for a multitude of monetisation models and allows builders to create new user experiences and monetisation models that are not necessarily dependent on user data mining and advertisers.

Instead of relying on centralized web2 platforms, web3 enables peer-to-peer exchanges. This approach not only improves security but also creates a more open and fair internet where users have more control over their experiences online. With web3, users can choose to take their social capital (profile, content, relationships and data) to any other web3 platform, so they are not locked into centralized servers and large platforms that control monetisation and their social capital. Web3 blockchain technology is decentralised, meaning data is stored across multiple servers, but user social capital is owned by the user.

Websites or applications that use wallets to manage identity and value are referred to as ‘dApps’ (decentralised apps). DApps run on decentralised blockchain networks rather than traditional servers. One of the key reasons for apps to be decentralized is so that they are more resistant to censorship and technical failures, such as data breaches. This decentralised nature supports a more resilient, fair and balanced online environment, where users are not constrained by large companies that mine and control data and make all governance decisions, whether it is an interest rate or an algorithm.

Web3 is a better option for creators
------------------------------------

Many web2 platforms promise users freedom to earn directly from their fans instead of relying on ad-driven, attention-based monetisation models, but don’t give their creators power over the economics of the platform. Web3 supports more creator-centric models for monetisation and distribution. The content they create on one platform, connected by a wallet identity, can travel with them to other websites. With fungible (non-unique) or non-fungible (one of a kind) tokens, creators have a number of ways to connect with their fan base. Most importantly, creators retain their relationship with their followers and fans if they decide to move to another platform.

Decentralised Finance is a category of Web3
-------------------------------------------

Web3 opens up the opportunity for many types of new user experience, networks or user application. One such use use case is decentralised finance, or DeFi. DeFi brings significant advancements to the financial sector, creating greater access as well as enabling faster, more cost-effective, transparent, and secure transactions globally. DeFi protocols or applications like Aave Protocol enable access to financial features or primatives such as supplying cryptographic assets (liquidity) into a market (pool) to earn yield on those assets, and it also enables users to borrow agains their assets in an overcollateralised way without requiring centralized intermediaries. DeFi utilizes 'smart contracts,' or self-executing digital agreements that run on blockchain technology, allowing for trustless execution of transactions. DeFi provides greater transparency, lower costs, and broader access to financial services and as a result, democratizes financial systems, making them available to anyone with an internet connection and cryptographic assets.</content>
</page>

<page>
  <title>Crypto Wallets</title>
  <url>https://aave.com/help/web3/wallets</url>
  <content>* * *

Introduction
------------

In the context of blockchain and cryptocurrencies, wallets are digital tools that enable users to store, send, and receive digital assets securely. These wallets come in different forms—such as hardware wallets, software wallets, and web wallets—each offering a balance between security and convenience. Similar to how browsers serve as your gateway to the internet, wallets serve as your gateway to interacting with web3. Crypto wallets also help you manage permissions with whom you share your data, store cryptocurrency, NFTs, and more.

Self-custody
------------

One of the most important features of blockchain wallets is self-custody, where users maintain full control over their private keys. The moment your crypto wallet is created, a unique phrase is generated, known as a “seed phrase” or a “recovery phrase.” You can think of this 12-word phrase as a master password that you need to keep secret and secure. This means that users are the sole custodians of their assets, allowing them to independently verify their balances and transactions without relying on third parties.

Public addresses and private ownership
--------------------------------------

A blockchain wallet consists of two key components: public address and a method of securing ownership (private key or smart contract rules). The public address is what users share to receive assets, functioning similarly to an account number or username in traditional online services. The method of securing ownership, varies depending on the type of wallet. There are two fundamental types of wallets:

*   Private key wallets, often referred to _EOAs_ (externally owned accounts). In this wallet type, the private key is used to sign transactions and verify ownership of the associated wallet.
*   Smart contract wallets, often referred to as _smart accounts_. In this wallet type, their ownership rules can be customized through code which enables more complex functionalities such as multi-signature approvals (multisig), batched transactions, and more.

The choice of a wallet and the method used to back up a wallet are important decisions given the irreversible nature of blockchain transactions. To learn more about wallets and explore potential options, you can refer to [this guide](https://ethereum.org/en/wallets/) from the Ethereum Foundation.

* * *</content>
</page>

<page>
  <title>Smart Contracts</title>
  <url>https://aave.com/help/web3/smart-contracts</url>
  <content>* * *

Introduction
------------

Smart contracts are self-executing programs that automate agreements by encoding the terms directly into code. When an address interacts with a smart contract, the contract executes the agreed-upon actions, such as transferring assets or updating internal accounting. This automation eliminates the need for intermediaries, making transactions more efficient and reducing the potential for human error or manipulation. By relying on code rather than a third parties, smart contracts enable trustless and transparent operations, enabling all parties involved to have confidence in the outcome.

Smart contracts are integral to many blockchain applications, as they are executed by blockchain networks like Ethereum, which functions as a global computer network. These networks process and validate the conditions set within each smart contract, updating the state of the contract with every new block added to the chain. This decentralised execution validates that smart contracts run precisely as programmed, without the risk of interference or manipulation. The combination of immutability and public auditability (transparency) in smart contracts provides a high level of trust and security, making them a foundational element in the development of decentralised applications such as identity, finance, and more.

How smart contracts work
------------------------

Here’s a more detailed breakdown of how smart contracts function on Ethereum and EVM-based networks:

1.  **Interaction and Execution:** Once a smart contract is deployed, it awaits interactions from users or other contracts. When a transaction is submitted to the smart contract, it triggers the contract’s code. For example, in a decentralised liquidity protocol, a smart contract might transfer funds from a liquidity pool to a borrower upon the completion of certain criteria, such as collateral verification and interest calculation.
2.  **Consensus and Validation:** In blockchain networks like Ethereum, the execution of smart contracts is validated by a consensus mechanism. Each node in the network processes the contract’s code and verifies that the conditions are met before executing any actions. This decentralised validation enforces that the contract operates consistently and fairly, according to its programmed logic.

Benefits of smart contracts
---------------------------

Smart contracts offer several significant benefits that enhance the efficiency, security, and reliability of transactions:

**Predictability:** By encoding the terms of an agreement directly into code, smart contracts validate that actions are carried out exactly as specified. This predictability minimizes human error and operational inefficiencies.

**Trustless Operations:** One of the defining features of smart contracts is their ability to operate in a trustless environment. Trustless means that parties involved in the contract do not need to trust each other or a third party; they can rely on the code to enforce the agreement. This trustless nature is achieved through the blockchain’s decentralised architecture, which enforces that the contract’s execution is transparent and tamper-proof.

**Transparency:** All interactions with smart contracts are recorded on the blockchain, creating an immutable and publicly accessible ledger. This transparency allows participants to verify the contract’s terms and actions, promoting accountability and trust. Any changes or updates to the contract are visible to all network participants, ensuring that the contract operates in an open and transparent manner.

**Security:** The decentralised nature of blockchain networks provides a high level of security for smart contracts. Once deployed, smart contracts are protected by the blockchain’s cryptographic algorithms, making them resistant to tampering and unauthorized access. The immutability of the blockchain enforces that once a contract is written and deployed, its terms cannot be altered without network consensus.

**Cost Efficiency:** By eliminating intermediaries such as brokers, agents, or legal representatives, smart contracts reduce transaction costs. The automation of processes and the removal of middlemen streamline operations, leading to cost savings for all parties involved. This efficiency is particularly valuable in complex financial transactions, global transactions, and multi-party agreements.

* * *</content>
</page>

<page>
  <title>DeFi</title>
  <url>https://aave.com/help/web3/defi</url>
  <content>Introduction
------------

Decentralised Finance, or DeFi, leverages blockchains and smart contracts to create an open, transparent, and decentralised financial ecosystem. At its core, DeFi aims to improve upon traditional financial systems without the reliance on centralized institutions such as banks, brokers, and financial intermediaries. DeFi offers a novel approach to financial services, marked by increased accessibility, transparency, and control for users.

DeFi operates on blockchain networks, with Ethereum being the first and most prominent platform. Most of the first DeFi applications are also now deployed on Layer 2 blockchains, such as Arbitrum, Optimism, and ZKSync. Unlike traditional financial systems that rely on intermediaries to process and verify transactions, DeFi uses decentralised networks to perform these functions. By removing intermediaries, DeFi aims to lower costs, reduce barriers to entry, and enhance the efficiency of financial transactions.

Central to the DeFi ecosystem are smart contracts (see [Smart Contracts](https://aave.com/help/[guide]/smart-contracts.mdx)) — self-executing programs that automate the execution of financial agreements based on predefined conditions. In a decentralised liquidity protocol like Aave, a smart contract validates the collateralisation of a borrow position and handles distribution of tokens in supply, borrow, repay, withdraw, and liquidation interactions. The use of smart contracts establishes that transactions are executed as programmed, without the need for manual intervention. This approach enables the protocol to operate continuously and also reduces the potential for human error or manipulation.

Open access
-----------

One of the key benefits of DeFi is its ability to provide open access to financial services. Traditional financial systems often require intermediaries and come with various barriers, such as high fees, geographic limitations, and stringent eligibility criteria. DeFi platforms, in contrast, are designed to be inclusive, allowing anyone with an internet connection to participate. This open access is made possible by the decentralised nature of blockchain networks, which do not discriminate based on geographic location or socio-economic status.

Transparency is another fundamental aspect of DeFi. Transactions and interactions within DeFi platforms are recorded on public blockchains, creating an immutable and transparent ledger. This means that all participants can view and verify transactions, which fosters trust and accountability. The transparency of DeFi platforms enables users to track the flow of assets and audit the operations of smart contracts, thereby reducing the risk of fraud and manipulation.

The programmability of smart contracts is a defining feature of DeFi. These contracts allow for the creation of complex financial products and services by encoding business logic into code. For example, DeFi platforms can create automated investment strategies, decentralised derivatives, and synthetic assets that mirror traditional financial instruments. This programmability provides developers with a high degree of flexibility and customization, enabling them to tailor financial products to their specific needs.

DeFi applications
-----------------

DeFi encompasses a wide range of financial services and components, each contributing to the overall ecosystem. Decentralised exchanges (DEXs) are a prominent example, allowing users to swap cryptocurrencies and other digital assets directly with one another, without the need for a centralized exchange. DEXs operate through smart contracts that facilitate trades, manage liquidity, and determine prices. This peer-to-peer trading model enhances security and reduces reliance on intermediaries.

Liquidity protocols such as Aave are another crucial component of DeFi. These platforms enable users to supply assets and earn interest or borrow assets by providing collateral. The process is automated through smart contracts, which determine interest rates, manage collateral, and handle repayments. By eliminating intermediaries and automating the liquidity provisioning process, DeFi platforms offer more efficient and accessible financial services.

[Stablecoins](https://aave.com/help/[guide]/stablecoins.mdx) play a significant role in the DeFi ecosystem by providing a stable medium of exchange. Unlike traditional cryptocurrencies, which can be highly volatile, stablecoins are designed to maintain a stable value relative to a fiat currency, such as the US Dollar. This stability is achieved through various mechanisms, such as being backed by reserves or collateralised by other assets. Stablecoins are essential for facilitating transactions, reducing price volatility, and serving as a reliable store of value within the DeFi ecosystem.

Decentralised Autonomous Organizations (DAOs) represent a governance model that allows for decentralised decision-making within DeFi projects. DAOs are organizations governed by smart contracts and operated by community members who hold governance tokens. These tokens grant voting rights on proposals and protocol upgrades, enabling collective decision-making and overseeing that the direction of the project reflects the interests of its community. DAOs enhance the democratic nature of DeFi and provide a mechanism for community-driven development.

DeFi risks
----------

Despite its many advantages, DeFi faces several challenges and risks. Smart contract vulnerabilities are a significant concern, as bugs or exploits in the code can lead to security breaches or loss of funds. Rigorous testing, third-party code audits, and formal verification are essential to mitigate these risks and enhance the reliability of DeFi platforms.

Market risks and volatility are inherent in the DeFi space. The value of assets, including cryptocurrencies and tokens, can experience significant fluctuations, affecting the stability and profitability of DeFi investments. Users should be aware of these risks and conduct thorough research before participating in DeFi activities.

Scalability and network congestion are also concerns for DeFi platforms, particularly those operating on the Ethereum network. High demand for DeFi services can lead to network congestion and increased transaction fees. Solutions such as Layer 2 networks help improve the costs and speed of DeFi protocols.

Security and custodial risks are important considerations in DeFi. While blockchain technology offers enhanced security through decentralisation and cryptographic mechanisms, users must take precautions to protect their private keys and wallets. Loss or theft of these credentials can result in the loss of assets, highlighting the importance of securing one's personal keys.</content>
</page>