# Warden Protocolの調査メモ

## Wardenプロトコルとは
Wardenプロトコルは、AIをWeb3にもたらし、安全なAIをあらゆるアプリケーション、プロトコル、またはスマートコントラクトに統合できるL1ブロックチェーンです。

Web3の大規模普及には、安全でシームレスなAI体験の構築が必要です。Wardenは、開発者がこの目標を達成できるよう支援します。

## AIブロックチェーンインターフェース (AIBI)
Wardenは、人工知能ブロックチェーンインターフェース（AIBI）をサポートしています。

AIBIは、開発者がアプリケーションにAIを統合するための直感的なインターフェースを提供し、AIをオンチェーン化します。計算証明と計算パイプラインのアイデアに基づき、AIBIはAIモデルが特定の予測を生成したことを証明する暗号学的証明を作成します。これらの証明は、Wardenの新しいコンセンサスメカニズムを通じてブロックチェーン上で検証され、AIの出力が信頼できることを保証します。

### WardenでのAI統合レイヤー
1. **検証レイヤー**  
   Wardenは、AIを安全にオンチェーン化するために設計されています。この検証レイヤーでは、ブロックチェーン、暗号技術、コンセンサスを活用してAIの結果が正しいことを検証します。

2. **実行レイヤー**  
   AIをアプリケーション、プロトコル、スマートコントラクトに簡単に統合できます。さらに、あらゆるチェーンでの実行を自動化します。

## プロトコルの主な特徴
Wardenの主な機能により、真にオープンなAI体験が可能になります。

- **AI対応**  
  アプリケーションにAIを簡単に統合し、新しいAI駆動のWeb3体験を楽しめます。

- **簡略化された暗号技術**  
  Wardenを使用すると、意図駆動型のキー管理を活用してWeb3アプリケーションを簡単に開発できます。

- **抽象化された相互運用性**  
  複数チェーンのアカウントを集約し、任意の目的チェーンでトランザクションに署名できるアプリケーションを構築可能です。

## Wardenでできること

### アプリケーションへのAI統合
Wardenを利用すると、アプリケーション、プロトコル、またはスマートコントラクトにAIを統合して新しいユーザー体験を提供できます。

### アプリケーションの構築
オムニチェーンアプリケーション（OApp）は、任意のチェーンでトランザクションに署名できるスマートコントラクトです。例えば、「SpaceWard」は、プロトコルのフロントエンドインターフェースとして機能するアプリケーションです。EVM互換のOAppをSolidityやRust & CosmWasmでデプロイできます。

### キーチェーンの運用
キーチェーンは、キーの生成・保管およびトランザクションの署名を行うカストディアンです。キーチェーンはほぼすべてのチェーンでトランザクションを署名できるため、手動のクロスチェーン調整を回避できます。キーチェーン運用者になるか、カスタムキーチェーンを構築できます。

### バリデータノードの運用
バリデータノードを運用し、Wardenネットワークのセキュリティを確保しながら報酬を得ることができます。

## ドキュメント概要
Wardenプロトコルのドキュメントへようこそ！

トップメニューを使用してドキュメントの主要セクションをナビゲートし、Wardenに参加する方法を学びましょう。

- **Learn**: プロトコルの基本情報
- **Build an App**: アプリケーション開発者向けガイド
- **Build a Keychain**: キーチェーン運用者向けガイド
- **Operate a Node**: ノード運用者向けガイド
- **Tokens**: Wardenトークン（WARDとWARP）の詳細概要
- **SpaceWard**: フロントエンドOApp「SpaceWard」のユーザーガイド

### 貢献
プロトコルに貢献したい場合は、GitHubのプロトコル開発者向けドキュメントをご覧ください。

## AIブロックチェーンインターフェース (AIBI) アルファリリース
AIBI（人工知能ブロックチェーンインターフェース）のアルファ版をリリースしました。

AIBIは、開発者がアプリケーションにAIを統合するための直感的なインターフェースを提供し、AIをオンチェーン化します。計算証明と計算パイプラインのアイデアに基づき、AIBIはAIモデルが特定の予測を生成したことを証明する暗号学的証明を作成します。これらの証明は、Wardenの新しいコンセンサスメカニズムを通じてブロックチェーン上で検証され、AIの出力が信頼できることを保証します。

### WardenでのAI統合レイヤー
1. **検証レイヤー**  
   Wardenは、AIを安全にオンチェーン化するために設計されています。この検証レイヤーでは、ブロックチェーン、暗号技術、コンセンサスを活用してAIの結果が正しいことを検証します。

2. **実行レイヤー**  
   AIをアプリケーション、プロトコル、スマートコントラクトに簡単に統合できます。さらに、あらゆるチェーンでの実行を自動化します。

## 用語集

## 抽象構文木 (Abstract syntax tree)
抽象構文木（AST）は、承認ルール定義を正式に表現するものです。以下の手順で作成されます：

1. ユーザーが、意図特定言語（Intent-Specific Language）を使って新しい承認ルールを定義します。
2. トークナイザーが承認ルールを、意図特定言語の最小要素に分割してトークン化します。
3. パーサーが定義の構文構造を検証し、ASTとして表現しオンチェーンに保存します。

---

## アクション (Action)
アクションは、Wardenプロトコル上のオンチェーンアクション（トランザクション）です：

- スマートコントラクトの実行（例：UniSwapでETHをMATICにスワップする）
- キーリクエストや署名リクエスト
- SpaceWardでメンバーをスペースに追加する

アクションは、ユーザー定義の承認ルールに基づいて承認が与えられた後に発生します。将来的には、Slackチャンネルへのメッセージ送信のようなオフチェーンアクションも実装予定です。

---

## AIブロックチェーンインターフェース (AIBI)
AIブロックチェーンインターフェース（Artificial Intelligence Blockchain Interface、AIBI）は、AIをオンチェーンに統合するための開発者向けの直感的なインターフェースを提供します。計算証明や計算パイプラインに着想を得て、AIBIはAIモデルが特定の予測を生成したことを暗号的に証明する仕組みを提供します。これにより、AIの出力は単に配信されるだけでなく、信頼性が確保されます。

---

## 承認 (Approval)
承認とは、アクションが実行されるための許可のことです。承認は、ユーザー定義の承認ルールに基づいて付与されます。

---

## 承認ルール (Approval Rule)
承認ルールは、アクションを実行する条件をユーザーが定義したものです。例えば、「3人の承認者のうち2人が署名した場合にのみトランザクションを実行する」といったルールを設定できます。

意図特定言語を使って承認ルールを意図（Intent）の一部として定義できます。WardenのIntent Engineは、抽象構文木として表現されたルールを確認してトランザクションの妥当性を保証します。

---

## ボンデッドバリデーター (Bonded validator)
ボンデッドバリデーターは、コンセンサスに参加しているアクティブなバリデーター（ステーキング中）です。これらのバリデーターは、トランザクションを検証し、ブロックを提案し、ネットワークへの貢献に対して報酬を得ます。

関連項目：アンボンデッドバリデーター、アンボンディングバリデーター

---

## ブリッジング (Bridging)
ブリッジングは、異なるブロックチェーンネットワーク間で資産を転送できる技術です。この技術では、送信元チェーンでトークンを受け取りロックし、対応する数のラップトークンを宛先チェーンでミントします。Wardenは現在、Axelarを利用したブリッジングをサポートしています。

詳しくはこちら: [ブリッジング](#)

---

## ビルダーインセンティブ (Builder incentive)
Wardenプロトコルは、サードパーティによるコアプロトコル開発やWardenエコシステム内でのOmnichain Applicationの構築を奨励しています。これらの貢献にはWARDで報酬が与えられます。詳細は後日発表予定です。

---

## デリゲーター (Delegator)
デリゲーターは、WARDトークンをバリデーターに委任してステーキングプロセスに参加する個人や団体です。委任により、ネットワークを保護しつつ、バリデーターと報酬を共有できます。

全てのデリゲーターは、自分のバリデーターの状態（ボンデッド、アンボンディング、アンボンデッド）を引き継ぎます。リスクを避けるため、デリゲーターはバリデーターの調査を行い、ステークを複数のバリデーターに分散することを推奨します。デリゲーターは、ガバナンスにも参加できます。

---

## フルノード (Full node)
フルノードは、プロトコルの完全で最新のトランザクション履歴を維持するソフトウェアを実行するサーバーです。Wardenプロトコルのフルノードを自分で実行することも可能です。

---

## ガバナンス (Governance)
Wardenプロトコルはオンチェーンガバナンスをサポートしています。これは、分散型コミュニティが直接投票によってプロトコルを更新できる仕組みであり、投票内容はオンチェーンに記録されます。

投票は、ステーキングに参加しているバリデーターとデリゲーターが行えます。投票権は、バリデーターの重みやデリゲーターがステーキングしたWARD量に依存します。

---

## Intent（インテント）
インテントとは、以下を指定するユーザー定義のスクリプトです：
- **アクション**: Warden Protocolで実行されるオンチェーンのアクション
- **承認ルール**: アクションが実行される条件のセット

アクションが開始されると、インテントエンジンが承認ルールを確認します。条件が満たされている場合、承認が与えられ、アクションが実行されます。

---

## Intent Engine（インテントエンジン）
インテントエンジンは、インテント専用言語を解釈するオンチェーンの不変な解釈装置であり、ゲートキーパーとして機能します。ユーザーがトランザクション（アクション）を開始すると、インテントエンジンは抽象構文木として表現されたユーザーの承認ルールをチェックし、真（承認）または偽（非承認）を返します。

---

## Intent-Specific Language（インテント専用言語）
インテント専用言語（ISL）は、ユーザーが承認ルール（インテントの一部）を設定できる言語です。この言語は以下の特長を持ちます：
- **組み合わせ可能**
- **拡張可能**
- **宣言型**
- **人間が読める**
- **英語に似た構文**

この言語はインテントエンジンによって解釈されます。

---

## Key（キー）
ブロックチェーンでのキーは、ユーザーを識別しウォレットの所有権を保護するためにペアで使用されます：
- **公開鍵**: 公開ウォレットアドレス
- **秘密鍵**: ウォレットでトランザクションに署名するための秘密コード

Wardenはモジュラーキー管理を提供しており、Keychainを使ってキーのペアを生成し、トランザクションに署名できます。

---

## Key request（キーリクエスト）
キーリクエストは、Keychainに公開鍵と秘密鍵のペアを生成するよう依頼するリクエストです。Keychainオペレーターはキーリクエストに対して手数料を設定できます。リクエスト処理の流れは以下の通りです：
1. ユーザーが、希望するKeychainを識別するKeychain IDを含むキーリクエストを送信します。
2. インテントエンジンが、インテント内で指定されたユーザーの承認ルールを確認します。
3. 承認ルールが満たされると、Keychainがキーのペアを生成し、秘密鍵を保存します。Keychain Writerが公開鍵をWarden Protocolに公開します。

[詳細はこちら: Key request flow](#)

---

## Key request fee（キーリクエスト手数料）
Keychainオペレーターは、キーリクエストに対してWARDで手数料を設定できます。手数料はKeychainのIDに収集され、オペレーターが管理します。手数料はaWARD（0.000000000000000001 WARD）で示されます。

---

## Keychain（キーチェーン）
すべてのOmnichainアプリケーションには少なくとも1つのKeychainがあり、これは鍵を生成・保存しトランザクションに署名する役割を担います。KeychainはWardenのモジュラーキー管理とセキュリティに貢献します。

Warden Protocolでは、ユーザーや外部組織がKeychainオペレーターになることができます。Keychainを導入し、キーリクエストや署名リクエストに対して手数料を請求できます。通常、KeychainオペレーターはMPCネットワークを使用してキーと署名を生成します。

[詳細はこちら: Build a Keychain](#)

---

## Keychain ID（キーチェーンID）
Keychain IDは、キーリクエストや署名リクエストでKeychainを識別し、ユーザーからの手数料を収集します。

---

## Keychain Writer（キーチェーンライター）
Keychain Writerは、Keychainに代わって署名や公開鍵を公開するアカウントです。キーリクエストや署名リクエストに応答する際に使用されます。Keychainオペレーターは、アドレスごとに複数のWriterを作成できます。

---

## Keychain SDK（キーチェーンSDK）
Keychain SDKは、Warden Protocolノードとの通信を抽象化し、Keychainの開発を簡素化するGo言語のSDKです。

[詳細はこちら: Keychain SDK](#)

---

## Modular Key Management（モジュラーキー管理）
モジュラーキー管理は、Wardenにおける柔軟な鍵管理アプローチです。1つのプロバイダーに依存せず、異なるKeychainで異なる鍵を管理できます。この仕組みにより、単一障害点のリスクを軽減し、ユーザーが鍵をより自由に管理できるようになります。

---

## Modular Security（モジュラーセキュリティ）
モジュール性により、同じOmnichainアプリケーションで異なるセキュリティモデルを組み合わせることが可能です：
- OAppユーザーは承認ルールやKeychainを利用して自分のアプリケーションセキュリティを設定・管理できます。
- 各OAppはプロトコルにステークされたすべてのトークンによって集団的に保護されます。

アプリケーション層とプロトコル層のセキュリティを分離することで、単一構造型や孤立型セキュリティシステムの利点を組み合わせつつ、それぞれのリスクを軽減します。

---

## WARPトークン
WARPはWARDの動的な対となるもので、Warden Protocolエコシステムに流動性とゲーミフィケーションを追加します。革新的なトークノミクスを通じて、エンゲージメントと参加を促進します。

詳細: [WARPトークン](#)

## YieldWard
YieldWardは、複数のプロトコルを通じて収益を自動化し最適化するスマートな利回りジェネレーターであるOmnichain Applicationです。YieldWardは、利回りとステーキングの体験を簡略化し、効率的な管理、分散型セキュリティ、最適な収益を提供します。

詳細: [YieldWardのドキュメント](#)

---

## 近日登場の機能

### エージェント（Agent）
エージェントは、人工知能によって駆動される自律的なトレーニング可能なプログラムです。エージェントは高度なスマートワークフローを実行し、人間による直接的な介入を必要とせずに複雑なプロセスを管理します。

※この新機能は近日公開予定です。

### トリガー（Trigger）
トリガーは、データの更新を監視し、ワークフローを開始するイベントリスナーです。トリガーには以下の2種類があります：

- **オンチェーントリガー**: オラクルからの価格フィードの変更など、オンチェーンイベントを監視します。
- **オフチェーントリガー**: Slackのメッセージ、Googleスプレッドシートの更新などを追跡します。オフチェーントリガーは、WebhookやAPIコールを通じて実装できます。

※この新機能は近日公開予定です。

### ワークフロー（Workflow）
ワークフローは、エージェントによって実行される一連の具体的なステップであり、Intentによって定義されます。各ワークフローには、以下のステップの少なくとも1つが含まれます（必ずしも順序通りではありません）：

1. トリガーがデータ更新を登録します。
2. 承認が受け取られます。
3. エージェントがアクションを実行します。

## Warden Protocol モジュール

Warden Protocol モジュールは、Warden Protocol のロジックのほとんどを含む Cosmos SDK モジュールです。

ユーザーは、トランザクションを送信したり、ノードにクエリを送ることで、これらのモジュールとやり取りできます。

このセクションの記事では、以下のモジュールについて説明しています：

- **x/warden**: ユーザーが自分のスペースを作成・管理し、ペイロードに署名するためのキーチェーンを要求できるようにします。
- **x/act**: 特定の条件（ルール）の下で任意のメッセージ（アクション）を実行します。
- **外部モジュール**: x/gmp、x/wasm など。

# 使用方法
当社のモジュールは、Omnichain アプリケーションの開発者が EVM と WASM スマートコントラクトを展開し、これらのコントラクトで Warden 機能を使用できるようにします：

| モジュール      | 機能                             | 使用方法                      |
|----------------|----------------------------------|-------------------------------|
| **x/evm**      | EVM スマートコントラクトの展開と実行 | EVM コントラクトを展開する      |
| **x/wasm**     | WASM スマートコントラクトの展開と実行 | WASM コントラクトを展開する     |
| **x/warden**   | スペース、キーチェーン、キーの管理   | x/warden とやり取りする         |
| **x/act**      | ルールに基づいてアクションを実行    | EVM コントラクトで x/act プレコンパイルを呼び出す |
| **x/gmp**      | クロスチェーンメッセージの送受信     | クロスチェーンアプリを展開する  |
| **x/oracle**   | オラクルサービスからの価格取得     | 近日公開予定                   |

## x/warden

### 概要
x/wardenモジュールは、ユーザーがスペースを作成・管理し、ペイロードに署名するためにキーチェーンを要求できるCosmos SDKモジュールです。

このモジュールはWardenの基本的な概念を実装しており、これらの概念は用語集に記載されています。

- **Space（スペース）**
- **Keychain（キーチェーン）**
- **Key（キー）**

### 使用方法
EVMスマートコントラクトからx/wardenモジュールを呼び出すことができます。これにはx/wardenプレコンパイルを使用します。このセクションではその方法を説明します。

### 概念

#### Space（スペース）
Spaceは、共通のルールを共有するユーザー（オーナー）の集合です：

- **Admin Rule（管理者ルール）**: スペースのオーナー追加や削除など、管理操作に適用されます。
- **Signing Rule（署名ルール）**: 新しいキーのリクエストや署名など、署名操作に適用されます。
- **Default Rule（デフォルトルール）**: ルールが指定されていない場合に適用されます。スペースのオーナーのうち1人でも承認すれば、どんな操作でも許可されます。

#### Key（キー）
キーは、オンチェーンに保存されるキーペアの公開部分です。各キーは特定のスペースに属します。

キーには一意の識別子があり、この識別子はペイロードに署名するためにキーチェーンに要求される際に使用されます。

#### Keychain（キーチェーン）
キーチェーンは、ユーザーからのキーリクエストや署名リクエストを処理します。オプションで、各リクエストに手数料を設定することもできます。

キーチェーンはオンチェーンに登録されます。各キーチェーンには以下のものが含まれます：

- キーチェーン情報を更新できる管理者のリスト
- リクエストの更新を送信できる唯一のアドレスであるWriterのリスト

#### Analyzer（アナライザー）
Analyzerは、CosmWasmコントラクトであり、ペイロードがキーチェーンによって署名される前にそのペイロードをインターセプトすることができます。アナライザーを使用すると、キーチェーンはペイロードの内容を知らなくても、最終的なペイロードを受け取ることができます。

アナライザーは次のことを行うことができます：

- ペイロードのメタデータを抽出し、それをルール式で参照できるようにする
- ペイロードを署名する前に操作する（例：特定のアルゴリズムでハッシュ化する）

#### State（状態）
x/wardenモジュールは、以下の主要なオブジェクトの状態を保持します：

- スペース
- キー
- キーチェーン
- キーリクエスト
- 署名リクエスト

この状態を管理するために、モジュールは次のインデックスも保持しています：

- スペースIDごとのキー
- オーナーアドレスごとのスペース
- ルール

#### メッセージ

**MsgNewSpace**
新しいスペースを作成します。オプションで次の項目を指定できます：

- 管理者ルール
- 署名ルール
- 追加のオーナー

**MsgNewKeychain**
新しいキーチェーンを作成します。次の項目を指定できます：

- 人間が読める説明
- キーリクエストの手数料（オプション）
- 署名リクエストの手数料（オプション）

**MsgUpdateKeychain**
指定されたIDのキーチェーンを更新します。次の項目を指定できます：

- 人間が読める説明
- キーリクエストの手数料
- 署名リクエストの手数料

**MsgAddKeychainWriter**
新しいWriterをキーチェーンに追加します。

**MsgFulfilKeyRequest**
指定されたIDのキーリクエスト（KeyRequest）を更新します：

- 成功した場合は、公開キーのバイトを送信します。
- 失敗した場合は、人間が読める理由を送信します。

**MsgFulfilSignRequest**
指定されたIDの署名リクエスト（SignRequest）を更新します：

- 成功した場合は、署名バイトを送信します。
- 失敗した場合は、人間が読める理由を送信します。

#### アクション

以下のメッセージは、x/actモジュールのアクション内でラップする必要があります（ユーザーが直接実行するのではなく）。

**MsgAddSpaceOwner**
スペースにオーナーを追加します。

**MsgRemoveSpaceOwner**
スペースからオーナーを削除します。

**MsgUpdateSpace**
スペースの管理者ルールと署名ルールを更新します。

**MsgNewKeyRequest**
指定されたキーチェーンに対して新しいキーリクエスト（KeyRequest）を作成します。新しいキーは指定されたスペースに属します。

**MsgUpdateKey**
指定されたIDのキーを更新します。

**MsgNewSignRequest**
指定されたキーとキーチェーンに対して新しい署名リクエスト（SignRequest）を作成します。

---

## x/act

### 概要
x/actモジュールは、ユーザーが定義した条件（ルール）に基づいてメッセージ（アクション）を実行するCosmos SDKモジュールです。

このモジュールは以下の概念を実装しており、これらの概念は用語集に記載されています：

- **Approval Rule（承認ルール）**
- **Action（アクション）**
- **Intent-Specific Language（特定意図言語）**

### 使用方法
EVMスマートコントラクトからx/actモジュールを呼び出すことができます。これにはx/actプレコンパイルを使用します。

### 概念

#### Rule（ルール）
Rule構造体は、何かを実行する前に満たすべきユーザー定義の条件を表します。

ユーザーは、Intent-Specific Languageで表現された条件を使用してルールをオンチェーンに登録できます。

#### Action（アクション）
アクションは他のメッセージをラップします。各アクションにはルールが含まれており、ルールの条件が満たされるとラップされたメッセージが実行されます。

アクションが作成されると、状態は「保留」となり、ラップされたメッセージが実行されると、アクションの状態は「完了」に変更されます。アクションの作成者は、アクションの状態をいつでも「取り消し」に変更できます。

#### Intent-Specific Language（特定意図言語）
特定意図言語（ISL）は、ルールを定義するための非常に簡単なスマートコントラクト言語として設計されています。

```bash
any(2, [warden1jdeysw88gtzz8da6qr6cqepl7ghleane5u46yh, warden1r4d7gh3ysfy3dz3nufpsmj4ad6t5qz2cs33xu3])
```

## 状態
x/act モジュールは、次の主要なオブジェクトの状態を保持します。

- ルール（Rules）
- アクション（Actions）

この状態を管理するために、モジュールは以下のインデックスも保持します。

- ルールで参照されたアドレスごとのアクション
- フック（Hooks）

## フック
このセクションでは、他のモジュールが x/act モジュールにどのようにフックできるか、そしてその動作をカスタマイズする方法について説明します。

### ルールハンドラー
ルールハンドラーは、アクションに適用されるルールを返すハンドラーです。

各ルールハンドラーは特定のメッセージタイプに関連付けられています。新しいアクションが作成されると、x/act モジュールはそのメッセージタイプに対応するルールハンドラーを呼び出します。

ハンドラーはアクションの作成時に一度だけ呼び出され、アクションのルールが再評価されるたびに呼び出されることはありません。

#### 例
以下のコードサンプルは、ダミーの x/satellites モジュールです。このモジュールは、`MsgLaunchSatellite` メッセージのルールを取得するためのハンドラーを登録します。

```go
package keeper

import (
  // ...
  acttypes "github.com/warden-protocol/wardenprotocol/warden/x/act/types/v1beta1"
)

func NewKeeper(
  // ...
  actKeeper types.ActKeeper,
) Keeper {
  // ...

  k := Keeper{...}
  acttypes.Register(reg, k.launchSatelliteRule)

  return k
}

func (k Keeper) launchSatelliteRule(ctx context.Context, msg *types.MsgLaunchSatellite) (acttypes.Rule, error) {
  // 例えば、ここでデータベースにアクセスして特定のルールを取得できます
  satellite, err := k.satellites.Get(ctx, msg.SatelliteID)
  return satellite.LaunchRule, err
}
```

新しい MsgLaunchSatellite メッセージを持つアクションが作成されるたびに、x/act モジュールは launchSatelliteRule を呼び出して、特定の衛星に適用されるルールを取得します。

ルール前処理
ルールハンドラーが呼び出され、ルールが取得された後、x/act モジュールは登録されたルールの前処理を呼び出します。これにより、他のモジュールがルールの式内の識別子を値に展開することができ、マクロ展開のような動作を実現します。

例
app.go で前処理を登録できます。例えば、前のセクションのダミーの x/satellites モジュールのための展開器は次のように見えます。

```go
appConfig = depinject.Configs(
  AppConfig(),
  depinject.Supply(
    // ...
    func() ast.Expander {
      return cosmoshield.NewExpanderManager(
        cosmoshield.NewPrefixedExpander(
          satellitetypes.ModuleName,
          app.SatelliteKeeper.ShieldExpander(),
        ),
        // 他の展開器を追加できます
      )
    },
```

PrefixedExpander は、モジュール名（satellitetypes.ModuleName）で始まり、ドットで区切られた識別子を処理します。ShieldExpander は残りの識別子を受け取り、それを置き換えるための抽象構文木ノードを返します。

SatelliteKeeper は次のような展開器を実装することができます。

```go
// ast.Expander は次のように定義されています：
type Expander interface {
 Expand(ctx context.Context, ident *Identifier) (Expression, error)
}

type SatelliteExpander struct{Keeper}

func (k Keeper) ShieldExpander() ast.Expander { return SatelliteExpander{k} }

func (e SatelliteExpander) Expand(ctx context.Context, ident *Identifier) (Expression, error) {
 if ident.Name == "123.cost" {
   cost := e.k.GetSatelliteCost(ctx, 123) // Keeperから提供されたデータにアクセス
   return ast.NewIntegerLiteral(&ast.IntegerLiteral{
     Value: cost,
   }), nil
 }
 return nil, fmt.Errorf("unknown identifier: %s", ident.Value)
}
```

ユーザーは次のようなルールを書けます。例えば、衛星のコストが 100 以下の場合は自動的に打ち上げを承認する、または 3 人の承認者のうち 2 人以上を要求する場合です。

```text
satellite.123.cost <= 100 || any(2, [warden1j6yh, warden1rxu3, warden1r4d7])
```

アクションが作成されると、ルールは展開器によって前処理され、次のような新しいルールになります（衛星 123 のコストが 900 の場合）。

```text
900 <= 100 || any(2, [warden1j6yh, warden1rxu3, warden1r4d7])
```

## ルール評価

警告
この機能は現在開発中で、まだ利用できません。

x/act モジュールは、保留中のアクションのルールを再評価して、現在のブロックチェーンの状態で満たされているかどうかを確認します。

アクションが承認されるたびに、そのアクションは再評価されます。評価中、前処理後に残った識別子には環境内に対応する値が関連付けられている必要があります。

例
前処理の例では、値はアクションが作成される際に一度だけ取得される必要がありました。これに対して、評価の例では、値は実行時環境で提供され、毎回評価時に再取得されます。この方法は、時間とともに変化する値に適しています。

app.go でモジュール環境を登録できます。例えば、ダミーの x/satellites モジュールのために環境を登録する方法は次のようになります。

```go
appConfig = depinject.Configs(
  AppConfig(),
  depinject.Supply(
    // ...
    func() shield.Environment {
      return cosmoshield.NewEnvironmentManager(
        cosmoshield.NewPrefixedEnvironment(
          satellitetypes.ModuleName,
          app.SatelliteKeeper.ShieldEnv(),
        ),
        // 他の環境を追加できます
      )
    },
```

PrefixedEnvironment は、モジュール名（satellitetypes.ModuleName）で始まり、ドットで区切られた識別子を処理します。ShieldEnv は識別子名を受け取り、その値を返します。

```go
type SatelliteEnv struct{Keeper}

func (k Keeper) ShieldEnv() ast.Env { return SatelliteEnv{k} }

func (e SatelliteEnv) Get(ctx context.Context, name string) (object.Object, bool) {
  if name == "fuel_price" {
    price := e.k.FuelPrice(ctx) // Keeperから提供されたデータにアクセス
    return object.NewInteger(price), true
  }

  // false を返すと、識別子が見つからないことを意味し、
  // ルールの評価がエラーで中止されます
  return nil, false
}
```

ユーザーは次のようなルールを書けます。例えば、燃料コストが 100 以下になるまで打ち上げを保留にする場合です。

```txt
satellite.fuel_price < 100
```

## メッセージ

### MsgNewRule
指定された人間が読める名前で新しいルールを作成します。このルールは、抽象構文木に解析され、オンチェーンに保存される式（文字列）を含みます。

このメッセージは次の場合に失敗することが予想されます：

### 名前が空である
式が無効な Intent-Specific Language の式である

### MsgUpdateRule
既存のルールを指定された人間が読める名前と新しい式で更新します。

このメッセージは次の場合に失敗することが予想されます：

### 名前が空である
式が無効な Intent-Specific Language の式である

### MsgNewAction
ラップされたメッセージで新しいアクションを作成し、オプションでタイムアウト高さを指定します。

このメッセージ実行中に、x/act モジュールはラップされたメッセージタイプのための登録されたルールハンドラーを呼び出し、ルールを適用します。

### MsgUpdateAction
既存のアクションを更新します。このメッセージは、タイムアウトがまだ発生していない場合にのみ成功します。


## MsgNewAction
新しいアクションを作成し、ラップされたメッセージとオプションでタイムアウト高さを指定します。

このメッセージの実行中、x/actモジュールはラップされたメッセージタイプに対して登録されたルールハンドラーを呼び出します。最終的なルールはアクションのルールフィールドに保存されます。

このメッセージは以下のケースで失敗することが予想されます：

- メッセージに登録されたルールハンドラーがない。
- タイムアウト高さが過去の日付である。

## MsgApproveAction
指定されたIDのアクションに対して承認を追加します。

このメッセージは以下のケースで失敗することが予想されます：

- このアドレスからの承認がすでに存在している。
- アクションの状態が保留中ではない。

## MsgRevokeAction
保留中のアクションを取り消し、その実行を中止します。

このメッセージは以下のケースで失敗することが予想されます：

- メッセージの作成者がアクションの作成者でない。
- アクションの状態が保留中ではない（ACTION_STATUS_PENDING）。

## 外部モジュール

## 概要
このセクションでは、Wardenプロトコルで使用される外部Cosmos SDKモジュールの説明を紹介します。詳細については、提供されたリンクから外部ドキュメントをご確認ください。

## x/evm
x/evmモジュールは、Evmosによって提供されるCosmos SDKモジュールで、スマートコントラクトのデプロイ、Ethereum仮想マシン（EVM）との相互作用、およびEVMツールの使用を可能にします。

x/evmを使用するには、以下のガイドに従ってください：

- EVMコントラクトのデプロイ
- 詳細はこちら：
  - Evmosドキュメントのx/evm
  - GitHubのx/evm

## x/wasm
x/wasmモジュールは、特定のメッセージを処理し、それを使用してスマートコントラクトをアップロード、インスタンス化、実行するCosmos SDKモジュールです。これは、Cosmos SDK上に構築された任意のブロックチェーンに統合可能なスマートコントラクトプラットフォームであるCosmWasmの重要な部分です。

x/wasmを使用するには、以下のガイドに従ってください：

- WASMコントラクトのデプロイ
- 詳細はこちら：
  - CosmWasmコントラクトのセマンティクス
  - GitHubのx/wasm

## x/gmp
x/gmpモジュールは、Axelar GMP（一般的なメッセージ送信）を可能にするCosmos SDKモジュールです。これにより、EVMおよびCosmosチェーン間でメッセージとデータを送受信できます。

GMPは、1つのチェーン上のスマートコントラクトが別のチェーン上のスマートコントラクトにメッセージやデータを送信することを可能にします。この技術は、トークン転送、データ共有、チェーン間でのアクションのトリガーなど、さまざまな目的で使用できます。

x/gmpを使用するには、以下のガイドに従ってください：

- クロスチェーンアプリのデプロイ
- 詳細はこちら：
  - Cosmos GMPドキュメント
  - Axelar GMP SDKのGitHub
  - Wardenドキュメント: ブリッジング

## x/oracle
x/oracleモジュールは、Skip Protocolによって提供されるCosmos SDKモジュールで、Skip:Connect（オラクルサービス）に価格をオンチェーンで保存することを可能にします。

詳細はこちら：
- Connectドキュメント
- GitHubのx/oracle
- Wardenドキュメント: オラクルサービス



### 参考文献
1. [WardenProtocol - 公式サイト](https://wardenprotocol.org/)
2. [WardenProtocol - 開発者ドキュメント](https://docs.wardenprotocol.org/)
3. [Youtube](https://www.youtube.com/c/NodesGuru)
4. [GitHub](https://github.com/nodesguru)
5. [テストネット Explorer](https://testnet.warden.explorers.guru/)
6. [Build an app](https://docs.wardenprotocol.org/build-an-app/introduction)
7. [Build a keychain](https://docs.wardenprotocol.org/build-a-keychain/introduction)
8. [Warden protocol faucet](https://faucet.chiado.wardenprotocol.org/)
9. [Warden protocol Spaceward](https://spaceward.chiado.wardenprotocol.org/)
10. [GitHub - warndenprotol](https://github.com/warden-protocol/wardenprotocol/tree/main)
11. [Example Oapps](https://docs.wardenprotocol.org/build-an-app/examples-of-oapps)
12. [Npm - wardenjs](https://www.npmjs.com/package/@wardenprotocol/wardenjs)